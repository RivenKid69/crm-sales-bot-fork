"""Markdown documentation generator.

Generates structured Markdown documentation from analysis results,
including README, module documentation, API docs, and project structure.
"""

import re
from dataclasses import dataclass, field
from pathlib import Path
from typing import Any

from jinja2 import Environment, PackageLoader, select_autoescape, BaseLoader, TemplateNotFound

from ..analyzer.models import (
    AnalysisResult,
    ArchitectureSummary,
    EntitySummary,
    ModuleSummary,
)
from ..utils.logging import get_logger

logger = get_logger("markdown_generator")


@dataclass
class GeneratorConfig:
    """Configuration for the markdown generator."""

    # Output settings
    create_module_docs: bool = True
    create_api_docs: bool = True
    create_structure: bool = True

    # Content settings
    include_mermaid_diagrams: bool = True
    include_code_samples: bool = True
    max_entities_per_module: int = 50

    # Formatting
    title: str = "Project Documentation"
    language: str = "en"


class StringLoader(BaseLoader):
    """Jinja2 loader for string templates."""

    def __init__(self, templates: dict[str, str]):
        self.templates = templates

    def get_source(self, environment, template):
        if template in self.templates:
            source = self.templates[template]
            return source, template, lambda: True
        raise TemplateNotFound(template)


# Default templates stored as strings
DEFAULT_TEMPLATES = {
    "readme.md.jinja": """# {{ title or "Project Documentation" }}

## Overview

{{ architecture.overview if architecture else "No architecture overview available." }}

{% if architecture and architecture.patterns_detected %}
## Architecture Patterns

{{ architecture.patterns_detected | join(", ") }}
{% endif %}

{% if modules %}
## Modules

{% for module in modules %}
- [{{ module.name }}](modules/{{ module.name | slugify }}.md) - {{ module.summary }}

{% endfor %}
{% endif %}

{% if architecture and architecture.tech_stack %}
## Tech Stack

{% for tech in architecture.tech_stack %}
- {{ tech }}
{% endfor %}
{% endif %}

{% if architecture and architecture.data_flow %}
## Data Flow

{{ architecture.data_flow }}
{% endif %}

{% if architecture and architecture.key_components %}
## Key Components

{% for component in architecture.key_components %}
- {{ component }}
{% endfor %}
{% endif %}

{% if architecture and architecture.diagram_mermaid %}
## Architecture Diagram

```mermaid
{{ architecture.diagram_mermaid }}
```
{% endif %}

---

*Generated by Codebase-Analyzer*
""",

    "module.md.jinja": """# {{ module.name }}

{{ module.summary }}

{% if module.responsibilities %}
## Responsibilities

{% for resp in module.responsibilities %}
- {{ resp }}
{% endfor %}
{% endif %}

{% if module.domains %}
## Domains

This module covers the following business domains:

{% for domain in module.domains %}
- {{ domain }}
{% endfor %}
{% endif %}

{% if module.dependencies %}
## Dependencies

This module depends on:

{% for dep in module.dependencies %}
- {{ dep }}
{% endfor %}
{% endif %}

{% if module.exports %}
## Main Exports

{% for export in module.exports %}
- `{{ export }}`
{% endfor %}
{% endif %}

{% if entities %}
## Components

{% for entity in entities %}
### {{ entity.entity_id.split("::")[-1] }}

{{ entity.summary }}

**Purpose:** {{ entity.purpose }}

{% if entity.key_behaviors %}
**Key Behaviors:**
{% for behavior in entity.key_behaviors %}
- {{ behavior }}
{% endfor %}
{% endif %}

{% if entity.dependencies_used %}
**Uses:** {{ entity.dependencies_used | join(", ") }}
{% endif %}

---

{% endfor %}
{% endif %}

## Metrics

- **Entities:** {{ module.entity_count }}
- **Total Lines:** {{ module.total_lines }}

---

*Generated by Codebase-Analyzer*
""",

    "structure.md.jinja": """# Project Structure

## Overview

{% if stats %}
- **Total Entities:** {{ stats.total_entities }}
- **Total Modules:** {{ stats.total_modules }}
- **Model Used:** {{ stats.model_used }}
{% endif %}

{% if modules_by_size %}
## Modules by Size

| Module | Entities | Lines |
|--------|----------|-------|
{% for module in modules_by_size %}
| {{ module.name }} | {{ module.entity_count }} | {{ module.total_lines }} |
{% endfor %}
{% endif %}

{% if domains %}
## Business Domains

{% for domain, count in domains.items() %}
- **{{ domain }}**: {{ count }} entities
{% endfor %}
{% endif %}

{% if processing_levels %}
## Dependency Levels

The codebase can be processed in {{ processing_levels | length }} levels:

{% for level_idx, level in enumerate(processing_levels) %}
### Level {{ level_idx }}
{{ level | length }} entities can be processed in parallel at this level.

{% endfor %}
{% endif %}

---

*Generated by Codebase-Analyzer*
""",

    "api.md.jinja": """# API Documentation

{% if has_api_entities %}
{% for entity in api_entities %}
## {{ entity.entity_id.split("::")[-1] }}

{{ entity.summary }}

**Purpose:** {{ entity.purpose }}

{% if entity.key_behaviors %}
### Behaviors

{% for behavior in entity.key_behaviors %}
- {{ behavior }}
{% endfor %}
{% endif %}

---

{% endfor %}
{% else %}
No API endpoints or public interfaces were detected in this codebase.
{% endif %}

---

*Generated by Codebase-Analyzer*
""",
}


def slugify(text: str) -> str:
    """Convert text to URL-friendly slug."""
    text = text.lower()
    text = re.sub(r'[^\w\s-]', '', text)
    text = re.sub(r'[\s_-]+', '-', text)
    text = text.strip('-')
    return text or 'unnamed'


def basename(path: str) -> str:
    """Get the base name from a path."""
    return Path(path).name


class MarkdownGenerator:
    """Generate Markdown documentation from analysis results.

    Creates a complete documentation structure including:
    - README.md with architecture overview
    - Module-specific documentation
    - API documentation
    - Project structure overview
    """

    def __init__(
        self,
        config: GeneratorConfig | None = None,
        custom_templates: dict[str, str] | None = None,
    ):
        """Initialize the generator.

        Args:
            config: Generator configuration
            custom_templates: Optional custom Jinja templates
        """
        self.config = config or GeneratorConfig()

        # Merge custom templates with defaults
        templates = {**DEFAULT_TEMPLATES}
        if custom_templates:
            templates.update(custom_templates)

        # Setup Jinja environment
        self.template_env = Environment(
            loader=StringLoader(templates),
            autoescape=select_autoescape(default=False),
            trim_blocks=True,
            lstrip_blocks=True,
        )

        # Add custom filters
        self.template_env.filters['slugify'] = slugify
        self.template_env.filters['basename'] = basename

        # Add enumerate to globals for templates
        self.template_env.globals['enumerate'] = enumerate

    def generate(
        self,
        result: AnalysisResult,
        output_dir: Path,
    ) -> list[Path]:
        """Generate complete documentation.

        Args:
            result: Analysis result to document
            output_dir: Directory to write documentation

        Returns:
            List of generated file paths
        """
        output_dir.mkdir(parents=True, exist_ok=True)
        generated_files: list[Path] = []

        # 1. Generate README.md
        readme_path = self._generate_readme(result, output_dir)
        generated_files.append(readme_path)
        logger.info(f"Generated README: {readme_path}")

        # 2. Generate module documentation
        if self.config.create_module_docs and result.module_summaries:
            modules_dir = output_dir / "modules"
            modules_dir.mkdir(exist_ok=True)

            for path, module in result.module_summaries.items():
                module_path = self._generate_module_doc(
                    module, result.entity_summaries, modules_dir
                )
                generated_files.append(module_path)

            logger.info(f"Generated {len(result.module_summaries)} module docs")

        # 3. Generate API documentation
        if self.config.create_api_docs:
            api_path = self._generate_api_docs(result, output_dir)
            generated_files.append(api_path)
            logger.info(f"Generated API docs: {api_path}")

        # 4. Generate structure overview
        if self.config.create_structure:
            structure_path = self._generate_structure(result, output_dir)
            generated_files.append(structure_path)
            logger.info(f"Generated structure: {structure_path}")

        logger.info(f"Generated {len(generated_files)} documentation files")
        return generated_files

    def _generate_readme(
        self,
        result: AnalysisResult,
        output_dir: Path,
    ) -> Path:
        """Generate main README.md."""
        template = self.template_env.get_template("readme.md.jinja")

        # Prepare modules list sorted by entity count
        modules = sorted(
            result.module_summaries.values(),
            key=lambda m: m.entity_count,
            reverse=True,
        )

        content = template.render(
            title=self.config.title,
            architecture=result.architecture,
            modules=modules,
        )

        readme_path = output_dir / "README.md"
        readme_path.write_text(content, encoding="utf-8")
        return readme_path

    def _generate_module_doc(
        self,
        module: ModuleSummary,
        entity_summaries: dict[str, EntitySummary],
        output_dir: Path,
    ) -> Path:
        """Generate documentation for a single module."""
        template = self.template_env.get_template("module.md.jinja")

        # Get entity summaries for this module
        entities = [
            entity_summaries[eid]
            for eid in module.entities[:self.config.max_entities_per_module]
            if eid in entity_summaries
        ]

        content = template.render(
            module=module,
            entities=entities,
        )

        filename = slugify(module.name) + ".md"
        module_path = output_dir / filename
        module_path.write_text(content, encoding="utf-8")
        return module_path

    def _generate_api_docs(
        self,
        result: AnalysisResult,
        output_dir: Path,
    ) -> Path:
        """Generate API documentation."""
        template = self.template_env.get_template("api.md.jinja")

        # Find entities that look like API endpoints or public interfaces
        api_entities = []
        api_keywords = ["api", "endpoint", "handler", "controller", "route", "service"]

        for entity_id, summary in result.entity_summaries.items():
            entity_lower = entity_id.lower()
            summary_lower = summary.summary.lower()

            if any(kw in entity_lower or kw in summary_lower for kw in api_keywords):
                api_entities.append(summary)

        content = template.render(
            has_api_entities=bool(api_entities),
            api_entities=api_entities,
        )

        api_path = output_dir / "API.md"
        api_path.write_text(content, encoding="utf-8")
        return api_path

    def _generate_structure(
        self,
        result: AnalysisResult,
        output_dir: Path,
    ) -> Path:
        """Generate project structure overview."""
        template = self.template_env.get_template("structure.md.jinja")

        # Sort modules by size
        modules_by_size = sorted(
            result.module_summaries.values(),
            key=lambda m: m.entity_count,
            reverse=True,
        )

        # Count entities by domain
        domains: dict[str, int] = {}
        for summary in result.entity_summaries.values():
            domain = summary.domain or "unknown"
            domains[domain] = domains.get(domain, 0) + 1

        # Sort domains by count
        domains = dict(sorted(domains.items(), key=lambda x: x[1], reverse=True))

        content = template.render(
            stats={
                "total_entities": result.total_entities,
                "total_modules": result.total_modules,
                "model_used": result.model_used,
            },
            modules_by_size=modules_by_size[:20],  # Top 20
            domains=domains,
            processing_levels=result.processing_levels,
        )

        structure_path = output_dir / "STRUCTURE.md"
        structure_path.write_text(content, encoding="utf-8")
        return structure_path

    def generate_single_module(
        self,
        module: ModuleSummary,
        entity_summaries: dict[str, EntitySummary],
    ) -> str:
        """Generate markdown for a single module without writing to file.

        Useful for previewing or streaming documentation.

        Args:
            module: Module summary
            entity_summaries: Dictionary of entity summaries

        Returns:
            Markdown content as string
        """
        template = self.template_env.get_template("module.md.jinja")

        entities = [
            entity_summaries[eid]
            for eid in module.entities[:self.config.max_entities_per_module]
            if eid in entity_summaries
        ]

        return template.render(
            module=module,
            entities=entities,
        )

    def generate_readme_content(
        self,
        result: AnalysisResult,
    ) -> str:
        """Generate README content without writing to file.

        Args:
            result: Analysis result

        Returns:
            README markdown content
        """
        template = self.template_env.get_template("readme.md.jinja")

        modules = sorted(
            result.module_summaries.values(),
            key=lambda m: m.entity_count,
            reverse=True,
        )

        return template.render(
            title=self.config.title,
            architecture=result.architecture,
            modules=modules,
        )


def generate_documentation(
    result: AnalysisResult,
    output_dir: Path,
    config: GeneratorConfig | None = None,
) -> list[Path]:
    """Convenience function for generating documentation.

    Args:
        result: Analysis result to document
        output_dir: Output directory
        config: Optional generator configuration

    Returns:
        List of generated file paths
    """
    generator = MarkdownGenerator(config=config)
    return generator.generate(result, output_dir)
