Conditional Rules: Полное резюме
Часть 1: ТЕКУЩЕЕ СОСТОЯНИЕ
1.1 Как работает система сейчас

┌─────────────────────────────────────────────────────────────────────────────┐
│                           ТЕКУЩАЯ АРХИТЕКТУРА                               │
└─────────────────────────────────────────────────────────────────────────────┘

                              config.py
                    ┌─────────────────────────┐
                    │  SALES_STATES = {       │
                    │    "spin_situation": {  │
                    │      "rules": {         │
                    │        "price_question":│──────► "deflect_and_continue"
                    │        "greeting":      │──────► "acknowledge"
                    │        "rejection":     │──────► "handle_rejection"
                    │      }                  │            │
                    │    }                    │            │
                    │  }                      │            │
                    └─────────────────────────┘            │
                                                          │
                                                          ▼
                              state_machine.py            │
                    ┌─────────────────────────┐           │
                    │  def apply_rules():     │           │
                    │                         │           │
                    │    rule = rules[intent] │◄──────────┘
                    │    return rule, state   │  ← Просто возвращает строку
                    │                         │    Никакой логики!
                    └─────────────────────────┘
Ключевой момент: Rules — это просто строки. Одна строка = один action. Всегда.

1.2 Проблема: Нужна условная логика
Бизнес-требование: "Если клиент спросил о цене И мы уже знаем размер команды — ответить на вопрос. Если не знаем — спросить размер."


                    ┌─────────────────────────────────────────┐
                    │  Клиент: "Сколько стоит?"               │
                    └─────────────────────────────────────────┘
                                       │
                                       ▼
                    ┌─────────────────────────────────────────┐
                    │  intent = "price_question"              │
                    │  rule = "deflect_and_continue"          │
                    └─────────────────────────────────────────┘
                                       │
                       ┌───────────────┴───────────────┐
                       ▼                               ▼
              Данных НЕТ                        Данные ЕСТЬ
              collected_data = {}               collected_data = {
                                                  company_size: 10
                                                }
                       │                               │
                       ▼                               ▼
              deflect_and_continue              deflect_and_continue
              "Сколько человек?"                "Сколько человек?"
                     ✓                                 ✗
              ПРАВИЛЬНО                         НЕПРАВИЛЬНО!
                                                Должен ответить на цену
1.3 Текущее решение: Костыли в коде

# state_machine.py — СЕЙЧАС

def apply_rules(self, intent: str):
    rules = config.get("rules", {})
    
    if intent in rules:
        rule_action = rules[intent]
        
        # ═══════════════════════════════════════════════════════
        # КОСТЫЛЬ #1: Price Deflect Loop Bug
        # ═══════════════════════════════════════════════════════
        if intent == "price_question" and rule_action == "deflect_and_continue":
            has_pricing_data = self.collected_data.get("company_size") or \
                              self.collected_data.get("users_count")
            if has_pricing_data:
                return "answer_with_facts", self.state
        
        # КОСТЫЛЬ #2: (будущий) Эскалация при повторах
        # if intent == "price_question" and self.price_question_count > 3:
        #     return "answer_with_range", self.state
        
        # КОСТЫЛЬ #3: (будущий) Competitor handling
        # if intent == "comparison" and self.collected_data.get("competitor"):
        #     return "compare_with_competitor", self.state
        
        return rule_action, self.state
Проблемы:

Проблема	Описание
Hardcoded	Каждое условие = новый if в коде
Не масштабируется	10 условий = 10 if'ов
Логика размазана	Часть в config.py, часть в state_machine.py
Сложно тестировать	Нужно поднимать весь SM для теста условия
Сложно понять	Чтобы узнать поведение, нужно читать код
1.4 Выявленные случаи где нужны условия
Из анализа simulation_report.txt и кода:

№	Интент	Условие	Результат
1	price_question	Есть company_size/users_count	answer_with_facts (action)
2	price_question	Повторился 3+ раз	answer_with_range (action)
3	pricing_details	Есть company_size	answer_with_facts (action)
4	comparison	Известен конкурент	compare_specific (action)
5	objection_price	Есть pain_point + company_size	handle_with_roi (action)
6	question_technical	Повторился 2+ раз	offer_documentation (action)
7	demo_request	В фазе close	success (transition)
Часть 2: ЦЕЛЬ РЕФАКТОРИНГА
2.1 Что хотим получить

┌─────────────────────────────────────────────────────────────────────────────┐
│                           ЦЕЛЕВАЯ АРХИТЕКТУРА                               │
└─────────────────────────────────────────────────────────────────────────────┘

                              config.py
                    ┌──────────────────────────────────────┐
                    │  "rules": { ... }                    │
                    │  "transition_rules": { ... }         │
                    └──────────────────────────────────────┘
                                       │
                                       ▼
                              state_machine.py
                    ┌──────────────────────────────────────┐
                    │  def apply_rules():                  │
                    │    action = _resolve_action(...)     │
                    │    next_state = _resolve_transition(...) │
                    │    return action, next_state         │
                    └──────────────────────────────────────┘
                                       │
                                       ▼
                    ┌──────────────────────────────────────┐
                    │  _resolve_action(rule)               │
                    │  _resolve_transition(rule)           │
                    │    uses condition_evaluator          │
                    └──────────────────────────────────────┘
2.2 Принципы
Принцип	Описание
Декларативность	Вся логика описана в config.py, не в коде
Единый источник правды	Хочешь узнать поведение — смотри config
Разделение ответственности	rules отвечают только за action, transition_rules только за переходы
Расширяемость	Новое условие = новый тип в resolver, используй везде
Обратная совместимость	Старые правила-строки продолжают работать
Тестируемость	Условия можно тестировать изолированно
Отказоустойчивость	Жёсткая валидация в CI, мягкий fallback + лог/метрики в runtime
Часть 3: ДЕТАЛЬНОЕ ОПИСАНИЕ РЕШЕНИЯ
3.1 Формат rules и transition_rules (Schema)

# Простое action-правило (обратная совместимость)
"greeting": "acknowledge_and_continue"

# Условное action-правило
"price_question": {
    "default": "deflect_and_continue",      # Действие по умолчанию
    "conditions": [                          # Список условий (проверяются по порядку)
        {
            "when": { ... },                 # Условие (см. типы ниже)
            "then": "answer_with_facts"      # Действие если условие true
        },
        {
            "when": { ... },
            "then": "another_action"
        }
    ]
}

# Простое transition-правило (переопределяет transitions)
"demo_request": "success"

# Условное transition-правило
"demo_request": {
    "conditions": [
        {
            "when": {"state_in": ["close"]},
            "then": "success"
        }
    ],
    "default": None  # None → использовать обычные transitions/SPIN-логику
}
3.2 Типы условий (Condition Types)

┌─────────────────────────────────────────────────────────────────────────────┐
│                           ТИПЫ УСЛОВИЙ                                      │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │  1. has_any                                                         │   │
│  │     Проверяет: есть ли ЛЮБОЕ из указанных полей в collected_data    │   │
│  │                                                                     │   │
│  │     "when": {"has_any": ["company_size", "users_count"]}            │   │
│  │                                                                     │   │
│  │     collected_data = {}                    → False                  │   │
│  │     collected_data = {company_size: 10}    → True                   │   │
│  │     collected_data = {users_count: 5}      → True                   │   │
│  │     collected_data = {pain_point: "..."}   → False                  │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│                                                                             │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │  2. has_all                                                         │   │
│  │     Проверяет: есть ли ВСЕ указанные поля в collected_data          │   │
│  │                                                                     │   │
│  │     "when": {"has_all": ["company_size", "pain_point"]}             │   │
│  │                                                                     │   │
│  │     collected_data = {company_size: 10}                → False      │   │
│  │     collected_data = {company_size: 10, pain_point: "x"} → True     │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│                                                                             │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │  3. intent_repeated                                                 │   │
│  │     Проверяет: повторился ли интент N+ раз подряд (по умолчанию)    │   │
│  │     или в окне последних N (scope="window")                         │   │
│  │                                                                     │   │
│  │     "when": {"intent_repeated": {"min": 3}}                         │   │
│  │     "when": {"intent_repeated": {"min": 2, "scope": "window",        │   │
│  │                                 "window": 5}}                       │   │
│  │                                                                     │   │
│  │     intent_streak["price_question"] = 2    → False                  │   │
│  │     intent_streak["price_question"] = 3    → True                   │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│                                                                             │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │  4. spin_phase_in                                                   │   │
│  │     Проверяет: текущая SPIN-фаза в списке                           │   │
│  │     Для presentation/close используйте state_in                     │   │
│  │                                                                     │   │
│  │     "when": {"spin_phase_in": ["implication", "need_payoff"]}        │   │
│  │                                                                     │   │
│  │     spin_phase = "situation"    → False                             │   │
│  │     spin_phase = "need_payoff"  → True                              │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│                                                                             │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │  5. state_in                                                        │   │
│  │     Проверяет: текущее состояние в списке                           │   │
│  │                                                                     │   │
│  │     "when": {"state_in": ["presentation", "close"]}                 │   │
│  │                                                                     │   │
│  │     state = "spin_problem"         → False                          │   │
│  │     state = "close"                → True                           │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│                                                                             │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │  6. field_equals                                                    │   │
│  │     Проверяет: поле равно конкретному значению                      │   │
│  │                                                                     │   │
│  │     "when": {"field_equals": {"urgency": "high"}}                   │   │
│  │                                                                     │   │
│  │     collected_data = {urgency: "low"}   → False                     │   │
│  │     collected_data = {urgency: "high"}  → True                      │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│                                                                             │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │  7. and / or (композиция)                                           │   │
│  │     Комбинирует несколько условий                                   │   │
│  │                                                                     │   │
│  │     "when": {                                                       │   │
│  │       "and": [                                                      │   │
│  │         {"has_any": ["company_size"]},                              │   │
│  │         {"state_in": ["presentation", "close"]}                     │   │
│  │       ]                                                             │   │
│  │     }                                                               │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
Контекст evaluator (минимальный набор):
- collected_data
- state
- spin_phase
- intent_history
- intent_counts / intent_streak
- last_intent
3.3 Порядок проверки условий (rules/transition_rules)

              Вход: rule/transition_rule с conditions
                         │
                         ▼
         ┌───────────────────────────────┐
         │  conditions[0]                │
         │  when: {has_any: [...]}       │
         └───────────────────────────────┘
                         │
                    True? ──────────────────► return conditions[0]["then"]
                         │
                       False
                         │
                         ▼
         ┌───────────────────────────────┐
         │  conditions[1]                │
         │  when: {intent_repeated: 3}   │
         └───────────────────────────────┘
                         │
                    True? ──────────────────► return conditions[1]["then"]
                         │
                       False
                         │
                         ▼
         ┌───────────────────────────────┐
         │  conditions[2]                │
         │  ...                          │
         └───────────────────────────────┘
                         │
                       False
                         │
                         ▼
         ┌───────────────────────────────┐
         │  return rule["default"]       │
         └───────────────────────────────┘
         
         ВАЖНО: Первое сработавшее условие побеждает!
         Порядок условий имеет значение.
3.4 Порядок разрешения action и переходов

Критические ранние выходы (до resolver'ов):
- final
- rejection
- go_back
- objections

Action resolver:
1) rules[intent] (str или conditional)
2) QUESTION_INTENTS → answer_question
3) default → continue_current_goal

Transition resolver:
1) transition_rules[intent] (str или conditional)
2) SPIN progress / SPIN data_complete
3) transitions[intent]
4) non-SPIN data_complete
5) transitions["any"]
6) stay in current state
Часть 4: ПРИМЕРЫ ПРИМЕНЕНИЯ
4.1 Price Question (текущий баг)
До:


# config.py
"price_question": "deflect_and_continue"

# state_machine.py — КОСТЫЛЬ
if intent == "price_question" and rule_action == "deflect_and_continue":
    if self.collected_data.get("company_size"):
        return "answer_with_facts", self.state
После:


# config.py — ВСЯ ЛОГИКА ЗДЕСЬ
"price_question": {
    "default": "deflect_and_continue",
    "conditions": [
        {
            "when": {"has_any": ["company_size", "users_count"]},
            "then": "answer_with_facts"
        }
    ]
}

# state_machine.py — БЕЗ КОСТЫЛЕЙ
# Resolvers обрабатывают всё автоматически
4.2 Эскалация при повторных вопросах о цене

"price_question": {
    "default": "deflect_and_continue",
    "conditions": [
        # Приоритет 1: Если данные есть — ответить
        {
            "when": {"has_any": ["company_size", "users_count"]},
            "then": "answer_with_facts"
        },
        # Приоритет 2: Если спросил 3+ раз — дать диапазон
        {
            "when": {"intent_repeated": {"min": 3}},  # по умолчанию подряд
            "then": "answer_with_price_range"
        }
    ]
}
Сценарий:


Ход 1: "Сколько стоит?"     → deflect (данных нет, повторов 1)
Ход 2: "Ну почем?"          → deflect (данных нет, повторов 2)
Ход 3: "Цену скажи!"        → answer_with_price_range (повторов 3!)
4.3 Умная обработка возражения о цене

"objection_price": {
    "default": "handle_price_objection_generic",
    "conditions": [
        # Если знаем боль и размер — показать ROI
        {
            "when": {"has_all": ["pain_point", "company_size"]},
            "then": "handle_price_with_roi"
        },
        # Если только размер — сравнить с конкурентами
        {
            "when": {"has_any": ["company_size"]},
            "then": "handle_price_with_comparison"
        }
    ]
}
Примечание: правила для objection_* размещаются в состоянии handle_objection,
переход в него управляется transitions/transition_rules.
4.4 Технические вопросы с эскалацией

"question_technical": {
    "default": "answer_technical",
    "conditions": [
        # Если спрашивает повторно — предложить документацию
        {
            "when": {"intent_repeated": {"min": 2}},
            "then": "offer_documentation_link"
        }
    ]
}
4.5 Условный переход (transition_rules)

"transition_rules": {
    "demo_request": {
        "conditions": [
            {
                "when": {"state_in": ["close"]},
                "then": "success"
            }
        ],
        "default": None
    }
}
Комментарий: если условия не сработали, переход определяется обычными transitions/SPIN.
Если transition_rules объявлены внутри конкретного state, state_in можно опустить.
Часть 5: ПЛАН РЕАЛИЗАЦИИ
5.1 Структура изменений

┌─────────────────────────────────────────────────────────────────────────────┐
│                           ФАЙЛЫ ДЛЯ ИЗМЕНЕНИЯ                               │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│  src/                                                                       │
│  ├── state_machine.py          ← _resolve_action + _resolve_transition      │
│  ├── config.py                 ← rules + transition_rules (conditional)     │
│  ├── condition_evaluator.py    ← НОВЫЙ: логика проверки условий             │
│  └── rule_validator.py         ← НОВЫЙ: валидация схемы правил              │
│                                                                             │
│  tests/                                                                     │
│  ├── test_condition_evaluator.py  ← НОВЫЙ: unit-тесты условий               │
│  ├── test_transition_rules.py     ← НОВЫЙ: интеграционные тесты             │
│  └── test_state_machine.py        ← Обновить существующие тесты             │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
5.2 Этапы

┌─────────────────────────────────────────────────────────────────────────────┐
│  ЭТАП 1: Схема config + контракт контекста                                  │
├─────────────────────────────────────────────────────────────────────────────┤
│  1. Зафиксировать разделение rules vs transition_rules                      │
│  2. Определить семантику intent_repeated (consecutive + window)             │
│  3. Добавить condition state_in                                             │
└─────────────────────────────────────────────────────────────────────────────┘
                                    │
                                    ▼
┌─────────────────────────────────────────────────────────────────────────────┐
│  ЭТАП 2: Condition Evaluator (изолированный модуль)                         │
├─────────────────────────────────────────────────────────────────────────────┤
│  1. Создать src/condition_evaluator.py                                      │
│  2. Реализовать все типы условий                                            │
│  3. Написать unit-тесты для каждого типа                                    │
│  4. Результат: модуль можно тестировать изолированно                        │
└─────────────────────────────────────────────────────────────────────────────┘
                                    │
                                    ▼
┌─────────────────────────────────────────────────────────────────────────────┐
│  ЭТАП 3: Resolvers в State Machine                                          │
├─────────────────────────────────────────────────────────────────────────────┤
│  1. Добавить _resolve_action() и _resolve_transition()                      │
│  2. Интегрировать condition_evaluator                                       │
│  3. Обеспечить обратную совместимость (str rules работают)                  │
│  4. Удалить костыль price_question                                          │
└─────────────────────────────────────────────────────────────────────────────┘
                                    │
                                    ▼
┌─────────────────────────────────────────────────────────────────────────────┐
│  ЭТАП 4: Миграция config.py                                                 │
├─────────────────────────────────────────────────────────────────────────────┤
│  1. Конвертировать price_question в conditional format                      │
│  2. Добавить условия для pricing_details                                    │
│  3. Добавить transition_rules для условных переходов (demo_request и др.)   │
└─────────────────────────────────────────────────────────────────────────────┘
                                    │
                                    ▼
┌─────────────────────────────────────────────────────────────────────────────┐
│  ЭТАП 5: Тестирование                                                       │
├─────────────────────────────────────────────────────────────────────────────┤
│  1. Unit-тесты evaluator                                                    │
│  2. Интеграционные тесты приоритетов action/transition                      │
│  3. Проверка SPIN-прогресса и objections                                    │
└─────────────────────────────────────────────────────────────────────────────┘
                                    │
                                    ▼
┌─────────────────────────────────────────────────────────────────────────────┐
│  ЭТАП 6: Валидация                                                         │
├─────────────────────────────────────────────────────────────────────────────┤
│  1. Жёсткая схема в CI                                                     │
│  2. Мягкий fallback + лог/метрики в runtime                                │
└─────────────────────────────────────────────────────────────────────────────┘
5.3 Обратная совместимость

def _resolve_action(self, rule: Union[str, Dict]) -> str:
    """
    Action resolver с обратной совместимостью.
    """
    # Обратная совместимость: строка работает как раньше
    if isinstance(rule, str):
        return rule

    # Новый формат: dict с conditions
    if isinstance(rule, dict):
        for condition in rule.get("conditions", []):
            if self.evaluator.evaluate(condition["when"], self._get_context()):
                return condition["then"]
        return rule.get("default", "continue_current_goal")

    # Fallback
    return "continue_current_goal"

def _resolve_transition(self, rule: Union[str, Dict]) -> Optional[str]:
    """
    Transition resolver с обратной совместимостью.
    """
    # Обратная совместимость: строка = явный next_state
    if isinstance(rule, str):
        return rule

    # Новый формат: dict с conditions
    if isinstance(rule, dict):
        for condition in rule.get("conditions", []):
            if self.evaluator.evaluate(condition["when"], self._get_context()):
                return condition["then"]
        return rule.get("default")  # None → fallback на transitions/SPIN

    # Fallback
    return None
Это значит:

Все существующие "intent": "action" правила продолжают работать
Все существующие transitions остаются источником переходов по умолчанию
Можно мигрировать правила по одному
Нет "big bang" миграции
Часть 6: ОЖИДАЕМЫЕ РЕЗУЛЬТАТЫ
6.1 До и После
Аспект	До	После
Где логика	config.py + state_machine.py	Только config.py (rules + transition_rules)
Добавить условие	Писать if в коде	Добавить в config
Понять поведение	Читать код SM	Читать config
Тестировать условие	Поднимать весь SM	Unit-тест evaluator
Количество костылей	Растёт	0
6.2 Пример: Как будет выглядеть config.py

SALES_STATES = {
    "spin_situation": {
        "goal": "Понять ситуацию клиента",
        "transitions": { ... },
        "rules": {
            # Простые правила (обратная совместимость)
            "greeting": "acknowledge_and_continue",
            "small_talk": "small_talk_and_continue",
            
            # Условные правила (новый формат)
            "price_question": {
                "default": "deflect_and_continue",
                "conditions": [
                    {
                        "when": {"has_any": ["company_size", "users_count"]},
                        "then": "answer_with_facts"
                    },
                    {
                        "when": {"intent_repeated": {"min": 3}},
                        "then": "answer_with_price_range"
                    }
                ]
            },
            "pricing_details": {
                "default": "deflect_and_continue",
                "conditions": [
                    {
                        "when": {"has_any": ["company_size", "users_count"]},
                        "then": "answer_with_facts"
                    }
                ]
            }
        }
    },
    "close": {
        "goal": "Взять контакт или назначить демо",
        "transitions": { ... },
        "transition_rules": {
            "demo_request": {
                "conditions": [
                    {
                        "when": {"has_any": ["contact_info"]},
                        "then": "success"
                    }
                ],
                "default": None
            }
        }
    },
    # ... остальные состояния
}
Часть 7: ЛОГГИРОВАНИЕ ДЛЯ СИМУЛЯЦИЙ

7.1 Цель
При запуске 50 симуляций нужно точно понимать:
- Почему бот выбрал конкретный action
- Какие условия проверялись и какой был результат
- Какой контекст был на момент принятия решения
- Почему переход пошёл в одно состояние, а не в другое

7.2 Уровни логирования

┌─────────────────────────────────────────────────────────────────────────────┐
│                           УРОВНИ ЛОГОВ                                       │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│  DEBUG   — Детали каждой проверки условия (для отладки конкретной итерации) │
│  INFO    — Финальные решения: action, transition, matched condition         │
│  WARNING — Fallback на default (условия не сработали)                       │
│  EVENT   — Бизнес-события для аналитики (state_transition, rule_matched)    │
│  METRIC  — Числовые метрики (conditions_checked, evaluation_time_ms)        │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘

7.3 Что логируем

┌─────────────────────────────────────────────────────────────────────────────┐
│  1. ВХОД В RESOLVER                                                         │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│  logger.debug("Resolving action",                                           │
│      intent="price_question",                                               │
│      state="spin_situation",                                                │
│      rule_type="conditional",        # "simple" | "conditional"             │
│      conditions_count=2                                                     │
│  )                                                                          │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────────────────┐
│  2. КОНТЕКСТ ДЛЯ EVALUATOR                                                  │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│  logger.debug("Evaluation context",                                         │
│      collected_data={"company_size": 10, "pain_point": "теряем клиентов"},  │
│      state="spin_situation",                                                │
│      spin_phase="situation",                                                │
│      intent_streak={"price_question": 2},                                   │
│      last_intent="info_provided"                                            │
│  )                                                                          │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────────────────┐
│  3. ПРОВЕРКА КАЖДОГО УСЛОВИЯ                                                │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│  logger.debug("Condition evaluated",                                        │
│      condition_index=0,                                                     │
│      condition_type="has_any",                                              │
│      condition_params=["company_size", "users_count"],                      │
│      result=True,                      # True | False                       │
│      matched_field="company_size"      # какое поле сработало (для has_any) │
│  )                                                                          │
│                                                                             │
│  logger.debug("Condition evaluated",                                        │
│      condition_index=1,                                                     │
│      condition_type="intent_repeated",                                      │
│      condition_params={"min": 3},                                           │
│      result=False,                                                          │
│      actual_streak=2                   # текущее значение streak            │
│  )                                                                          │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────────────────┐
│  4. ФИНАЛЬНОЕ РЕШЕНИЕ                                                       │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│  # Условие сработало                                                        │
│  logger.info("Action resolved",                                             │
│      intent="price_question",                                               │
│      action="answer_with_facts",                                            │
│      resolution="condition_matched",   # "condition_matched" | "default"    │
│      matched_condition_index=0,                                             │
│      matched_condition_type="has_any"                                       │
│  )                                                                          │
│                                                                             │
│  # Ни одно условие не сработало → default                                   │
│  logger.warning("Action resolved via default",                              │
│      intent="price_question",                                               │
│      action="deflect_and_continue",                                         │
│      resolution="default",                                                  │
│      conditions_checked=2,                                                  │
│      all_conditions_failed=True                                             │
│  )                                                                          │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────────────────┐
│  5. TRANSITION RESOLVER (аналогично)                                        │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│  logger.info("Transition resolved",                                         │
│      intent="demo_request",                                                 │
│      from_state="close",                                                    │
│      to_state="success",                                                    │
│      resolution="transition_rule_matched",                                  │
│      matched_condition_type="state_in"                                      │
│  )                                                                          │
│                                                                             │
│  # Fallback на обычные transitions                                          │
│  logger.info("Transition resolved",                                         │
│      intent="demo_request",                                                 │
│      from_state="spin_situation",                                           │
│      to_state="close",                                                      │
│      resolution="transitions_fallback"  # transition_rules не сработали     │
│  )                                                                          │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘

7.4 Бизнес-события (EVENT)

# Для аналитики симуляций
logger.event("conditional_rule_triggered",
    intent="price_question",
    condition_type="has_any",
    action="answer_with_facts",
    simulation_id=42
)

logger.event("conditional_rule_default_used",
    intent="price_question",
    action="deflect_and_continue",
    reason="no_pricing_data",
    simulation_id=42
)

7.5 Метрики (METRIC)

# Производительность evaluator
logger.metric("condition_evaluation",
    conditions_checked=3,
    evaluation_time_ms=0.5,
    intent="price_question"
)

# Статистика по правилам
logger.metric("conditional_rules_stats",
    total_evaluations=150,
    conditions_matched=87,
    defaults_used=63,
    simulation_batch_id="batch_001"
)

7.6 Формат вывода для симуляций

Логи conditional rules встраиваются прямо в секцию диалогов.
Каждый ход показывает rule resolution для быстрой отладки.

┌─────────────────────────────────────────────────────────────────────────────┐
│  ФОРМАТ ДИАЛОГА С RULE RESOLUTION                                           │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│  [Ход 3]                                                                    │
│  Клиент: А сколько это стоит?                                               │
│  Бот: Чтобы назвать точную цену, уточните сколько человек в команде?        │
│    (state=spin_situation, intent=price_question, action=deflect_and_continue)│
│    [RULE] conditional → DEFAULT                                             │
│           has_any(company_size,users_count)=FAIL                            │
│           intent_repeated(3)=FAIL (streak=1)                                │
│                                                                             │
│  [Ход 5]                                                                    │
│  Клиент: Ну так сколько стоит-то?                                           │
│  Бот: При команде из 10 человек стоимость составит 15000₸ в месяц.          │
│    (state=spin_situation, intent=price_question, action=answer_with_facts)  │
│    [RULE] conditional → MATCHED[0]                                          │
│           has_any(company_size,users_count)=PASS (company_size=10)          │
│                                                                             │
│  [Ход 7]                                                                    │
│  Клиент: Расскажите про интеграции                                          │
│  Бот: Мы интегрируемся с 1С, Kaspi, WhatsApp...                             │
│    (state=spin_situation, intent=question_integrations, action=answer_and_continue)
│    [RULE] simple → answer_and_continue                                      │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘

Формат строки [RULE]:
- "simple → action"           — простое правило (строка)
- "conditional → MATCHED[N]"  — сработало условие N
- "conditional → DEFAULT"     — ни одно условие не сработало
- "none → continue_current_goal" — правило не найдено

Детали условий показываются только для conditional rules.
Формат: condition_type(params)=PASS/FAIL (details)

7.6.1 Реализация: как rule info попадает в отчёт

1. StateMachine.apply_rules() возвращает расширенный результат:

# Было:
return action, next_state

# Стало:
return action, next_state, rule_info

# Где rule_info:
{
    "rule_type": "conditional",      # "simple" | "conditional" | "none"
    "resolution": "condition_matched", # "condition_matched" | "default" | "simple"
    "matched_index": 0,              # индекс сработавшего условия (или None)
    "conditions_evaluated": [        # список проверенных условий
        {
            "type": "has_any",
            "params": ["company_size", "users_count"],
            "result": True,
            "details": {"matched_field": "company_size", "value": 10}
        },
        # ... остальные условия (если первое не сработало)
    ]
}

2. Runner записывает rule_info в turn_data:

# В runner.py _run_single()
turn_data = {
    "turn": turn + 1,
    "client": client_message,
    "bot": bot_result.get("response", ""),
    "state": bot_result.get("state", ""),
    "intent": bot_result.get("intent", ""),
    "action": bot_result.get("action", ""),
    "rule_info": bot_result.get("rule_info", {}),  # NEW
}

3. ReportGenerator форматирует rule_info:

# В report.py _section_full_dialogues()
def _format_rule_info(self, rule_info: Dict) -> List[str]:
    """Форматирует rule_info для отчёта"""
    lines = []

    rule_type = rule_info.get("rule_type", "none")
    resolution = rule_info.get("resolution", "")

    if rule_type == "simple":
        lines.append(f"    [RULE] simple → {rule_info.get('action', '?')}")

    elif rule_type == "conditional":
        if resolution == "condition_matched":
            idx = rule_info.get("matched_index", 0)
            lines.append(f"    [RULE] conditional → MATCHED[{idx}]")
        else:
            lines.append(f"    [RULE] conditional → DEFAULT")

        # Детали условий
        for cond in rule_info.get("conditions_evaluated", []):
            result = "PASS" if cond["result"] else "FAIL"
            params = ",".join(str(p) for p in cond["params"]) if isinstance(cond["params"], list) else str(cond["params"])
            detail = f" ({cond['details']})" if cond.get("details") else ""
            lines.append(f"           {cond['type']}({params})={result}{detail}")

    else:
        lines.append(f"    [RULE] none → continue_current_goal")

    return lines

7.7 Конфигурация уровня логирования

# settings.yaml
logging:
  level: INFO                    # Production: INFO, Debug: DEBUG
  conditional_rules:
    enabled: true                # Включить детальное логирование rules
    level: DEBUG                 # Уровень для conditional rules
    log_context: true            # Логировать полный контекст
    log_each_condition: true     # Логировать каждое условие

# Или через environment
CONDITIONAL_RULES_LOG_LEVEL=DEBUG

7.8 Класс RuleLogger (обёртка)

class RuleLogger:
    """
    Специализированный логгер для conditional rules.
    Упрощает логирование и добавляет контекст симуляции.
    """

    def __init__(self, simulation_id: Optional[int] = None):
        self.simulation_id = simulation_id
        self.enabled = settings.get_nested("logging.conditional_rules.enabled", True)
        self.log_context = settings.get_nested("logging.conditional_rules.log_context", True)
        self.log_each_condition = settings.get_nested("logging.conditional_rules.log_each_condition", True)

    def log_resolution_start(self, intent: str, rule_type: str, state: str):
        """Начало разрешения правила"""
        if not self.enabled:
            return
        logger.debug("Resolving rule",
            intent=intent,
            rule_type=rule_type,
            state=state,
            simulation_id=self.simulation_id
        )

    def log_context(self, context: Dict):
        """Логирование контекста evaluator"""
        if not self.enabled or not self.log_context:
            return
        logger.debug("Evaluation context",
            **context,
            simulation_id=self.simulation_id
        )

    def log_condition_result(
        self,
        index: int,
        condition_type: str,
        params: Any,
        result: bool,
        details: Optional[Dict] = None
    ):
        """Результат проверки одного условия"""
        if not self.enabled or not self.log_each_condition:
            return
        log_data = {
            "condition_index": index,
            "condition_type": condition_type,
            "params": params,
            "result": result,
            "simulation_id": self.simulation_id
        }
        if details:
            log_data.update(details)
        logger.debug("Condition evaluated", **log_data)

    def log_resolution_result(
        self,
        intent: str,
        result: str,
        resolution: str,  # "condition_matched" | "default" | "simple_rule"
        matched_index: Optional[int] = None,
        matched_type: Optional[str] = None
    ):
        """Финальный результат разрешения"""
        if not self.enabled:
            return

        log_fn = logger.info if resolution == "condition_matched" else logger.warning
        log_fn("Rule resolved",
            intent=intent,
            result=result,
            resolution=resolution,
            matched_condition_index=matched_index,
            matched_condition_type=matched_type,
            simulation_id=self.simulation_id
        )

7.9 Интеграция с SimulationRunner

# В runner.py
def _run_single(self, sim_id: int, persona_name: str) -> SimulationResult:
    ...
    # Создаём логгер для этой симуляции
    rule_logger = RuleLogger(simulation_id=sim_id)

    # Передаём в бота
    bot = SalesBot(self.bot_llm, rule_logger=rule_logger)
    ...

# В state_machine.py
class StateMachine:
    def __init__(self, rule_logger: Optional[RuleLogger] = None):
        ...
        self.rule_logger = rule_logger or RuleLogger()

7.10 Пример полного лога одного хода

[12:34:56] DEBUG - Resolving rule [intent=price_question, rule_type=conditional, state=spin_situation, simulation_id=10]
[12:34:56] DEBUG - Evaluation context [collected_data={company_size: 10}, state=spin_situation, spin_phase=situation, intent_streak={price_question: 2}, simulation_id=10]
[12:34:56] DEBUG - Condition evaluated [condition_index=0, condition_type=has_any, params=['company_size', 'users_count'], result=True, matched_field=company_size, simulation_id=10]
[12:34:56] INFO - Rule resolved [intent=price_question, result=answer_with_facts, resolution=condition_matched, matched_condition_index=0, matched_condition_type=has_any, simulation_id=10]

Часть 8: РЕЗЮМЕ
Что имеем сейчас
Rules — простые строки
Условная логика — hardcoded костыли в state_machine.py
Логика размазана по файлам
Каждый новый случай = новый if
Что хотим
Rules — декларативные объекты с условиями для action
Transition_rules — декларативные условия для переходов
Условная логика — в config.py
Разделение action/transition
Единый источник правды
Каждый новый случай = строка в config
Как достигнем
Condition Evaluator — изолированный модуль проверки условий
Action/Transition Resolvers — универсальные интерпретаторы правил в SM
Миграция — постепенная, с обратной совместимостью
Валидация — жёстко в CI, мягко в runtime
Зачем это нужно
Сейчас: 1 костыль (price_question)
Через месяц: 5 костылей
Через полгода: 20 костылей, код нечитаем
С рефакторингом: 0 костылей навсегда
