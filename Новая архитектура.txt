Conditional Rules: Полное резюме
Часть 1: ТЕКУЩЕЕ СОСТОЯНИЕ
1.1 Как работает система сейчас

┌─────────────────────────────────────────────────────────────────────────────┐
│                           ТЕКУЩАЯ АРХИТЕКТУРА                               │
└─────────────────────────────────────────────────────────────────────────────┘

                              config.py
                    ┌─────────────────────────┐
                    │  SALES_STATES = {       │
                    │    "spin_situation": {  │
                    │      "rules": {         │
                    │        "price_question":│──────► "deflect_and_continue"
                    │        "greeting":      │──────► "acknowledge"
                    │        "rejection":     │──────► "handle_rejection"
                    │      }                  │            │
                    │    }                    │            │
                    │  }                      │            │
                    └─────────────────────────┘            │
                                                          │
                                                          ▼
                              state_machine.py            │
                    ┌─────────────────────────┐           │
                    │  def apply_rules():     │           │
                    │                         │           │
                    │    rule = rules[intent] │◄──────────┘
                    │    return rule, state   │  ← Просто возвращает строку
                    │                         │    Никакой логики!
                    └─────────────────────────┘
Ключевой момент: Rules — это просто строки. Одна строка = один action. Всегда.

1.2 Проблема: Нужна условная логика
Бизнес-требование: "Если клиент спросил о цене И мы уже знаем размер команды — ответить на вопрос. Если не знаем — спросить размер."


                    ┌─────────────────────────────────────────┐
                    │  Клиент: "Сколько стоит?"               │
                    └─────────────────────────────────────────┘
                                       │
                                       ▼
                    ┌─────────────────────────────────────────┐
                    │  intent = "price_question"              │
                    │  rule = "deflect_and_continue"          │
                    └─────────────────────────────────────────┘
                                       │
                       ┌───────────────┴───────────────┐
                       ▼                               ▼
              Данных НЕТ                        Данные ЕСТЬ
              collected_data = {}               collected_data = {
                                                  company_size: 10
                                                }
                       │                               │
                       ▼                               ▼
              deflect_and_continue              deflect_and_continue
              "Сколько человек?"                "Сколько человек?"
                     ✓                                 ✗
              ПРАВИЛЬНО                         НЕПРАВИЛЬНО!
                                                Должен ответить на цену
1.3 Текущее решение: Костыли в коде

# state_machine.py — СЕЙЧАС

def apply_rules(self, intent: str):
    rules = config.get("rules", {})
    
    if intent in rules:
        rule_action = rules[intent]
        
        # ═══════════════════════════════════════════════════════
        # КОСТЫЛЬ #1: Price Deflect Loop Bug
        # ═══════════════════════════════════════════════════════
        if intent == "price_question" and rule_action == "deflect_and_continue":
            has_pricing_data = self.collected_data.get("company_size") or \
                              self.collected_data.get("users_count")
            if has_pricing_data:
                return "answer_with_facts", self.state
        
        # КОСТЫЛЬ #2: (будущий) Эскалация при повторах
        # if intent == "price_question" and self.price_question_count > 3:
        #     return "answer_with_range", self.state
        
        # КОСТЫЛЬ #3: (будущий) Competitor handling
        # if intent == "comparison" and self.collected_data.get("competitor"):
        #     return "compare_with_competitor", self.state
        
        return rule_action, self.state
Проблемы:

Проблема	Описание
Hardcoded	Каждое условие = новый if в коде
Не масштабируется	10 условий = 10 if'ов
Логика размазана	Часть в config.py, часть в state_machine.py
Сложно тестировать	Нужно поднимать весь SM для теста условия
Сложно понять	Чтобы узнать поведение, нужно читать код
1.4 Выявленные случаи где нужны условия
Из анализа simulation_report.txt и кода:

№	Интент	Условие	Результат
1	price_question	Есть company_size/users_count	answer_with_facts (action)
2	price_question	Повторился 3+ раз	answer_with_range (action)
3	pricing_details	Есть company_size	answer_with_facts (action)
4	comparison	Известен конкурент	compare_specific (action)
5	objection_price	Есть pain_point + company_size	handle_with_roi (action)
6	question_technical	Повторился 2+ раз	offer_documentation (action)
7	demo_request	В фазе close	success (transition)
Часть 2: ЦЕЛЬ РЕФАКТОРИНГА
2.1 Что хотим получить

┌─────────────────────────────────────────────────────────────────────────────┐
│                           ЦЕЛЕВАЯ АРХИТЕКТУРА                               │
└─────────────────────────────────────────────────────────────────────────────┘

                              config.py
                    ┌──────────────────────────────────────┐
                    │  "rules": { ... }                    │
                    │  "transition_rules": { ... }         │
                    └──────────────────────────────────────┘
                                       │
                                       ▼
                              state_machine.py
                    ┌──────────────────────────────────────┐
                    │  def apply_rules():                  │
                    │    action = _resolve_action(...)     │
                    │    next_state = _resolve_transition(...) │
                    │    return action, next_state         │
                    └──────────────────────────────────────┘
                                       │
                                       ▼
                    ┌──────────────────────────────────────┐
                    │  _resolve_action(rule)               │
                    │  _resolve_transition(rule)           │
                    │    uses condition_evaluator          │
                    └──────────────────────────────────────┘
2.2 Принципы
Принцип	Описание
Декларативность	Вся логика описана в config.py, не в коде
Единый источник правды	Хочешь узнать поведение — смотри config
Разделение ответственности	rules отвечают только за action, transition_rules только за переходы
Расширяемость	Новое условие = новый тип в resolver, используй везде
Обратная совместимость	Старые правила-строки продолжают работать
Тестируемость	Условия можно тестировать изолированно
Отказоустойчивость	Жёсткая валидация в CI, мягкий fallback + лог/метрики в runtime
Часть 3: ДЕТАЛЬНОЕ ОПИСАНИЕ РЕШЕНИЯ
3.1 Формат rules и transition_rules (Schema)

# Простое action-правило (обратная совместимость)
"greeting": "acknowledge_and_continue"

# Условное action-правило
"price_question": {
    "default": "deflect_and_continue",
    "conditions": [
        {
            "when": { ... },                 # Условие (см. 3.2)
            "then": "answer_with_facts"      # Только action
        }
    ]
}

# Расширенный формат then — action + state вместе
"contact_provided": {
    "default": "acknowledge_and_continue",
    "conditions": [
        {
            "when": {"is_spin_state": true},
            "then": {
                "action": "acknowledge_contact_early",  # Действие
                "state": "close"                        # И переход
            }
        }
    ]
}

# Простое transition-правило
"demo_request": "success"

# Условное transition-правило
"demo_request": {
    "conditions": [
        {
            "when": {"state_in": ["close"]},
            "then": "success"                # Только state
        }
    ],
    "default": None  # None → fallback на transitions/SPIN
}

Формат then:
┌─────────────────────────────────────────────────────────────────────────────┐
│  "then": "action_name"              — только action (строка)                │
│  "then": {"action": "..."}          — только action (объект)                │
│  "then": {"state": "..."}           — только state                          │
│  "then": {"action": "...", "state": "..."} — action + state вместе          │
└─────────────────────────────────────────────────────────────────────────────┘
3.2 Типы условий (Condition Types)

┌─────────────────────────────────────────────────────────────────────────────┐
│  ДАННЫЕ (проверка collected_data)                                           │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│  1. has_any — есть ЛЮБОЕ из полей                                           │
│     "when": {"has_any": ["company_size", "users_count"]}                    │
│     {} → False, {company_size: 10} → True                                   │
│                                                                             │
│  2. has_all — есть ВСЕ поля                                                 │
│     "when": {"has_all": ["company_size", "pain_point"]}                     │
│     {company_size: 10} → False, {company_size: 10, pain_point: "x"} → True  │
│                                                                             │
│  3. missing_any — отсутствует ЛЮБОЕ из полей                                │
│     "when": {"missing_any": ["company_size", "pain_point"]}                 │
│     {} → True, {company_size: 10} → True (нет pain_point)                   │
│     {company_size: 10, pain_point: "x"} → False                             │
│                                                                             │
│  4. missing_all — отсутствуют ВСЕ поля                                      │
│     "when": {"missing_all": ["company_size", "users_count"]}                │
│     {} → True, {company_size: 10} → False (есть хотя бы одно)               │
│                                                                             │
│  5. field_equals — поле равно значению                                      │
│     "when": {"field_equals": {"urgency": "high"}}                           │
│     {urgency: "low"} → False, {urgency: "high"} → True                      │
│                                                                             │
│  6. field_compare — числовые сравнения                                      │
│     "when": {"field_gt": {"company_size": 50}}    # >50                     │
│     "when": {"field_gte": {"company_size": 10}}   # >=10                    │
│     "when": {"field_lt": {"company_size": 100}}   # <100                    │
│                                                                             │
├─────────────────────────────────────────────────────────────────────────────┤
│  СОСТОЯНИЕ                                                                  │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│  7. state_in — текущее состояние в списке                                   │
│     "when": {"state_in": ["presentation", "close"]}                         │
│                                                                             │
│  8. spin_phase_in — текущая SPIN-фаза в списке                              │
│     "when": {"spin_phase_in": ["implication", "need_payoff"]}               │
│                                                                             │
│  9. is_spin_state — находимся в SPIN-фазе (bool)                            │
│     "when": {"is_spin_state": true}                                         │
│                                                                             │
│  10. data_complete — все required_data собраны                              │
│      "when": {"data_complete": true}                                        │
│                                                                             │
├─────────────────────────────────────────────────────────────────────────────┤
│  ИСТОРИЯ ИНТЕНТОВ (требует IntentTracker)                                   │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│  11. intent_repeated — интент повторился N+ раз                             │
│      # Подряд (consecutive) — по умолчанию                                  │
│      "when": {"intent_repeated": {"min": 3}}                                │
│                                                                             │
│      # В окне последних N ходов                                             │
│      "when": {"intent_repeated": {"min": 2, "scope": "window", "window": 5}}│
│                                                                             │
├─────────────────────────────────────────────────────────────────────────────┤
│  ВОЗРАЖЕНИЯ                                                                 │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│  12. objection_count — счётчик возражений                                   │
│      "when": {"objection_count": {"scope": "consecutive", "min": 2}}        │
│      "when": {"objection_count": {"scope": "total", "min": 3}}              │
│                                                                             │
├─────────────────────────────────────────────────────────────────────────────┤
│  МЕТАДАННЫЕ                                                                 │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│  13. turn_number — номер хода в диалоге                                     │
│      "when": {"turn_number": {"min": 5}}        # после 5 ходов             │
│      "when": {"turn_number": {"max": 3}}        # в первые 3 хода           │
│                                                                             │
├─────────────────────────────────────────────────────────────────────────────┤
│  ЛОГИЧЕСКИЕ ОПЕРАТОРЫ                                                       │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│  14. and — все условия истинны                                              │
│      "when": {"and": [{"has_any": [...]}, {"state_in": [...]}]}             │
│                                                                             │
│  15. or — любое условие истинно                                             │
│      "when": {"or": [{"has_any": [...]}, {"intent_repeated": 3}]}           │
│                                                                             │
│  16. not — инверсия условия                                                 │
│      "when": {"not": {"has_any": ["company_size"]}}                         │
│      {} → True (not False), {company_size: 10} → False (not True)           │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘

3.2.1 IntentTracker (реализация для intent_repeated)

class IntentTracker:
    """
    Отслеживает историю интентов для conditional rules.
    Реализует паттерн Sliding Window для эффективного подсчёта.
    """
    MAX_HISTORY = 20

    def __init__(self):
        self.history: List[str] = []           # ["greeting", "price_question", ...]
        self.consecutive: Dict[str, int] = {}  # {"price_question": 3}
        self.last_intent: Optional[str] = None

    def record(self, intent: str) -> None:
        """Записать интент (вызывается в начале process)"""
        if intent == self.last_intent:
            self.consecutive[intent] = self.consecutive.get(intent, 1) + 1
        else:
            self.consecutive = {intent: 1}

        self.history.append(intent)
        if len(self.history) > self.MAX_HISTORY:
            self.history.pop(0)

        self.last_intent = intent

    def get_consecutive(self, intent: str) -> int:
        return self.consecutive.get(intent, 0)

    def count_in_window(self, intent: str, window: int = 5) -> int:
        recent = self.history[-window:]
        return recent.count(intent)

# Интеграция в StateMachine:
class StateMachine:
    def __init__(self):
        ...
        self.intent_tracker = IntentTracker()

3.2.2 EvaluatorContext (типизированный контракт)

@dataclass
class EvaluatorContext:
    """
    Контекст для проверки условий.
    Все поля гарантированно существуют.
    """
    # Данные клиента
    collected_data: Dict[str, Any]

    # Состояние диалога
    state: str
    spin_phase: Optional[str]
    is_spin_state: bool

    # История интентов
    last_intent: Optional[str]
    intent_consecutive: Dict[str, int]   # {"price_question": 3}
    intent_history: List[str]

    # Возражения
    objection_consecutive: int
    objection_total: int

    # Метаданные
    turn_number: int
    missing_required_data: List[str]

    @classmethod
    def from_state_machine(cls, sm: "StateMachine") -> "EvaluatorContext":
        config = SALES_STATES.get(sm.state, {})
        required = config.get("required_data", [])
        missing = [f for f in required if not sm.collected_data.get(f)]

        return cls(
            collected_data=sm.collected_data.copy(),
            state=sm.state,
            spin_phase=sm.spin_phase,
            is_spin_state=sm.spin_phase is not None,
            last_intent=sm.intent_tracker.last_intent,
            intent_consecutive=sm.intent_tracker.consecutive.copy(),
            intent_history=sm.intent_tracker.history.copy(),
            objection_consecutive=sm.objection_flow.objection_count,
            objection_total=sm.objection_flow.total_objections,
            turn_number=len(sm.intent_tracker.history),
            missing_required_data=missing,
        )

Mapping условий → поля контекста:
┌────────────────────────┬─────────────────────────────────────────────────────┐
│  Условие               │  Использует                                         │
├────────────────────────┼─────────────────────────────────────────────────────┤
│  has_any/has_all       │  collected_data                                     │
│  missing_any/all       │  collected_data                                     │
│  field_equals/compare  │  collected_data                                     │
│  state_in              │  state                                              │
│  spin_phase_in         │  spin_phase                                         │
│  is_spin_state         │  is_spin_state                                      │
│  intent_repeated       │  intent_consecutive (подряд), intent_history (window)│
│  objection_count       │  objection_consecutive, objection_total             │
│  turn_number           │  turn_number                                        │
│  data_complete         │  missing_required_data (empty = complete)           │
└────────────────────────┴─────────────────────────────────────────────────────┘
3.3 Порядок проверки условий (rules/transition_rules)

              Вход: rule/transition_rule с conditions
                         │
                         ▼
         ┌───────────────────────────────┐
         │  conditions[0]                │
         │  when: {has_any: [...]}       │
         └───────────────────────────────┘
                         │
                    True? ──────────────────► return conditions[0]["then"]
                         │
                       False
                         │
                         ▼
         ┌───────────────────────────────┐
         │  conditions[1]                │
         │  when: {intent_repeated: 3}   │
         └───────────────────────────────┘
                         │
                    True? ──────────────────► return conditions[1]["then"]
                         │
                       False
                         │
                         ▼
         ┌───────────────────────────────┐
         │  conditions[2]                │
         │  ...                          │
         └───────────────────────────────┘
                         │
                       False
                         │
                         ▼
         ┌───────────────────────────────┐
         │  return rule["default"]       │
         └───────────────────────────────┘
         
         ВАЖНО: Первое сработавшее условие побеждает!
         Порядок условий имеет значение.
3.4 Наследование правил (Rule Inheritance)

Проблема: В текущей архитектуре одинаковые rules дублируются в spin_situation,
spin_problem, spin_implication, spin_need_payoff. Это нарушает DRY.

Решение: Трёхуровневая иерархия правил.

┌─────────────────────────────────────────────────────────────────────────────┐
│  ИЕРАРХИЯ ПРАВИЛ                                                            │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│  ┌─────────────────┐                                                        │
│  │  global_rules   │  ← Применяются ко ВСЕМ состояниям                      │
│  │  (приоритет 3)  │     greeting, gratitude, small_talk                    │
│  └────────┬────────┘                                                        │
│           │                                                                 │
│           ▼                                                                 │
│  ┌─────────────────┐                                                        │
│  │  rule_groups    │  ← Группы правил для наследования                      │
│  │  (приоритет 2)  │     "spin_phases": price_question, pricing_details...  │
│  └────────┬────────┘     "post_spin": price_question без deflect            │
│           │                                                                 │
│           ▼                                                                 │
│  ┌─────────────────┐                                                        │
│  │  state.rules    │  ← Специфичные для состояния (высший приоритет)        │
│  │  (приоритет 1)  │     unclear → probe_situation (только в spin_situation)│
│  └─────────────────┘                                                        │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘

Формат конфигурации:

SALES_CONFIG = {
    # Уровень 1: Глобальные правила (для всех состояний)
    "global_rules": {
        "greeting": "acknowledge_and_continue",
        "gratitude": "acknowledge_and_continue",
        "small_talk": "small_talk_and_continue",
    },

    # Уровень 2: Группы правил (для наследования)
    "rule_groups": {
        "spin_phases": {
            "price_question": {
                "default": "deflect_and_continue",
                "conditions": [
                    {"when": {"has_any": ["company_size", "users_count"]},
                     "then": "answer_with_facts"},
                    {"when": {"intent_repeated": {"min": 3}},
                     "then": "answer_with_price_range"}
                ]
            },
            "pricing_details": {
                "default": "deflect_and_continue",
                "conditions": [
                    {"when": {"has_any": ["company_size", "users_count"]},
                     "then": "answer_with_facts"}
                ]
            },
            "comparison": "answer_and_continue",
            "question_features": "answer_and_continue",
            "question_integrations": "answer_and_continue",
        },
        "post_spin": {
            "price_question": "answer_with_facts",
            "pricing_details": "answer_with_facts",
        }
    },

    # Уровень 3: Состояния с наследованием
    "states": {
        "spin_situation": {
            "inherit_rules": ["spin_phases"],  # Наследует из группы
            "rules": {
                "unclear": "probe_situation",  # Специфичное правило
            }
        },
        "spin_problem": {
            "inherit_rules": ["spin_phases"],
            "rules": {
                "unclear": "probe_problem",
            }
        },
        "spin_implication": {
            "inherit_rules": ["spin_phases"],
            "rules": {
                "unclear": "probe_implication",
            }
        },
        "spin_need_payoff": {
            "inherit_rules": ["spin_phases"],
            "rules": {
                "unclear": "probe_need_payoff",
            }
        },
        "presentation": {
            "inherit_rules": ["post_spin"],
            "rules": { ... }
        },
        "close": {
            "inherit_rules": ["post_spin"],
            "rules": { ... }
        }
    }
}

Алгоритм разрешения правила:

def _get_rule_for_intent(self, state: str, intent: str) -> Optional[Union[str, Dict]]:
    """Получить правило с учётом наследования"""
    config = SALES_CONFIG["states"].get(state, {})

    # Приоритет 1: Специфичное правило состояния
    if intent in config.get("rules", {}):
        return config["rules"][intent]

    # Приоритет 2: Унаследованные группы (в порядке объявления)
    for group_name in config.get("inherit_rules", []):
        group = SALES_CONFIG["rule_groups"].get(group_name, {})
        if intent in group:
            return group[intent]

    # Приоритет 3: Глобальные правила
    if intent in SALES_CONFIG.get("global_rules", {}):
        return SALES_CONFIG["global_rules"][intent]

    return None  # Правило не найдено → fallback в apply_rules()

Результат: Вместо 4x дублирования правил для SPIN-фаз — 1 определение в rule_groups.

3.5 Порядок разрешения action и переходов

Критические ранние выходы (до resolver'ов):
- final
- rejection
- go_back
- objections

Action resolver:
1) rules[intent] (str или conditional)
2) QUESTION_INTENTS → answer_question
3) default → continue_current_goal

Transition resolver:
1) transition_rules[intent] (str или conditional)
2) SPIN progress / SPIN data_complete
3) transitions[intent]
4) non-SPIN data_complete
5) transitions["any"]
6) stay in current state
Часть 4: ПРИМЕРЫ ПРИМЕНЕНИЯ
4.1 Price Question (текущий баг)
До:


# config.py
"price_question": "deflect_and_continue"

# state_machine.py — КОСТЫЛЬ
if intent == "price_question" and rule_action == "deflect_and_continue":
    if self.collected_data.get("company_size"):
        return "answer_with_facts", self.state
После:


# config.py — ВСЯ ЛОГИКА ЗДЕСЬ
"price_question": {
    "default": "deflect_and_continue",
    "conditions": [
        {
            "when": {"has_any": ["company_size", "users_count"]},
            "then": "answer_with_facts"
        }
    ]
}

# state_machine.py — БЕЗ КОСТЫЛЕЙ
# Resolvers обрабатывают всё автоматически
4.2 Эскалация при повторных вопросах о цене

"price_question": {
    "default": "deflect_and_continue",
    "conditions": [
        # Приоритет 1: Если данные есть — ответить
        {
            "when": {"has_any": ["company_size", "users_count"]},
            "then": "answer_with_facts"
        },
        # Приоритет 2: Если спросил 3+ раз — дать диапазон
        {
            "when": {"intent_repeated": {"min": 3}},  # по умолчанию подряд
            "then": "answer_with_price_range"
        }
    ]
}
Сценарий:


Ход 1: "Сколько стоит?"     → deflect (данных нет, повторов 1)
Ход 2: "Ну почем?"          → deflect (данных нет, повторов 2)
Ход 3: "Цену скажи!"        → answer_with_price_range (повторов 3!)
4.3 Умная обработка возражения о цене

"objection_price": {
    "default": "handle_price_objection_generic",
    "conditions": [
        # Если знаем боль и размер — показать ROI
        {
            "when": {"has_all": ["pain_point", "company_size"]},
            "then": "handle_price_with_roi"
        },
        # Если только размер — сравнить с конкурентами
        {
            "when": {"has_any": ["company_size"]},
            "then": "handle_price_with_comparison"
        }
    ]
}
Примечание: правила для objection_* размещаются в состоянии handle_objection,
переход в него управляется transitions/transition_rules.
4.4 Технические вопросы с эскалацией

"question_technical": {
    "default": "answer_technical",
    "conditions": [
        # Если спрашивает повторно — предложить документацию
        {
            "when": {"intent_repeated": {"min": 2}},
            "then": "offer_documentation_link"
        }
    ]
}
4.5 Условный переход (transition_rules)

"transition_rules": {
    "demo_request": {
        "conditions": [
            {
                "when": {"state_in": ["close"]},
                "then": "success"
            }
        ],
        "default": None
    }
}
Комментарий: если условия не сработали, переход определяется обычными transitions/SPIN.
Если transition_rules объявлены внутри конкретного state, state_in можно опустить.
Часть 5: ПЛАН РЕАЛИЗАЦИИ
5.1 Структура изменений

┌─────────────────────────────────────────────────────────────────────────────┐
│                           ФАЙЛЫ ДЛЯ ИЗМЕНЕНИЯ                               │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│  src/                                                                       │
│  ├── state_machine.py          ← _resolve_action + _resolve_transition      │
│  ├── config.py                 ← rules + transition_rules (conditional)     │
│  ├── condition_evaluator.py    ← НОВЫЙ: логика проверки условий             │
│  └── rule_validator.py         ← НОВЫЙ: валидация схемы правил              │
│                                                                             │
│  tests/                                                                     │
│  ├── test_condition_evaluator.py  ← НОВЫЙ: unit-тесты условий               │
│  ├── test_transition_rules.py     ← НОВЫЙ: интеграционные тесты             │
│  └── test_state_machine.py        ← Обновить существующие тесты             │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
5.2 Этапы

┌─────────────────────────────────────────────────────────────────────────────┐
│  ЭТАП 1: Схема config + контракт контекста                                  │
├─────────────────────────────────────────────────────────────────────────────┤
│  1. Зафиксировать разделение rules vs transition_rules                      │
│  2. Определить семантику intent_repeated (consecutive + window)             │
│  3. Добавить condition state_in                                             │
└─────────────────────────────────────────────────────────────────────────────┘
                                    │
                                    ▼
┌─────────────────────────────────────────────────────────────────────────────┐
│  ЭТАП 2: Condition Evaluator (изолированный модуль)                         │
├─────────────────────────────────────────────────────────────────────────────┤
│  1. Создать src/condition_evaluator.py                                      │
│  2. Реализовать все типы условий                                            │
│  3. Написать unit-тесты для каждого типа                                    │
│  4. Результат: модуль можно тестировать изолированно                        │
└─────────────────────────────────────────────────────────────────────────────┘
                                    │
                                    ▼
┌─────────────────────────────────────────────────────────────────────────────┐
│  ЭТАП 3: Resolvers в State Machine                                          │
├─────────────────────────────────────────────────────────────────────────────┤
│  1. Добавить _resolve_action() и _resolve_transition()                      │
│  2. Интегрировать condition_evaluator                                       │
│  3. Обеспечить обратную совместимость (str rules работают)                  │
│  4. Удалить костыль price_question                                          │
└─────────────────────────────────────────────────────────────────────────────┘
                                    │
                                    ▼
┌─────────────────────────────────────────────────────────────────────────────┐
│  ЭТАП 4: Миграция config.py                                                 │
├─────────────────────────────────────────────────────────────────────────────┤
│  1. Конвертировать price_question в conditional format                      │
│  2. Добавить условия для pricing_details                                    │
│  3. Добавить transition_rules для условных переходов (demo_request и др.)   │
└─────────────────────────────────────────────────────────────────────────────┘
                                    │
                                    ▼
┌─────────────────────────────────────────────────────────────────────────────┐
│  ЭТАП 5: Тестирование                                                       │
├─────────────────────────────────────────────────────────────────────────────┤
│  1. Unit-тесты evaluator                                                    │
│  2. Интеграционные тесты приоритетов action/transition                      │
│  3. Проверка SPIN-прогресса и objections                                    │
└─────────────────────────────────────────────────────────────────────────────┘
                                    │
                                    ▼
┌─────────────────────────────────────────────────────────────────────────────┐
│  ЭТАП 6: Валидация                                                         │
├─────────────────────────────────────────────────────────────────────────────┤
│  1. Жёсткая схема в CI                                                     │
│  2. Мягкий fallback + лог/метрики в runtime                                │
└─────────────────────────────────────────────────────────────────────────────┘
5.3 Обратная совместимость

def _resolve_action(self, rule: Union[str, Dict]) -> str:
    """
    Action resolver с обратной совместимостью.
    """
    # Обратная совместимость: строка работает как раньше
    if isinstance(rule, str):
        return rule

    # Новый формат: dict с conditions
    if isinstance(rule, dict):
        for condition in rule.get("conditions", []):
            if self.evaluator.evaluate(condition["when"], self._get_context()):
                return condition["then"]
        return rule.get("default", "continue_current_goal")

    # Fallback
    return "continue_current_goal"

def _resolve_transition(self, rule: Union[str, Dict]) -> Optional[str]:
    """
    Transition resolver с обратной совместимостью.
    """
    # Обратная совместимость: строка = явный next_state
    if isinstance(rule, str):
        return rule

    # Новый формат: dict с conditions
    if isinstance(rule, dict):
        for condition in rule.get("conditions", []):
            if self.evaluator.evaluate(condition["when"], self._get_context()):
                return condition["then"]
        return rule.get("default")  # None → fallback на transitions/SPIN

    # Fallback
    return None
Это значит:

Все существующие "intent": "action" правила продолжают работать
Все существующие transitions остаются источником переходов по умолчанию
Можно мигрировать правила по одному
Нет "big bang" миграции
Часть 6: ОЖИДАЕМЫЕ РЕЗУЛЬТАТЫ
6.1 До и После
Аспект	До	После
Где логика	config.py + state_machine.py	Только config.py (rules + transition_rules)
Добавить условие	Писать if в коде	Добавить в config
Понять поведение	Читать код SM	Читать config
Тестировать условие	Поднимать весь SM	Unit-тест evaluator
Количество костылей	Растёт	0
6.2 Пример: Как будет выглядеть config.py

SALES_STATES = {
    "spin_situation": {
        "goal": "Понять ситуацию клиента",
        "transitions": { ... },
        "rules": {
            # Простые правила (обратная совместимость)
            "greeting": "acknowledge_and_continue",
            "small_talk": "small_talk_and_continue",
            
            # Условные правила (новый формат)
            "price_question": {
                "default": "deflect_and_continue",
                "conditions": [
                    {
                        "when": {"has_any": ["company_size", "users_count"]},
                        "then": "answer_with_facts"
                    },
                    {
                        "when": {"intent_repeated": {"min": 3}},
                        "then": "answer_with_price_range"
                    }
                ]
            },
            "pricing_details": {
                "default": "deflect_and_continue",
                "conditions": [
                    {
                        "when": {"has_any": ["company_size", "users_count"]},
                        "then": "answer_with_facts"
                    }
                ]
            }
        }
    },
    "close": {
        "goal": "Взять контакт или назначить демо",
        "transitions": { ... },
        "transition_rules": {
            "demo_request": {
                "conditions": [
                    {
                        "when": {"has_any": ["contact_info"]},
                        "then": "success"
                    }
                ],
                "default": None
            }
        }
    },
    # ... остальные состояния
}
Часть 7: ЛОГГИРОВАНИЕ ДЛЯ СИМУЛЯЦИЙ

7.1 Цель
При запуске 50 симуляций нужно точно понимать:
- Почему бот выбрал конкретный action
- Какие условия проверялись и какой был результат
- Какой контекст был на момент принятия решения
- Почему переход пошёл в одно состояние, а не в другое

7.2 Уровни логирования

┌─────────────────────────────────────────────────────────────────────────────┐
│                           УРОВНИ ЛОГОВ                                       │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│  DEBUG   — Детали каждой проверки условия (для отладки конкретной итерации) │
│  INFO    — Финальные решения: action, transition, matched condition         │
│  WARNING — Fallback на default (условия не сработали)                       │
│  EVENT   — Бизнес-события для аналитики (state_transition, rule_matched)    │
│  METRIC  — Числовые метрики (conditions_checked, evaluation_time_ms)        │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘

7.3 Что логируем

┌─────────────────────────────────────────────────────────────────────────────┐
│  1. ВХОД В RESOLVER                                                         │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│  logger.debug("Resolving action",                                           │
│      intent="price_question",                                               │
│      state="spin_situation",                                                │
│      rule_type="conditional",        # "simple" | "conditional"             │
│      conditions_count=2                                                     │
│  )                                                                          │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────────────────┐
│  2. КОНТЕКСТ ДЛЯ EVALUATOR                                                  │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│  logger.debug("Evaluation context",                                         │
│      collected_data={"company_size": 10, "pain_point": "теряем клиентов"},  │
│      state="spin_situation",                                                │
│      spin_phase="situation",                                                │
│      intent_streak={"price_question": 2},                                   │
│      last_intent="info_provided"                                            │
│  )                                                                          │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────────────────┐
│  3. ПРОВЕРКА КАЖДОГО УСЛОВИЯ                                                │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│  logger.debug("Condition evaluated",                                        │
│      condition_index=0,                                                     │
│      condition_type="has_any",                                              │
│      condition_params=["company_size", "users_count"],                      │
│      result=True,                      # True | False                       │
│      matched_field="company_size"      # какое поле сработало (для has_any) │
│  )                                                                          │
│                                                                             │
│  logger.debug("Condition evaluated",                                        │
│      condition_index=1,                                                     │
│      condition_type="intent_repeated",                                      │
│      condition_params={"min": 3},                                           │
│      result=False,                                                          │
│      actual_streak=2                   # текущее значение streak            │
│  )                                                                          │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────────────────┐
│  4. ФИНАЛЬНОЕ РЕШЕНИЕ                                                       │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│  # Условие сработало                                                        │
│  logger.info("Action resolved",                                             │
│      intent="price_question",                                               │
│      action="answer_with_facts",                                            │
│      resolution="condition_matched",   # "condition_matched" | "default"    │
│      matched_condition_index=0,                                             │
│      matched_condition_type="has_any"                                       │
│  )                                                                          │
│                                                                             │
│  # Ни одно условие не сработало → default                                   │
│  logger.warning("Action resolved via default",                              │
│      intent="price_question",                                               │
│      action="deflect_and_continue",                                         │
│      resolution="default",                                                  │
│      conditions_checked=2,                                                  │
│      all_conditions_failed=True                                             │
│  )                                                                          │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────────────────┐
│  5. TRANSITION RESOLVER (аналогично)                                        │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│  logger.info("Transition resolved",                                         │
│      intent="demo_request",                                                 │
│      from_state="close",                                                    │
│      to_state="success",                                                    │
│      resolution="transition_rule_matched",                                  │
│      matched_condition_type="state_in"                                      │
│  )                                                                          │
│                                                                             │
│  # Fallback на обычные transitions                                          │
│  logger.info("Transition resolved",                                         │
│      intent="demo_request",                                                 │
│      from_state="spin_situation",                                           │
│      to_state="close",                                                      │
│      resolution="transitions_fallback"  # transition_rules не сработали     │
│  )                                                                          │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘

7.4 Бизнес-события (EVENT)

# Для аналитики симуляций
logger.event("conditional_rule_triggered",
    intent="price_question",
    condition_type="has_any",
    action="answer_with_facts",
    simulation_id=42
)

logger.event("conditional_rule_default_used",
    intent="price_question",
    action="deflect_and_continue",
    reason="no_pricing_data",
    simulation_id=42
)

7.5 Метрики (METRIC)

# Производительность evaluator
logger.metric("condition_evaluation",
    conditions_checked=3,
    evaluation_time_ms=0.5,
    intent="price_question"
)

# Статистика по правилам
logger.metric("conditional_rules_stats",
    total_evaluations=150,
    conditions_matched=87,
    defaults_used=63,
    simulation_batch_id="batch_001"
)

7.6 Формат вывода для симуляций

Логи conditional rules встраиваются прямо в секцию диалогов.
Каждый ход показывает rule resolution для быстрой отладки.

┌─────────────────────────────────────────────────────────────────────────────┐
│  ФОРМАТ ДИАЛОГА С RULE RESOLUTION                                           │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│  [Ход 3]                                                                    │
│  Клиент: А сколько это стоит?                                               │
│  Бот: Чтобы назвать точную цену, уточните сколько человек в команде?        │
│    (state=spin_situation, intent=price_question, action=deflect_and_continue)│
│    [RULE] conditional → DEFAULT                                             │
│           has_any(company_size,users_count)=FAIL                            │
│           intent_repeated(3)=FAIL (streak=1)                                │
│                                                                             │
│  [Ход 5]                                                                    │
│  Клиент: Ну так сколько стоит-то?                                           │
│  Бот: При команде из 10 человек стоимость составит 15000₸ в месяц.          │
│    (state=spin_situation, intent=price_question, action=answer_with_facts)  │
│    [RULE] conditional → MATCHED[0]                                          │
│           has_any(company_size,users_count)=PASS (company_size=10)          │
│                                                                             │
│  [Ход 7]                                                                    │
│  Клиент: Расскажите про интеграции                                          │
│  Бот: Мы интегрируемся с 1С, Kaspi, WhatsApp...                             │
│    (state=spin_situation, intent=question_integrations, action=answer_and_continue)
│    [RULE] simple → answer_and_continue                                      │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘

Формат строки [RULE]:
- "simple → action"           — простое правило (строка)
- "conditional → MATCHED[N]"  — сработало условие N
- "conditional → DEFAULT"     — ни одно условие не сработало
- "none → continue_current_goal" — правило не найдено

Детали условий показываются только для conditional rules.
Формат: condition_type(params)=PASS/FAIL (details)

7.6.1 Реализация: как rule info попадает в отчёт

1. StateMachine.apply_rules() возвращает расширенный результат:

# Было:
return action, next_state

# Стало:
return action, next_state, rule_info

# Где rule_info:
{
    "rule_type": "conditional",      # "simple" | "conditional" | "none"
    "resolution": "condition_matched", # "condition_matched" | "default" | "simple"
    "matched_index": 0,              # индекс сработавшего условия (или None)
    "conditions_evaluated": [        # список проверенных условий
        {
            "type": "has_any",
            "params": ["company_size", "users_count"],
            "result": True,
            "details": {"matched_field": "company_size", "value": 10}
        },
        # ... остальные условия (если первое не сработало)
    ]
}

2. Runner записывает rule_info в turn_data:

# В runner.py _run_single()
turn_data = {
    "turn": turn + 1,
    "client": client_message,
    "bot": bot_result.get("response", ""),
    "state": bot_result.get("state", ""),
    "intent": bot_result.get("intent", ""),
    "action": bot_result.get("action", ""),
    "rule_info": bot_result.get("rule_info", {}),  # NEW
}

3. ReportGenerator форматирует rule_info:

# В report.py _section_full_dialogues()
def _format_rule_info(self, rule_info: Dict) -> List[str]:
    """Форматирует rule_info для отчёта"""
    lines = []

    rule_type = rule_info.get("rule_type", "none")
    resolution = rule_info.get("resolution", "")

    if rule_type == "simple":
        lines.append(f"    [RULE] simple → {rule_info.get('action', '?')}")

    elif rule_type == "conditional":
        if resolution == "condition_matched":
            idx = rule_info.get("matched_index", 0)
            lines.append(f"    [RULE] conditional → MATCHED[{idx}]")
        else:
            lines.append(f"    [RULE] conditional → DEFAULT")

        # Детали условий
        for cond in rule_info.get("conditions_evaluated", []):
            result = "PASS" if cond["result"] else "FAIL"
            params = ",".join(str(p) for p in cond["params"]) if isinstance(cond["params"], list) else str(cond["params"])
            detail = f" ({cond['details']})" if cond.get("details") else ""
            lines.append(f"           {cond['type']}({params})={result}{detail}")

    else:
        lines.append(f"    [RULE] none → continue_current_goal")

    return lines

7.7 Конфигурация уровня логирования

# settings.yaml
logging:
  level: INFO                    # Production: INFO, Debug: DEBUG
  conditional_rules:
    enabled: true                # Включить детальное логирование rules
    level: DEBUG                 # Уровень для conditional rules
    log_context: true            # Логировать полный контекст
    log_each_condition: true     # Логировать каждое условие

# Или через environment
CONDITIONAL_RULES_LOG_LEVEL=DEBUG

7.8 Класс RuleLogger (обёртка)

class RuleLogger:
    """
    Специализированный логгер для conditional rules.
    Упрощает логирование и добавляет контекст симуляции.
    """

    def __init__(self, simulation_id: Optional[int] = None):
        self.simulation_id = simulation_id
        self.enabled = settings.get_nested("logging.conditional_rules.enabled", True)
        self.log_context = settings.get_nested("logging.conditional_rules.log_context", True)
        self.log_each_condition = settings.get_nested("logging.conditional_rules.log_each_condition", True)

    def log_resolution_start(self, intent: str, rule_type: str, state: str):
        """Начало разрешения правила"""
        if not self.enabled:
            return
        logger.debug("Resolving rule",
            intent=intent,
            rule_type=rule_type,
            state=state,
            simulation_id=self.simulation_id
        )

    def log_context(self, context: Dict):
        """Логирование контекста evaluator"""
        if not self.enabled or not self.log_context:
            return
        logger.debug("Evaluation context",
            **context,
            simulation_id=self.simulation_id
        )

    def log_condition_result(
        self,
        index: int,
        condition_type: str,
        params: Any,
        result: bool,
        details: Optional[Dict] = None
    ):
        """Результат проверки одного условия"""
        if not self.enabled or not self.log_each_condition:
            return
        log_data = {
            "condition_index": index,
            "condition_type": condition_type,
            "params": params,
            "result": result,
            "simulation_id": self.simulation_id
        }
        if details:
            log_data.update(details)
        logger.debug("Condition evaluated", **log_data)

    def log_resolution_result(
        self,
        intent: str,
        result: str,
        resolution: str,  # "condition_matched" | "default" | "simple_rule"
        matched_index: Optional[int] = None,
        matched_type: Optional[str] = None
    ):
        """Финальный результат разрешения"""
        if not self.enabled:
            return

        log_fn = logger.info if resolution == "condition_matched" else logger.warning
        log_fn("Rule resolved",
            intent=intent,
            result=result,
            resolution=resolution,
            matched_condition_index=matched_index,
            matched_condition_type=matched_type,
            simulation_id=self.simulation_id
        )

7.9 Интеграция с SimulationRunner

# В runner.py
def _run_single(self, sim_id: int, persona_name: str) -> SimulationResult:
    ...
    # Создаём логгер для этой симуляции
    rule_logger = RuleLogger(simulation_id=sim_id)

    # Передаём в бота
    bot = SalesBot(self.bot_llm, rule_logger=rule_logger)
    ...

# В state_machine.py
class StateMachine:
    def __init__(self, rule_logger: Optional[RuleLogger] = None):
        ...
        self.rule_logger = rule_logger or RuleLogger()

7.10 Пример полного лога одного хода

[12:34:56] DEBUG - Resolving rule [intent=price_question, rule_type=conditional, state=spin_situation, simulation_id=10]
[12:34:56] DEBUG - Evaluation context [collected_data={company_size: 10}, state=spin_situation, spin_phase=situation, intent_streak={price_question: 2}, simulation_id=10]
[12:34:56] DEBUG - Condition evaluated [condition_index=0, condition_type=has_any, params=['company_size', 'users_count'], result=True, matched_field=company_size, simulation_id=10]
[12:34:56] INFO - Rule resolved [intent=price_question, result=answer_with_facts, resolution=condition_matched, matched_condition_index=0, matched_condition_type=has_any, simulation_id=10]

Часть 8: РЕЗЮМЕ

Что имеем сейчас
Rules — простые строки
Условная логика — hardcoded костыли в state_machine.py
Логика размазана по файлам
Каждый новый случай = новый if
Что хотим
Rules — декларативные объекты с условиями для action
Transition_rules — декларативные условия для переходов
Условная логика — в config.py
Разделение action/transition
Единый источник правды
Каждый новый случай = строка в config
Как достигнем
Condition Evaluator — изолированный модуль проверки условий
Action/Transition Resolvers — универсальные интерпретаторы правил в SM
IntentTracker — отслеживание истории интентов (NEW)
EvaluatorContext — типизированный контекст для условий (NEW)
Rule Groups — наследование правил для устранения дублирования (NEW)
Миграция — постепенная, с обратной совместимостью
Валидация — жёсткая в CI, мягкий fallback в runtime

Решённые проблемы:
┌─────────────────────────────────────────────────────────────────────────────┐
│  #  │ Проблема                      │ Решение                              │
├─────┼───────────────────────────────┼──────────────────────────────────────┤
│  1  │ Scope узкий                   │ Разделение ответственности SM/rules  │
│  2  │ intent_repeated не существует │ IntentTracker класс                  │
│  3  │ Нет not условия               │ not, missing_any, missing_all        │
│  4  │ Условия не влияют на state    │ Расширенный then: {action, state}    │
│  5  │ Дублирование                  │ global_rules + rule_groups + inherit │
│  6  │ Контекст не специфицирован    │ EvaluatorContext dataclass           │
│  7  │ Implicit приоритет            │ Документация + валидатор порядка     │
└─────────────────────────────────────────────────────────────────────────────┘

Зачем это нужно
Сейчас: 1 костыль (price_question)
Через месяц: 5 костылей
Через полгода: 20 костылей, код нечитаем
С рефакторингом: 0 костылей навсегда
