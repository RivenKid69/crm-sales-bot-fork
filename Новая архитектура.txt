Conditional Rules: Полное резюме
Часть 1: ТЕКУЩЕЕ СОСТОЯНИЕ
1.1 Как работает система сейчас

┌─────────────────────────────────────────────────────────────────────────────┐
│                           ТЕКУЩАЯ АРХИТЕКТУРА                               │
└─────────────────────────────────────────────────────────────────────────────┘

                              config.py
                    ┌─────────────────────────┐
                    │  SALES_STATES = {       │
                    │    "spin_situation": {  │
                    │      "rules": {         │
                    │        "price_question":│──────► "deflect_and_continue"
                    │        "greeting":      │──────► "acknowledge"
                    │        "rejection":     │──────► "handle_rejection"
                    │      }                  │            │
                    │    }                    │            │
                    │  }                      │            │
                    └─────────────────────────┘            │
                                                          │
                                                          ▼
                              state_machine.py            │
                    ┌─────────────────────────┐           │
                    │  def apply_rules():     │           │
                    │                         │           │
                    │    rule = rules[intent] │◄──────────┘
                    │    return rule, state   │  ← Просто возвращает строку
                    │                         │    Никакой логики!
                    └─────────────────────────┘
Ключевой момент: Rules — это просто строки. Одна строка = один action. Всегда.

1.2 Проблема: Нужна условная логика
Бизнес-требование: "Если клиент спросил о цене И мы уже знаем размер команды — ответить на вопрос. Если не знаем — спросить размер."


                    ┌─────────────────────────────────────────┐
                    │  Клиент: "Сколько стоит?"               │
                    └─────────────────────────────────────────┘
                                       │
                                       ▼
                    ┌─────────────────────────────────────────┐
                    │  intent = "price_question"              │
                    │  rule = "deflect_and_continue"          │
                    └─────────────────────────────────────────┘
                                       │
                       ┌───────────────┴───────────────┐
                       ▼                               ▼
              Данных НЕТ                        Данные ЕСТЬ
              collected_data = {}               collected_data = {
                                                  company_size: 10
                                                }
                       │                               │
                       ▼                               ▼
              deflect_and_continue              deflect_and_continue
              "Сколько человек?"                "Сколько человек?"
                     ✓                                 ✗
              ПРАВИЛЬНО                         НЕПРАВИЛЬНО!
                                                Должен ответить на цену
1.3 Текущее решение: Костыли в коде

# state_machine.py — СЕЙЧАС

def apply_rules(self, intent: str):
    rules = config.get("rules", {})
    
    if intent in rules:
        rule_action = rules[intent]
        
        # ═══════════════════════════════════════════════════════
        # КОСТЫЛЬ #1: Price Deflect Loop Bug
        # ═══════════════════════════════════════════════════════
        if intent == "price_question" and rule_action == "deflect_and_continue":
            has_pricing_data = self.collected_data.get("company_size") or \
                              self.collected_data.get("users_count")
            if has_pricing_data:
                return "answer_with_facts", self.state
        
        # КОСТЫЛЬ #2: (будущий) Эскалация при повторах
        # if intent == "price_question" and self.price_question_count > 3:
        #     return "answer_with_range", self.state
        
        # КОСТЫЛЬ #3: (будущий) Competitor handling
        # if intent == "comparison" and self.collected_data.get("competitor"):
        #     return "compare_with_competitor", self.state
        
        return rule_action, self.state
Проблемы:

Проблема	Описание
Hardcoded	Каждое условие = новый if в коде
Не масштабируется	10 условий = 10 if'ов
Логика размазана	Часть в config.py, часть в state_machine.py
Сложно тестировать	Нужно поднимать весь SM для теста условия
Сложно понять	Чтобы узнать поведение, нужно читать код
1.4 Выявленные случаи где нужны условия
Из анализа simulation_report.txt и кода:

№	Интент	Условие	Результат
1	price_question	Есть company_size/users_count	answer_with_facts (action)
2	price_question	Повторился 3+ раз	answer_with_range (action)
3	pricing_details	Есть company_size	answer_with_facts (action)
4	comparison	Известен конкурент	compare_specific (action)
5	objection_price	Есть pain_point + company_size	handle_with_roi (action)
6	question_technical	Повторился 2+ раз	offer_documentation (action)
7	demo_request	В фазе close	success (transition)
Часть 2: ЦЕЛЬ РЕФАКТОРИНГА
2.1 Что хотим получить

┌─────────────────────────────────────────────────────────────────────────────┐
│                           ЦЕЛЕВАЯ АРХИТЕКТУРА                               │
└─────────────────────────────────────────────────────────────────────────────┘

                              config.py
         ┌────────────────────────────────────────────────────────┐
         │                                                        │
         │  INTENT_CATEGORIES = { ... }                           │
         │                                                        │
         │  # Python-level sharing (compile-time)                 │
         │  SPIN_COMMON_RULES = { ... }                           │
         │  POST_SPIN_RULES = { ... }                             │
         │                                                        │
         │  SALES_CONFIG = {                                      │
         │      "global_rules": { ... },     ← runtime fallback   │
         │      "states": {                                       │
         │          "spin_situation": {                           │
         │              "rules": {**SPIN_COMMON_RULES, ...}       │
         │              "transitions": { ... }                    │
         │          }                                             │
         │      }                                                 │
         │  }                                                     │
         │                                                        │
         └────────────────────────────────────────────────────────┘
                                       │
                                       ▼
                              state_machine.py
         ┌────────────────────────────────────────────────────────┐
         │                                                        │
         │  def apply_rules(intent):                              │
         │      _apply_hooks(intent)           # 0. Side effects  │
         │      _check_early_exits(intent)     # 1. Final/reject  │
         │      action = _resolve_action(...)  # 2. Action        │
         │      state = _resolve_transition(.) # 3. Transition    │
         │      return action, state                              │
         │                                                        │
         └────────────────────────────────────────────────────────┘
                                       │
                                       ▼
                    ┌──────────────────────────────────────┐
                    │  condition_evaluator.py              │
                    │  - evaluate(condition, context)      │
                    │  - EvaluatorContext dataclass        │
                    └──────────────────────────────────────┘
2.2 Принципы
Принцип	Описание
Декларативность	Вся логика описана в config.py, не в коде
Единый источник правды	Хочешь узнать поведение — смотри config
Разделение ответственности	rules → action, transitions → state (строгое разделение)
Расширяемость	Новое условие = новый тип в resolver, используй везде
Обратная совместимость	Старые правила-строки продолжают работать
Тестируемость	Условия можно тестировать изолированно
Отказоустойчивость	Жёсткая валидация в CI, мягкий fallback + лог/метрики в runtime
Часть 3: ДЕТАЛЬНОЕ ОПИСАНИЕ РЕШЕНИЯ
3.1 Формат rules и transitions (Schema)

ПРИНЦИП: Строгое разделение ответственности
┌─────────────────────────────────────────────────────────────────────────────┐
│  rules       → определяют ACTION (что делать)                               │
│  transitions → определяют STATE  (куда переходить)                          │
│                                                                             │
│  Оба поддерживают условия. Если нужны оба — условие дублируется явно.       │
└─────────────────────────────────────────────────────────────────────────────┘

═══════════════════════════════════════════════════════════════════════════════
RULES — определяют action
═══════════════════════════════════════════════════════════════════════════════

# Простое правило (обратная совместимость)
"greeting": "acknowledge_and_continue"

# Условное правило
"price_question": {
    "default": "deflect_and_continue",
    "conditions": [
        {
            "when": {"has_any": ["company_size", "users_count"]},
            "then": "answer_with_facts"      # Только action (строка)
        }
    ]
}

═══════════════════════════════════════════════════════════════════════════════
TRANSITIONS — определяют state
═══════════════════════════════════════════════════════════════════════════════

# Простой переход (обратная совместимость)
"demo_request": "success"

# Условный переход
"contact_provided": {
    "default": null,                         # null → не переходить, fallback на SPIN/data_complete
    "conditions": [
        {
            "when": {"is_spin_state": true},
            "then": "close"                  # Только state (строка)
        }
    ]
}

═══════════════════════════════════════════════════════════════════════════════
КОГДА НУЖНЫ ОБА (action + state) — дублируем условие явно
═══════════════════════════════════════════════════════════════════════════════

# Пример: contact_provided в SPIN-фазе → особый action И переход в close
"spin_situation": {
    "rules": {
        "contact_provided": {
            "default": "acknowledge_and_continue",
            "conditions": [
                {"when": {"is_spin_state": true}, "then": "acknowledge_contact_early"}
            ]
        }
    },
    "transitions": {
        "contact_provided": {
            "default": null,
            "conditions": [
                {"when": {"is_spin_state": true}, "then": "close"}
            ]
        }
    }
}

# Почему дублирование OK:
# 1. Явно видно что этот интент влияет и на action, и на переход
# 2. Легко найти все переходы — смотри только transitions
# 3. Легко найти все actions — смотри только rules
# 4. Таких случаев мало (2-3 из ~15)
3.2 Типы условий (Condition Types)

┌─────────────────────────────────────────────────────────────────────────────┐
│  ДАННЫЕ (проверка collected_data)                                           │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│  1. has_any — есть ЛЮБОЕ из полей                                           │
│     "when": {"has_any": ["company_size", "users_count"]}                    │
│     {} → False, {company_size: 10} → True                                   │
│                                                                             │
│  2. has_all — есть ВСЕ поля                                                 │
│     "when": {"has_all": ["company_size", "pain_point"]}                     │
│     {company_size: 10} → False, {company_size: 10, pain_point: "x"} → True  │
│                                                                             │
│  3. missing_any — отсутствует ЛЮБОЕ из полей                                │
│     "when": {"missing_any": ["company_size", "pain_point"]}                 │
│     {} → True, {company_size: 10} → True (нет pain_point)                   │
│     {company_size: 10, pain_point: "x"} → False                             │
│                                                                             │
│  4. missing_all — отсутствуют ВСЕ поля                                      │
│     "when": {"missing_all": ["company_size", "users_count"]}                │
│     {} → True, {company_size: 10} → False (есть хотя бы одно)               │
│                                                                             │
│  5. field_equals — поле равно значению                                      │
│     "when": {"field_equals": {"urgency": "high"}}                           │
│     {urgency: "low"} → False, {urgency: "high"} → True                      │
│                                                                             │
│  6. field_compare — числовые сравнения                                      │
│     "when": {"field_gt": {"company_size": 50}}    # >50                     │
│     "when": {"field_gte": {"company_size": 10}}   # >=10                    │
│     "when": {"field_lt": {"company_size": 100}}   # <100                    │
│                                                                             │
├─────────────────────────────────────────────────────────────────────────────┤
│  СОСТОЯНИЕ                                                                  │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│  7. state_in — текущее состояние в списке                                   │
│     "when": {"state_in": ["presentation", "close"]}                         │
│                                                                             │
│  8. spin_phase_in — текущая SPIN-фаза в списке                              │
│     "when": {"spin_phase_in": ["implication", "need_payoff"]}               │
│                                                                             │
│  9. is_spin_state — находимся в SPIN-фазе (bool)                            │
│     "when": {"is_spin_state": true}                                         │
│                                                                             │
│  10. data_complete — все required_data собраны                              │
│      "when": {"data_complete": true}                                        │
│                                                                             │
├─────────────────────────────────────────────────────────────────────────────┤
│  ТЕКУЩИЙ И ПРЕДЫДУЩИЙ ИНТЕНТ                                                │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│  11. current_intent_in — текущий интент в списке                            │
│      "when": {"current_intent_in": ["price_question", "pricing_details"]}   │
│      # Редко нужно — обычно правила уже по интенту                          │
│                                                                             │
│  12. prev_intent — предыдущий интент равен значению                         │
│      "when": {"prev_intent": "greeting"}                                    │
│                                                                             │
│  13. prev_intent_in — предыдущий интент в списке                            │
│      "when": {"prev_intent_in": ["greeting", "small_talk"]}                 │
│      # Полезно: после приветствия применить другую логику                   │
│                                                                             │
├─────────────────────────────────────────────────────────────────────────────┤
│  ИСТОРИЯ ИНТЕНТОВ (требует IntentTracker)                                   │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│  14. intent_streak — интент идёт подряд N+ раз (включая текущий)            │
│      # Подряд — по умолчанию                                                │
│      "when": {"intent_streak": {"min": 3}}   # на 3-м подряд сработает      │
│                                                                             │
│      # В окне последних N ходов                                             │
│      "when": {"intent_streak": {"min": 2, "scope": "window", "window": 5}}  │
│                                                                             │
│      # ВАЖНО: record() вызывается ДО проверки условий.                      │
│      # streak_count включает текущий интент.                                │
│      # min:3 = "этот интент идёт уже 3-й раз подряд"                        │
│                                                                             │
├─────────────────────────────────────────────────────────────────────────────┤
│  ВОЗРАЖЕНИЯ                                                                 │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│  15. objection_count — счётчик возражений                                   │
│      "when": {"objection_count": {"scope": "consecutive", "min": 2}}        │
│      "when": {"objection_count": {"scope": "total", "min": 3}}              │
│                                                                             │
├─────────────────────────────────────────────────────────────────────────────┤
│  МЕТАДАННЫЕ                                                                 │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│  16. turn_number — номер хода в диалоге                                     │
│      "when": {"turn_number": {"min": 5}}        # после 5 ходов             │
│      "when": {"turn_number": {"max": 3}}        # в первые 3 хода           │
│                                                                             │
├─────────────────────────────────────────────────────────────────────────────┤
│  ЛОГИЧЕСКИЕ ОПЕРАТОРЫ                                                       │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│  17. and — все условия истинны                                              │
│      "when": {"and": [{"has_any": [...]}, {"state_in": [...]}]}             │
│                                                                             │
│  18. or — любое условие истинно                                             │
│      "when": {"or": [{"has_any": [...]}, {"intent_streak": {"min": 3}}]}           │
│                                                                             │
│  19. not — инверсия условия                                                 │
│      "when": {"not": {"has_any": ["company_size"]}}                         │
│      {} → True (not False), {company_size: 10} → False (not True)           │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘

3.2.1 IntentTracker (реализация для intent_streak)

class IntentTracker:
    """
    Отслеживает историю интентов для conditional rules.

    ВАЖНО: Контракт timing'а
    ========================
    record() вызывается В НАЧАЛЕ apply_rules(), ДО проверки условий.
    Все методы возвращают значения ВКЛЮЧАЯ текущий записанный интент.

    Пример:
        Ход 1: price_question → record() → streak=1, min:3 → False
        Ход 2: price_question → record() → streak=2, min:3 → False
        Ход 3: price_question → record() → streak=3, min:3 → True ✓
    """
    MAX_HISTORY = 20

    def __init__(self):
        self.history: List[str] = []           # ["greeting", "price_question", ...]
        self._streak_count: int = 0            # Текущая серия одинаковых интентов
        self._last_intent: Optional[str] = None

    def record(self, intent: str) -> None:
        """
        Записать интент. Вызывать В НАЧАЛЕ apply_rules().

        После вызова streak_count() будет включать этот интент.
        """
        if intent == self._last_intent:
            self._streak_count += 1
        else:
            self._streak_count = 1

        self.history.append(intent)
        if len(self.history) > self.MAX_HISTORY:
            self.history.pop(0)

        self._last_intent = intent

    def streak_count(self, intent: str) -> int:
        """
        Сколько раз этот интент идёт подряд (включая текущий).

        Для intent_streak: {min: N} проверяем streak_count(intent) >= N.
        """
        if intent == self._last_intent:
            return self._streak_count
        return 0

    def count_in_window(self, intent: str, window: int = 5) -> int:
        """Сколько раз интент встречался в последних N ходах."""
        recent = self.history[-window:]
        return recent.count(intent)

    @property
    def last_intent(self) -> Optional[str]:
        """Последний записанный интент."""
        return self._last_intent

    @property
    def prev_intent(self) -> Optional[str]:
        """Интент до текущего (для условия prev_intent_in)."""
        if len(self.history) >= 2:
            return self.history[-2]
        return None

# Интеграция в StateMachine:
class StateMachine:
    def __init__(self):
        ...
        self.intent_tracker = IntentTracker()

3.2.2 EvaluatorContext (типизированный контракт)

@dataclass
class EvaluatorContext:
    """
    Контекст для проверки условий.
    Все поля гарантированно существуют.
    IntentTracker — единственный источник истории интентов (см. 3.7).
    """
    # Данные клиента
    collected_data: Dict[str, Any]

    # Состояние диалога
    state: str
    spin_phase: Optional[str]
    is_spin_state: bool

    # Интенты — текущий и предыдущий
    current_intent: str                # Интент который сейчас обрабатываем
    prev_intent: Optional[str]         # Предыдущий интент (до текущего)

    # IntentTracker — единый источник истории интентов
    intent_tracker: IntentTracker

    # Метаданные
    turn_number: int
    missing_required_data: List[str]

    @classmethod
    def from_state_machine(cls, sm: "StateMachine", intent: str) -> "EvaluatorContext":
        """
        Создать контекст для проверки условий.

        ВАЖНО: Контракт timing'а
        ========================
        record() вызывается В НАЧАЛЕ apply_rules(), ДО создания контекста.
        streak_count() включает текущий интент.
        prev_intent берётся из history[-2] (до текущего).

        Порядок в apply_rules():
            1. intent_tracker.record(intent, state)      # записываем текущий
            2. ctx = EvaluatorContext.from_state_machine(sm, intent)
            3. # Теперь streak_count(intent) включает текущий
        """
        config = SALES_STATES.get(sm.state, {})
        required = config.get("required_data", [])
        missing = [f for f in required if not sm.collected_data.get(f)]

        # prev_intent — то что было ДО записи текущего
        # К моменту вызова from_state_machine, intent уже записан,
        # поэтому prev_intent передаётся явно или берётся из истории
        history = sm.intent_tracker.history
        prev = history[-2].intent if len(history) >= 2 else None

        return cls(
            collected_data=sm.collected_data.copy(),
            state=sm.state,
            spin_phase=sm.spin_phase,
            is_spin_state=sm.spin_phase is not None,
            current_intent=intent,
            prev_intent=prev,
            intent_tracker=sm.intent_tracker,
            turn_number=len(history),
            missing_required_data=missing,
        )

Mapping условий → поля контекста:
┌────────────────────────┬─────────────────────────────────────────────────────┐
│  Условие               │  Использует                                         │
├────────────────────────┼─────────────────────────────────────────────────────┤
│  has_any/has_all       │  collected_data                                     │
│  missing_any/all       │  collected_data                                     │
│  field_equals/compare  │  collected_data                                     │
│  state_in              │  state                                              │
│  spin_phase_in         │  spin_phase                                         │
│  is_spin_state         │  is_spin_state                                      │
│  current_intent_in     │  current_intent                                     │
│  prev_intent           │  prev_intent                                        │
│  prev_intent_in        │  prev_intent                                        │
│  intent_streak         │  intent_tracker.streak_count() / .count_in_window() │
│  objection_count       │  intent_tracker.objection_consecutive() / .total()  │
│  turn_number           │  turn_number (= len(intent_tracker.history))        │
│  data_complete         │  missing_required_data (empty = complete)           │
└────────────────────────┴─────────────────────────────────────────────────────┘
3.3 Порядок проверки условий (для rules и transitions)

              Вход: rule или transition с conditions
                         │
                         ▼
         ┌───────────────────────────────┐
         │  conditions[0]                │
         │  when: {has_any: [...]}       │
         └───────────────────────────────┘
                         │
                    True? ──────────────────► return conditions[0]["then"]
                         │
                       False
                         │
                         ▼
         ┌───────────────────────────────┐
         │  conditions[1]                │
         │  when: {intent_streak: min:3} │
         └───────────────────────────────┘
                         │
                    True? ──────────────────► return conditions[1]["then"]
                         │
                       False
                         │
                         ▼
         ┌───────────────────────────────┐
         │  conditions[2]                │
         │  ...                          │
         └───────────────────────────────┘
                         │
                       False
                         │
                         ▼
         ┌───────────────────────────────┐
         │  return rule["default"]       │
         └───────────────────────────────┘
         
         ВАЖНО: Первое сработавшее условие побеждает!
         Порядок условий имеет значение.
3.4 Переиспользование правил (Python-level sharing)

Проблема: В текущей архитектуре одинаковые rules дублируются в spin_situation,
spin_problem, spin_implication, spin_need_payoff. Это нарушает DRY.

Решение: Python dict unpacking вместо runtime inheritance.

┌─────────────────────────────────────────────────────────────────────────────┐
│  ПОЧЕМУ НЕ RUNTIME INHERITANCE                                               │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│  ❌ inherit_rules: ["spin_phases"]  — магия, сложно дебажить                │
│  ❌ rule_groups в runtime           — "откуда пришло правило?"              │
│  ❌ 3 уровня приоритетов            — сложно для понимания                  │
│                                                                             │
│  ✓ {**SPIN_COMMON_RULES, ...}       — явно, на этапе определения            │
│  ✓ IDE поддержка (go to definition) — сразу видно источник                  │
│  ✓ 2 уровня: state.rules → global_rules                                     │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────────────────┐
│  УПРОЩЁННАЯ ИЕРАРХИЯ (2 уровня)                                              │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│  ┌─────────────────┐                                                        │
│  │  global_rules   │  ← Runtime fallback для всех состояний                 │
│  │  (приоритет 2)  │     greeting, gratitude, small_talk, question_*        │
│  └────────┬────────┘                                                        │
│           │                                                                 │
│           ▼                                                                 │
│  ┌─────────────────┐                                                        │
│  │  state.rules    │  ← Все правила состояния (включая shared)              │
│  │  (приоритет 1)  │     {**SPIN_COMMON_RULES, "unclear": "probe_situation"}│
│  └─────────────────┘                                                        │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘

Формат конфигурации:

# ═══════════════════════════════════════════════════════════════════════════
# Python-level sharing — обычные dict'ы для переиспользования
# ═══════════════════════════════════════════════════════════════════════════

SPIN_COMMON_RULES = {
    "price_question": {
        "default": "deflect_and_continue",
        "conditions": [
            {"when": {"has_any": ["company_size", "users_count"]},
             "then": "answer_with_facts"},
            {"when": {"intent_streak": {"min": 3}},  # 3-й раз подряд
             "then": "answer_with_price_range"}
        ]
    },
    "pricing_details": {
        "default": "deflect_and_continue",
        "conditions": [
            {"when": {"has_any": ["company_size", "users_count"]},
             "then": "answer_with_facts"}
        ]
    },
    "comparison": "answer_and_continue",
}

POST_SPIN_RULES = {
    "price_question": "answer_with_facts",   # Без deflect — данные уже есть
    "pricing_details": "answer_with_facts",
}

# ═══════════════════════════════════════════════════════════════════════════
# SALES_CONFIG — только 2 уровня: state.rules → global_rules
# ═══════════════════════════════════════════════════════════════════════════

SALES_CONFIG = {
    # Runtime fallback — применяются если нет правила в state.rules
    "global_rules": {
        "greeting": "acknowledge_and_continue",
        "gratitude": "acknowledge_and_continue",
        "small_talk": "small_talk_and_continue",
        "question_features": "answer_question",
        "question_integrations": "answer_question",
    },

    "states": {
        # SPIN states — Python unpacking, всё явно
        "spin_situation": {
            "rules": {**SPIN_COMMON_RULES, "unclear": "probe_situation"}
        },
        "spin_problem": {
            "rules": {**SPIN_COMMON_RULES, "unclear": "probe_problem"}
        },
        "spin_implication": {
            "rules": {**SPIN_COMMON_RULES, "unclear": "probe_implication"}
        },
        "spin_need_payoff": {
            "rules": {**SPIN_COMMON_RULES, "unclear": "probe_need_payoff"}
        },

        # Post-SPIN states
        "presentation": {
            "rules": {**POST_SPIN_RULES, "objection_price": "handle_objection"}
        },
        "close": {
            "rules": {**POST_SPIN_RULES, "demo_request": "schedule_demo"}
        },
    }
}

Алгоритм разрешения правила (упрощённый):

def _get_rule_for_intent(self, state: str, intent: str) -> Optional[Union[str, Dict]]:
    """Получить правило — только 2 уровня"""
    config = SALES_CONFIG["states"].get(state, {})

    # Приоритет 1: Правило состояния (уже включает shared через unpacking)
    if intent in config.get("rules", {}):
        return config["rules"][intent]

    # Приоритет 2: Глобальные правила (fallback)
    if intent in SALES_CONFIG.get("global_rules", {}):
        return SALES_CONFIG["global_rules"][intent]

    return None  # Правило не найдено → default в apply_rules()

Результат:
┌────────────────────────────────┬────────────────────────────────────────────┐
│  Было                          │  Стало                                     │
├────────────────────────────────┼────────────────────────────────────────────┤
│  3 уровня runtime inheritance  │  2 уровня: state.rules → global_rules      │
│  inherit_rules: ["spin_phases"]│  {**SPIN_COMMON_RULES, ...}                │
│  rule_groups в config          │  Обычные Python dict'ы                     │
│  Магия в runtime               │  Явно на этапе определения                 │
│  Сложно дебажить               │  IDE go-to-definition работает             │
└────────────────────────────────┴────────────────────────────────────────────┘

3.5 Порядок разрешения action и переходов

┌─────────────────────────────────────────────────────────────────────────────┐
│  НОВАЯ СТРУКТУРА apply_rules()                                               │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│  def apply_rules(self, intent: str) -> RuleResult:                          │
│      # ═══════════════════════════════════════════════════════════════════  │
│      # 0. HOOKS: Записываем интент в tracker                                │
│      # ═══════════════════════════════════════════════════════════════════  │
│      self.intent_tracker.record(intent, self.state)                         │
│                                                                             │
│      # ═══════════════════════════════════════════════════════════════════  │
│      # 1. Создаём контекст (current_intent + prev_intent уже доступны)      │
│      # ═══════════════════════════════════════════════════════════════════  │
│      ctx = EvaluatorContext.from_state_machine(self, intent)                │
│      config = SALES_CONFIG["states"].get(self.state, {})                    │
│                                                                             │
│      # ═══════════════════════════════════════════════════════════════════  │
│      # 2. EARLY EXITS: final, rejection, go_back                            │
│      # ═══════════════════════════════════════════════════════════════════  │
│      early_exit = self._check_early_exits(intent, config)                   │
│      if early_exit:                                                         │
│          return early_exit                                                  │
│                                                                             │
│      # ═══════════════════════════════════════════════════════════════════  │
│      # 3. RESOLVE ACTION: rules → global_rules → default                    │
│      # ═══════════════════════════════════════════════════════════════════  │
│      action, action_info = self._resolve_action(intent, config, ctx)        │
│                                                                             │
│      # ═══════════════════════════════════════════════════════════════════  │
│      # 4. RESOLVE TRANSITION: transitions → SPIN → data_complete → stay     │
│      # ═══════════════════════════════════════════════════════════════════  │
│      next_state, trans_info = self._resolve_transition(intent, config, ctx) │
│                                                                             │
│      # ═══════════════════════════════════════════════════════════════════  │
│      # 5. Возвращаем RuleResult (обратно совместим с tuple unpacking)       │
│      # ═══════════════════════════════════════════════════════════════════  │
│      return RuleResult(                                                     │
│          action=action,                                                     │
│          next_state=next_state,                                             │
│          rule_info={"action": action_info, "transition": trans_info}        │
│      )                                                                      │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘

Action resolver (подробно):
1) state.rules[intent] (str или conditional) — уже включает shared через **unpacking
2) global_rules[intent] — runtime fallback
3) default → continue_current_goal

Transition resolver (подробно):
1) state.transitions[intent] (str или conditional)
2) SPIN progress (situation_provided → spin_problem, etc.)
3) data_complete
4) transitions["any"]
5) stay in current state

3.6 Intent Categories и Hooks

ПРОБЛЕМА: В текущем коде категории интентов hardcoded:
- OBJECTION_INTENTS = ["objection_price", ...]
- POSITIVE_INTENTS = {"agreement", "demo_request", ...}
- GO_BACK_INTENTS = ["go_back", "correct_info"]
- QUESTION_INTENTS = [...]

РЕШЕНИЕ: Вынести категории в config, оставить только hooks в коде.

┌─────────────────────────────────────────────────────────────────────────────┐
│  INTENT_CATEGORIES — определяют какие hooks вызывать                         │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│  # config.py                                                                │
│  INTENT_CATEGORIES = {                                                      │
│      "objection": [                                                         │
│          "objection_price",                                                 │
│          "objection_competitor",                                            │
│          "objection_no_time",                                               │
│          "objection_think"                                                  │
│      ],                                                                     │
│      "positive": [                                                          │
│          "agreement", "demo_request", "callback_request", "contact_provided",│
│          "consultation_request",                                            │
│          "situation_provided", "problem_revealed", "implication_acknowledged",│
│          "need_expressed", "info_provided",                                 │
│          "question_features", "question_integrations", "comparison",        │
│          "greeting", "gratitude"                                            │
│      ],                                                                     │
│      "go_back": ["go_back", "correct_info"],                                │
│      "question": [                                                          │
│          "question_features", "question_integrations", "question_technical" │
│      ]                                                                      │
│  }                                                                          │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────────────────┐
│  HOOKS — минимальный код для side effects                                    │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│  # state_machine.py                                                         │
│  def _apply_hooks(self, intent: str) -> None:                               │
│      """                                                                    │
│      Side effects based on intent category.                                 │
│      Читает категории из INTENT_CATEGORIES.                                 │
│      """                                                                    │
│      categories = INTENT_CATEGORIES                                         │
│                                                                             │
│      # Objection tracking                                                   │
│      if intent in categories.get("objection", []):                          │
│          self.objection_flow.record_objection(intent, self.state)           │
│                                                                             │
│      # Reset objection count on positive intents                            │
│      if intent in categories.get("positive", []):                           │
│          self.objection_flow.reset_consecutive()                            │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────────────────┐
│  РЕЗУЛЬТАТЫ — через conditional rules/transitions                           │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│  # Вместо hardcoded: if should_soft_close(): return "...", "soft_close"     │
│  # Используем условие objection_count в rules/transitions:                  │
│                                                                             │
│  # Любое состояние где может быть objection                                 │
│  "rules": {                                                                 │
│      "objection_price": {                                                   │
│          "default": "handle_objection",                                     │
│          "conditions": [                                                    │
│              {                                                              │
│                  "when": {"objection_count": {"scope": "consecutive", "min": 3}},│
│                  "then": "objection_limit_reached"                          │
│              }                                                              │
│          ]                                                                  │
│      }                                                                      │
│  },                                                                         │
│  "transitions": {                                                           │
│      "objection_price": {                                                   │
│          "default": "handle_objection",                                     │
│          "conditions": [                                                    │
│              {                                                              │
│                  "when": {"objection_count": {"scope": "consecutive", "min": 3}},│
│                  "then": "soft_close"                                       │
│              }                                                              │
│          ]                                                                  │
│      }                                                                      │
│  }                                                                          │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────────────────┐
│  GLOBAL_RULES — для QUESTION_INTENTS                                         │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│  # Вместо hardcoded: if intent in QUESTION_INTENTS: return "answer_question"│
│  # Используем global_rules:                                                 │
│                                                                             │
│  SALES_CONFIG = {                                                           │
│      "global_rules": {                                                      │
│          # Применяются ко ВСЕМ состояниям если нет state-specific rule      │
│          "question_features": "answer_question",                            │
│          "question_integrations": "answer_question",                        │
│          "question_technical": "answer_question",                           │
│          "greeting": "acknowledge_and_continue",                            │
│          "gratitude": "acknowledge_and_continue",                           │
│          "small_talk": "small_talk_and_continue"                            │
│      },                                                                     │
│      "states": { ... }                                                      │
│  }                                                                          │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘

Что это даёт:
┌────────────────────────────────┬────────────────────────────────────────────┐
│  Было                          │  Стало                                     │
├────────────────────────────────┼────────────────────────────────────────────┤
│  OBJECTION_INTENTS hardcoded   │  INTENT_CATEGORIES["objection"] в config   │
│  POSITIVE_INTENTS hardcoded    │  INTENT_CATEGORIES["positive"] в config    │
│  QUESTION_INTENTS → answer_q   │  global_rules в config                     │
│  if should_soft_close(): ...   │  условие objection_count в rules           │
│  8+ if'ов в apply_rules()      │  3 этапа: hooks → action → transition      │
└────────────────────────────────┴────────────────────────────────────────────┘

3.7 IntentTracker — единый источник истории интентов

ПРОБЛЕМА: Дублирование tracking'а в 4+ местах

┌─────────────────────────────────────────────────────────────────────────────┐
│  ТЕКУЩЕЕ СОСТОЯНИЕ — ДУБЛИРОВАНИЕ ВЕЗДЕ                                      │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│  1. StateMachine.last_intent                                                │
│     self.last_intent = intent  # в process()                                │
│                                                                             │
│  2. Bot.last_intent                                                         │
│     self.last_intent = classified_intent  # в process_message()             │
│                                                                             │
│  3. ContextEnvelope.last_intent                                             │
│     "last_intent": self.state_machine.last_intent  # в envelope             │
│                                                                             │
│  4. ObjectionFlowManager.objection_count + objection_history                │
│     Отдельный класс только для возражений:                                  │
│     - objection_count: int (consecutive)                                    │
│     - total_objections: int                                                 │
│     - objection_history: List[Tuple[str, str]]                              │
│                                                                             │
│  5. ContextWindow.get_objection_count()                                     │
│     Ещё один подсчёт через window                                           │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘

Проблемы:
- Рассинхронизация: Bot.last_intent может отличаться от SM.last_intent
- ObjectionFlowManager дублирует то, что можно вычислить из истории интентов
- Нет единого места для запроса "сколько раз price_question подряд"
- Сложно добавить новые метрики (например, "сколько вопросов в последних 5 ходах")

РЕШЕНИЕ: IntentTracker как единый источник правды

┌─────────────────────────────────────────────────────────────────────────────┐
│  IntentTracker — заменяет ВСЁ                                                │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│  @dataclass                                                                 │
│  class IntentRecord:                                                        │
│      """Запись об одном интенте"""                                          │
│      intent: str                                                            │
│      state: str                      # состояние на момент интента          │
│      timestamp: float                # время для дебага                     │
│      category: Optional[str] = None  # "objection", "positive", etc.        │
│                                                                             │
│                                                                             │
│  class IntentTracker:                                                       │
│      """                                                                    │
│      Единый источник истории интентов.                                      │
│      Заменяет: last_intent, ObjectionFlowManager, ContextWindow.objections  │
│      """                                                                    │
│      MAX_HISTORY = 50                # Достаточно для любых window условий  │
│                                                                             │
│      def __init__(self):                                                    │
│          self.history: List[IntentRecord] = []                              │
│          self._consecutive_cache: Dict[str, int] = {}                       │
│          self._last_intent: Optional[str] = None                            │
│                                                                             │
│      # ═══════════════════════════════════════════════════════════════════  │
│      # ЗАПИСЬ                                                               │
│      # ═══════════════════════════════════════════════════════════════════  │
│                                                                             │
│      def record(self, intent: str, state: str) -> None:                     │
│          """Записать интент (вызывается в начале SM.process)"""             │
│          category = self._get_category(intent)                              │
│          record = IntentRecord(                                             │
│              intent=intent,                                                 │
│              state=state,                                                   │
│              timestamp=time.time(),                                         │
│              category=category                                              │
│          )                                                                  │
│                                                                             │
│          # Update consecutive cache                                         │
│          if intent == self._last_intent:                                    │
│              self._consecutive_cache[intent] = \                            │
│                  self._consecutive_cache.get(intent, 1) + 1                 │
│          else:                                                              │
│              self._consecutive_cache = {intent: 1}                          │
│                                                                             │
│          self.history.append(record)                                        │
│          if len(self.history) > self.MAX_HISTORY:                           │
│              self.history.pop(0)                                            │
│                                                                             │
│          self._last_intent = intent                                         │
│                                                                             │
│      def _get_category(self, intent: str) -> Optional[str]:                 │
│          """Определить категорию интента из INTENT_CATEGORIES"""            │
│          for category, intents in INTENT_CATEGORIES.items():                │
│              if intent in intents:                                          │
│                  return category                                            │
│          return None                                                        │
│                                                                             │
│      # ═══════════════════════════════════════════════════════════════════  │
│      # ЧТЕНИЕ — базовые свойства                                            │
│      # ═══════════════════════════════════════════════════════════════════  │
│                                                                             │
│      @property                                                              │
│      def last_intent(self) -> Optional[str]:                                │
│          """Последний интент (заменяет SM.last_intent, Bot.last_intent)"""  │
│          return self._last_intent                                           │
│                                                                             │
│      @property                                                              │
│      def last_record(self) -> Optional[IntentRecord]:                       │
│          """Полная запись о последнем интенте"""                            │
│          return self.history[-1] if self.history else None                  │
│                                                                             │
│      # ═══════════════════════════════════════════════════════════════════  │
│      # ЧТЕНИЕ — для условий intent_streak                                   │
│      # ═══════════════════════════════════════════════════════════════════  │
│                                                                             │
│      def streak_count(self, intent: str) -> int:                            │
│          """                                                                │
│          Сколько раз этот интент идёт подряд (включая текущий).             │
│          Для intent_streak: {min: N} проверяем streak_count(intent) >= N.   │
│          """                                                                │
│          if intent == self._last_intent:                                    │
│              return self._streak_count                                      │
│          return 0                                                           │
│                                                                             │
│      def count_in_window(self, intent: str, window: int = 5) -> int:        │
│          """Сколько раз интент встречался в последних N ходах."""           │
│          recent = self.history[-window:] if window else self.history        │
│          return sum(1 for r in recent if r.intent == intent)                │
│                                                                             │
│      # ═══════════════════════════════════════════════════════════════════  │
│      # ЧТЕНИЕ — для условий objection_count (заменяет ObjectionFlowManager) │
│      # ═══════════════════════════════════════════════════════════════════  │
│                                                                             │
│      def objection_consecutive(self) -> int:                                │
│          """Сколько возражений подряд (для objection_count: consecutive)""" │
│          count = 0                                                          │
│          for record in reversed(self.history):                              │
│              if record.category == "objection":                             │
│                  count += 1                                                 │
│              else:                                                          │
│                  break                                                      │
│          return count                                                       │
│                                                                             │
│      def objection_total(self) -> int:                                      │
│          """Всего возражений за диалог (для objection_count: total)"""      │
│          return sum(1 for r in self.history if r.category == "objection")   │
│                                                                             │
│      def objection_in_window(self, window: int = 5) -> int:                 │
│          """Возражений в последних N ходах"""                               │
│          recent = self.history[-window:] if window else self.history        │
│          return sum(1 for r in recent if r.category == "objection")         │
│                                                                             │
│      # ═══════════════════════════════════════════════════════════════════  │
│      # ЧТЕНИЕ — для других категорий                                        │
│      # ═══════════════════════════════════════════════════════════════════  │
│                                                                             │
│      def category_consecutive(self, category: str) -> int:                  │
│          """Сколько интентов данной категории подряд"""                     │
│          count = 0                                                          │
│          for record in reversed(self.history):                              │
│              if record.category == category:                                │
│                  count += 1                                                 │
│              else:                                                          │
│                  break                                                      │
│          return count                                                       │
│                                                                             │
│      def positive_consecutive(self) -> int:                                 │
│          """Сколько положительных интентов подряд"""                        │
│          return self.category_consecutive("positive")                       │
│                                                                             │
│      # ═══════════════════════════════════════════════════════════════════  │
│      # СЕРИАЛИЗАЦИЯ (для ContextEnvelope)                                   │
│      # ═══════════════════════════════════════════════════════════════════  │
│                                                                             │
│      def to_dict(self) -> Dict:                                             │
│          """Сериализация для передачи в LLM context"""                      │
│          return {                                                           │
│              "last_intent": self._last_intent,                              │
│              "current_streak": self._streak_count,  # Текущая серия         │
│              "objection_consecutive": self.objection_consecutive(),         │
│              "objection_total": self.objection_total(),                     │
│              "recent_intents": [r.intent for r in self.history[-5:]]        │
│          }                                                                  │
│                                                                             │
│      def reset(self) -> None:                                               │
│          """Сброс (для начала нового диалога)"""                            │
│          self.history.clear()                                               │
│          self._streak_count = 0                                             │
│          self._last_intent = None                                           │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘

Что удаляется:

┌─────────────────────────────────────────────────────────────────────────────┐
│  КОМПОНЕНТЫ К УДАЛЕНИЮ                                                       │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│  1. StateMachine.last_intent                                                │
│     - УДАЛИТЬ: self.last_intent = intent                                    │
│     - ЗАМЕНИТЬ НА: self.intent_tracker.record(intent, self.state)           │
│                                                                             │
│  2. Bot.last_intent                                                         │
│     - УДАЛИТЬ: self.last_intent = classified_intent                         │
│     - ДОСТУП ЧЕРЕЗ: self.state_machine.intent_tracker.last_intent           │
│                                                                             │
│  3. ContextEnvelope → "last_intent"                                         │
│     - УДАЛИТЬ: "last_intent": self.state_machine.last_intent                │
│     - ЗАМЕНИТЬ НА: "intent_tracker": self.state_machine.intent_tracker.to_dict()
│                                                                             │
│  4. ObjectionFlowManager (ВЕСЬ КЛАСС)                                       │
│     - УДАЛИТЬ: class ObjectionFlowManager                                   │
│     - УДАЛИТЬ: self.objection_flow = ObjectionFlowManager()                 │
│     - ЗАМЕНИТЬ:                                                             │
│       objection_flow.objection_count → intent_tracker.objection_consecutive()
│       objection_flow.total_objections → intent_tracker.objection_total()    │
│       objection_flow.record_objection() → intent_tracker.record() [автоматически]
│       objection_flow.reset_consecutive() → не нужен (вычисляется динамически)
│                                                                             │
│  5. ContextWindow.get_objection_count() (если есть дублирование)            │
│     - Проверить и удалить, если дублирует IntentTracker                     │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘

Интеграция с EvaluatorContext:

┌─────────────────────────────────────────────────────────────────────────────┐
│  ОБНОВЛЁННЫЙ EvaluatorContext                                                │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│  @dataclass                                                                 │
│  class EvaluatorContext:                                                    │
│      # Данные клиента                                                       │
│      collected_data: Dict[str, Any]                                         │
│                                                                             │
│      # Состояние диалога                                                    │
│      state: str                                                             │
│      spin_phase: Optional[str]                                              │
│      is_spin_state: bool                                                    │
│                                                                             │
│      # ═══════════════════════════════════════════════════════════════════  │
│      # IntentTracker — ЕДИНСТВЕННЫЙ источник истории интентов               │
│      # ═══════════════════════════════════════════════════════════════════  │
│      intent_tracker: IntentTracker     # ← NEW: весь трекер                 │
│                                                                             │
│      # Метаданные                                                           │
│      turn_number: int                                                       │
│      missing_required_data: List[str]                                       │
│                                                                             │
│      # Удалено (доступ через intent_tracker):                               │
│      # - last_intent → intent_tracker.last_intent                           │
│      # - intent_streak → intent_tracker.streak_count(intent)                │
│      # - intent_history → intent_tracker.history                            │
│      # - objection_consecutive → intent_tracker.objection_consecutive()     │
│      # - objection_total → intent_tracker.objection_total()                 │
│                                                                             │
│      @classmethod                                                           │
│      def from_state_machine(cls, sm: "StateMachine") -> "EvaluatorContext": │
│          config = SALES_STATES.get(sm.state, {})                            │
│          required = config.get("required_data", [])                         │
│          missing = [f for f in required if not sm.collected_data.get(f)]    │
│                                                                             │
│          return cls(                                                        │
│              collected_data=sm.collected_data.copy(),                       │
│              state=sm.state,                                                │
│              spin_phase=sm.spin_phase,                                      │
│              is_spin_state=sm.spin_phase is not None,                       │
│              intent_tracker=sm.intent_tracker,  # Передаём весь трекер      │
│              turn_number=len(sm.intent_tracker.history),                    │
│              missing_required_data=missing,                                 │
│          )                                                                  │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘

Обновлённый ConditionEvaluator:

┌─────────────────────────────────────────────────────────────────────────────┐
│  EVALUATOR ИСПОЛЬЗУЕТ IntentTracker                                          │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│  class ConditionEvaluator:                                                  │
│      def evaluate(self, condition: Dict, ctx: EvaluatorContext) -> bool:    │
│          ...                                                                │
│                                                                             │
│      def _eval_intent_streak(self, params, ctx) -> bool:                    │
│          """                                                                │
│          intent_streak: {min: 3} — интент идёт подряд минимум 3 раза.       │
│          intent_streak: {min: 2, scope: "window", window: 5} — в окне.      │
│                                                                             │
│          ВАЖНО: streak_count() включает текущий интент (record() до eval).  │
│          min:3 = "этот интент идёт уже 3-й раз подряд"                      │
│          """                                                                │
│          min_count = params.get("min", 1)                                   │
│          scope = params.get("scope", "consecutive")                         │
│          intent = ctx.current_intent                                        │
│                                                                             │
│          if scope == "consecutive":                                         │
│              actual = ctx.intent_tracker.streak_count(intent)               │
│          elif scope == "window":                                            │
│              window = params.get("window", 5)                               │
│              actual = ctx.intent_tracker.count_in_window(intent, window)    │
│          else:                                                              │
│              actual = ctx.intent_tracker.streak_count(intent)               │
│                                                                             │
│          return actual >= min_count                                         │
│                                                                             │
│      def _eval_objection_count(self, params, ctx) -> bool:                  │
│          """objection_count: {scope: "consecutive", min: 3}"""              │
│          min_count = params.get("min", 1)                                   │
│          scope = params.get("scope", "consecutive")                         │
│                                                                             │
│          if scope == "consecutive":                                         │
│              actual = ctx.intent_tracker.objection_consecutive()            │
│          elif scope == "total":                                             │
│              actual = ctx.intent_tracker.objection_total()                  │
│          elif scope == "window":                                            │
│              window = params.get("window", 5)                               │
│              actual = ctx.intent_tracker.objection_in_window(window)        │
│          else:                                                              │
│              actual = ctx.intent_tracker.objection_consecutive()            │
│                                                                             │
│          return actual >= min_count                                         │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘

Обновлённые Hooks:

┌─────────────────────────────────────────────────────────────────────────────┐
│  HOOKS ИСПОЛЬЗУЮТ IntentTracker (проще!)                                     │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│  # БЫЛО (с ObjectionFlowManager):                                           │
│  def _apply_hooks(self, intent: str) -> None:                               │
│      if intent in INTENT_CATEGORIES.get("objection", []):                   │
│          self.objection_flow.record_objection(intent, self.state)           │
│      if intent in INTENT_CATEGORIES.get("positive", []):                    │
│          self.objection_flow.reset_consecutive()                            │
│                                                                             │
│  # СТАЛО (с IntentTracker):                                                 │
│  def _apply_hooks(self, intent: str) -> None:                               │
│      # Просто записываем — IntentTracker сам определит категорию            │
│      self.intent_tracker.record(intent, self.state)                         │
│      # Всё! Objection tracking теперь автоматический через category         │
│                                                                             │
│  # Метод _apply_hooks становится тривиальным и может быть inline в process()│
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘

Результат:

┌────────────────────────────────┬────────────────────────────────────────────┐
│  Было                          │  Стало                                     │
├────────────────────────────────┼────────────────────────────────────────────┤
│  4+ источника last_intent      │  1 источник: intent_tracker.last_intent    │
│  ObjectionFlowManager класс    │  УДАЛЁН                                    │
│  Ручной record_objection()     │  Автоматически через category              │
│  Ручной reset_consecutive()    │  Не нужен (динамическое вычисление)        │
│  Синхронизация между Bot и SM  │  Не нужна (единый источник)                │
│  Сложно добавить новые метрики │  Легко: новый метод в IntentTracker        │
└────────────────────────────────┴────────────────────────────────────────────┘

Часть 4: ПРИМЕРЫ ПРИМЕНЕНИЯ
4.1 Price Question (текущий баг)
До:


# config.py
"price_question": "deflect_and_continue"

# state_machine.py — КОСТЫЛЬ
if intent == "price_question" and rule_action == "deflect_and_continue":
    if self.collected_data.get("company_size"):
        return "answer_with_facts", self.state
После:


# config.py — ВСЯ ЛОГИКА ЗДЕСЬ
"price_question": {
    "default": "deflect_and_continue",
    "conditions": [
        {
            "when": {"has_any": ["company_size", "users_count"]},
            "then": "answer_with_facts"
        }
    ]
}

# state_machine.py — БЕЗ КОСТЫЛЕЙ
# Resolvers обрабатывают всё автоматически
4.2 Эскалация при повторных вопросах о цене

"price_question": {
    "default": "deflect_and_continue",
    "conditions": [
        # Приоритет 1: Если данные есть — ответить
        {
            "when": {"has_any": ["company_size", "users_count"]},
            "then": "answer_with_facts"
        },
        # Приоритет 2: Если спросил 3-й раз подряд — дать диапазон
        {
            "when": {"intent_streak": {"min": 3}},
            "then": "answer_with_price_range"
        }
    ]
}
Сценарий:


Ход 1: "Сколько стоит?"     → deflect (данных нет, streak=1, min:3 → False)
Ход 2: "Ну почем?"          → deflect (данных нет, streak=2, min:3 → False)
Ход 3: "Цену скажи!"        → answer_with_price_range (streak=3, min:3 → True!)
4.3 Умная обработка возражения о цене

"objection_price": {
    "default": "handle_price_objection_generic",
    "conditions": [
        # Если знаем боль и размер — показать ROI
        {
            "when": {"has_all": ["pain_point", "company_size"]},
            "then": "handle_price_with_roi"
        },
        # Если только размер — сравнить с конкурентами
        {
            "when": {"has_any": ["company_size"]},
            "then": "handle_price_with_comparison"
        }
    ]
}
Примечание: правила для objection_* размещаются в состоянии handle_objection,
переход в него управляется через transitions (могут быть conditional).
4.4 Технические вопросы с эскалацией

"question_technical": {
    "default": "answer_technical",
    "conditions": [
        # Если спрашивает 2-й раз подряд — предложить документацию
        {
            "when": {"intent_streak": {"min": 2}},
            "then": "offer_documentation_link"
        }
    ]
}
4.5 Условный переход (conditional transitions)

# Пример: demo_request переводит в success только если есть контакт
"close": {
    "transitions": {
        "demo_request": {
            "default": null,          # null → не переходить, остаться в close
            "conditions": [
                {
                    "when": {"has_any": ["contact_info"]},
                    "then": "success"
                }
            ]
        },
        # Простые переходы работают как раньше
        "contact_provided": "success",
        "rejection": "soft_close"
    }
}

# Комментарий:
# - transitions внутри state, поэтому state_in не нужен
# - если условия не сработали → default (null = остаёмся)
# - если default не указан → fallback на SPIN/data_complete логику
Часть 5: ПЛАН РЕАЛИЗАЦИИ
5.1 Структура изменений

┌─────────────────────────────────────────────────────────────────────────────┐
│                           ФАЙЛЫ ДЛЯ ИЗМЕНЕНИЯ                               │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│  src/                                                                       │
│  ├── config.py                 ← INTENT_CATEGORIES, SPIN_COMMON_RULES,      │
│  │                               POST_SPIN_RULES, SALES_CONFIG              │
│  ├── state_machine.py          ← Рефакторинг apply_rules():                 │
│  │                               _apply_hooks, _resolve_action,             │
│  │                               _resolve_transition                        │
│  ├── condition_evaluator.py    ← НОВЫЙ: логика проверки условий             │
│  ├── intent_tracker.py         ← НОВЫЙ: отслеживание истории интентов       │
│  └── rule_validator.py         ← НОВЫЙ: валидация схемы правил              │
│                                                                             │
│  tests/                                                                     │
│  ├── test_condition_evaluator.py  ← НОВЫЙ: unit-тесты условий               │
│  ├── test_intent_tracker.py       ← НОВЫЙ: тесты IntentTracker              │
│  ├── test_conditional_rules.py    ← НОВЫЙ: интеграционные тесты             │
│  └── test_state_machine.py        ← Обновить существующие тесты             │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
5.2 Этапы

┌─────────────────────────────────────────────────────────────────────────────┐
│  ЭТАП 1: Схема config + контракт контекста                                  │
├─────────────────────────────────────────────────────────────────────────────┤
│  1. Зафиксировать разделение: rules → action, transitions → state           │
│  2. Определить INTENT_CATEGORIES (objection, positive, go_back, question)   │
│  3. Определить SPIN_COMMON_RULES, POST_SPIN_RULES, SALES_CONFIG             │
│  4. Определить EvaluatorContext dataclass                                   │
└─────────────────────────────────────────────────────────────────────────────┘
                                    │
                                    ▼
┌─────────────────────────────────────────────────────────────────────────────┐
│  ЭТАП 2: IntentTracker + Condition Evaluator                                │
├─────────────────────────────────────────────────────────────────────────────┤
│  1. Создать src/intent_tracker.py:                                          │
│     - IntentRecord dataclass (intent, state, timestamp, category)           │
│     - IntentTracker класс с методами:                                       │
│       • record(intent, state) — запись интента (вызывать ДО проверки)       │
│       • streak_count(intent) — подряд для intent_streak (включая текущий)   │
│       • count_in_window(intent, window) — в окне для scope: "window"        │
│       • objection_consecutive() — подряд возражений (заменяет OFM)          │
│       • objection_total() — всего возражений (заменяет OFM)                 │
│       • to_dict() — сериализация для ContextEnvelope                        │
│  2. Создать src/condition_evaluator.py                                      │
│  3. Реализовать все типы условий (has_any, objection_count, etc.)           │
│  4. Написать unit-тесты для каждого модуля                                  │
│  5. Результат: модули можно тестировать изолированно                        │
└─────────────────────────────────────────────────────────────────────────────┘
                                    │
                                    ▼
┌─────────────────────────────────────────────────────────────────────────────┐
│  ЭТАП 3: Рефакторинг State Machine + Удаление дублирования                  │
├─────────────────────────────────────────────────────────────────────────────┤
│  1. Добавить _apply_hooks() — вызывает intent_tracker.record()              │
│  2. Добавить _resolve_action() — rules → global_rules (2 уровня)            │
│  3. Добавить _resolve_transition() — transitions → SPIN → data_complete     │
│  4. Упростить apply_rules() до 4 шагов (hooks, early_exit, action, state)   │
│  5. Удалить hardcoded списки (OBJECTION_INTENTS, POSITIVE_INTENTS, etc.)    │
│  6. Удалить костыль price_question                                          │
│  7. УДАЛИТЬ дублирующие компоненты (см. секция 3.7):                        │
│     - StateMachine.last_intent → intent_tracker.last_intent                 │
│     - ObjectionFlowManager (весь класс) → intent_tracker.objection_*()      │
│     - self.objection_flow → удалить                                         │
│  8. В Bot.py:                                                               │
│     - УДАЛИТЬ: Bot.last_intent                                              │
│     - ДОСТУП ЧЕРЕЗ: self.state_machine.intent_tracker.last_intent           │
│  9. В ContextEnvelope:                                                      │
│     - ЗАМЕНИТЬ: "last_intent" → "intent_tracker": tracker.to_dict()         │
│  10. Обеспечить обратную совместимость (str rules работают)                 │
└─────────────────────────────────────────────────────────────────────────────┘
                                    │
                                    ▼
┌─────────────────────────────────────────────────────────────────────────────┐
│  ЭТАП 4: Миграция config.py                                                 │
├─────────────────────────────────────────────────────────────────────────────┤
│  1. Добавить INTENT_CATEGORIES                                              │
│  2. Добавить global_rules (greeting, gratitude, question_*)                 │
│  3. Добавить SPIN_COMMON_RULES, POST_SPIN_RULES (Python dict'ы)             │
│  4. Конвертировать price_question в conditional format                      │
│  5. Добавить conditional transitions для objection_* (objection_count)      │
│  6. Мигрировать SPIN-состояния на **unpacking вместо дублирования           │
└─────────────────────────────────────────────────────────────────────────────┘
                                    │
                                    ▼
┌─────────────────────────────────────────────────────────────────────────────┐
│  ЭТАП 5: Тестирование                                                       │
├─────────────────────────────────────────────────────────────────────────────┤
│  1. Unit-тесты evaluator                                                    │
│  2. Интеграционные тесты приоритетов action/transition                      │
│  3. Проверка SPIN-прогресса и objections                                    │
└─────────────────────────────────────────────────────────────────────────────┘
                                    │
                                    ▼
┌─────────────────────────────────────────────────────────────────────────────┐
│  ЭТАП 6: Валидация                                                         │
├─────────────────────────────────────────────────────────────────────────────┤
│  1. Жёсткая схема в CI                                                     │
│  2. Мягкий fallback + лог/метрики в runtime                                │
└─────────────────────────────────────────────────────────────────────────────┘
5.3 Обратная совместимость

def _resolve_action(self, rule: Union[str, Dict]) -> str:
    """
    Action resolver с обратной совместимостью.
    """
    # Обратная совместимость: строка работает как раньше
    if isinstance(rule, str):
        return rule

    # Новый формат: dict с conditions
    if isinstance(rule, dict):
        for condition in rule.get("conditions", []):
            if self.evaluator.evaluate(condition["when"], self._get_context()):
                return condition["then"]
        return rule.get("default", "continue_current_goal")

    # Fallback
    return "continue_current_goal"

def _resolve_transition(self, rule: Union[str, Dict]) -> Optional[str]:
    """
    Transition resolver с обратной совместимостью.
    """
    # Обратная совместимость: строка = явный next_state
    if isinstance(rule, str):
        return rule

    # Новый формат: dict с conditions
    if isinstance(rule, dict):
        for condition in rule.get("conditions", []):
            if self.evaluator.evaluate(condition["when"], self._get_context()):
                return condition["then"]
        return rule.get("default")  # None → fallback на transitions/SPIN

    # Fallback
    return None
Это значит:

Все существующие "intent": "action" правила продолжают работать
Все существующие transitions остаются источником переходов по умолчанию
Можно мигрировать правила по одному
Нет "big bang" миграции
Часть 6: ОЖИДАЕМЫЕ РЕЗУЛЬТАТЫ
6.1 До и После
Аспект	До	После
Где логика	config.py + state_machine.py	Только config.py (rules + transitions)
Добавить условие	Писать if в коде	Добавить в config
Понять поведение	Читать код SM	Читать config
Тестировать условие	Поднимать весь SM	Unit-тест evaluator
Количество костылей	Растёт	0
6.2 Пример: Как будет выглядеть config.py

# ═══════════════════════════════════════════════════════════════════════════════
# INTENT_CATEGORIES — категории интентов для hooks
# ═══════════════════════════════════════════════════════════════════════════════
INTENT_CATEGORIES = {
    "objection": [
        "objection_price", "objection_competitor",
        "objection_no_time", "objection_think"
    ],
    "positive": [
        "agreement", "demo_request", "callback_request", "contact_provided",
        "situation_provided", "problem_revealed", "implication_acknowledged",
        "need_expressed", "info_provided", "greeting", "gratitude"
    ],
    "go_back": ["go_back", "correct_info"]
}

# ═══════════════════════════════════════════════════════════════════════════════
# Python-level sharing — обычные dict'ы для переиспользования (НЕ runtime)
# ═══════════════════════════════════════════════════════════════════════════════
SPIN_COMMON_RULES = {
    "price_question": {
        "default": "deflect_and_continue",
        "conditions": [
            {"when": {"has_any": ["company_size", "users_count"]},
             "then": "answer_with_facts"},
            {"when": {"intent_streak": {"min": 3}},  # 3-й раз подряд
             "then": "answer_with_price_range"}
        ]
    },
    "pricing_details": {
        "default": "deflect_and_continue",
        "conditions": [
            {"when": {"has_any": ["company_size", "users_count"]},
             "then": "answer_with_facts"}
        ]
    },
    "comparison": "answer_and_continue",
}

POST_SPIN_RULES = {
    "price_question": "answer_with_facts",   # Без deflect
    "pricing_details": "answer_with_facts",
}

# ═══════════════════════════════════════════════════════════════════════════════
# SALES_CONFIG — только 2 уровня: state.rules → global_rules
# ═══════════════════════════════════════════════════════════════════════════════
SALES_CONFIG = {
    # Runtime fallback — применяются если нет правила в state.rules
    "global_rules": {
        "greeting": "acknowledge_and_continue",
        "gratitude": "acknowledge_and_continue",
        "small_talk": "small_talk_and_continue",
        "question_features": "answer_question",
        "question_integrations": "answer_question",
        "question_technical": "answer_question"
    },

    # Состояния — используют Python **unpacking (явно, без магии)
    "states": {
        "spin_situation": {
            "goal": "Понять ситуацию клиента",
            "spin_phase": "situation",
            "rules": {
                **SPIN_COMMON_RULES,           # Общие SPIN-правила
                "unclear": "probe_situation"   # Специфичное для этого состояния
            },
            "transitions": {
                "data_complete": "spin_problem",
                "situation_provided": "spin_problem"
            }
        },

        "spin_problem": {
            "goal": "Выявить проблемы клиента",
            "spin_phase": "problem",
            "rules": {
                **SPIN_COMMON_RULES,
                "unclear": "probe_problem"
            },
            "transitions": {
                "problem_revealed": "spin_implication"
            }
        },

        "close": {
            "goal": "Взять контакт или назначить демо",
            "rules": {
                **POST_SPIN_RULES,
                # Objection с условием на лимит
                "objection_price": {
                    "default": "handle_objection",
                    "conditions": [
                        {"when": {"objection_count": {"scope": "consecutive", "min": 3}},
                         "then": "objection_limit_reached"}
                    ]
                }
            },
            "transitions": {
                "contact_provided": "success",
                "rejection": "soft_close",
                # Условный переход
                "demo_request": {
                    "default": None,
                    "conditions": [
                        {"when": {"has_any": ["contact_info"]}, "then": "success"}
                    ]
                },
                # Переход в soft_close при лимите возражений
                "objection_price": {
                    "default": None,
                    "conditions": [
                        {"when": {"objection_count": {"scope": "consecutive", "min": 3}},
                         "then": "soft_close"}
                    ]
                }
            }
        }
        # ... остальные состояния
    }
}
Часть 7: ЛОГГИРОВАНИЕ ДЛЯ СИМУЛЯЦИЙ

7.1 Цель
При запуске 50 симуляций нужно точно понимать:
- Почему бот выбрал конкретный action
- Какие условия проверялись и какой был результат
- Какой контекст был на момент принятия решения
- Почему переход пошёл в одно состояние, а не в другое

7.2 Уровни логирования

┌─────────────────────────────────────────────────────────────────────────────┐
│                           УРОВНИ ЛОГОВ                                       │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│  DEBUG   — Детали каждой проверки условия (для отладки конкретной итерации) │
│  INFO    — Финальные решения: action, transition, matched condition         │
│  WARNING — Fallback на default (условия не сработали)                       │
│  EVENT   — Бизнес-события для аналитики (state_transition, rule_matched)    │
│  METRIC  — Числовые метрики (conditions_checked, evaluation_time_ms)        │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘

7.3 Что логируем

┌─────────────────────────────────────────────────────────────────────────────┐
│  1. ВХОД В RESOLVER                                                         │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│  logger.debug("Resolving action",                                           │
│      intent="price_question",                                               │
│      state="spin_situation",                                                │
│      rule_type="conditional",        # "simple" | "conditional"             │
│      conditions_count=2                                                     │
│  )                                                                          │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────────────────┐
│  2. КОНТЕКСТ ДЛЯ EVALUATOR                                                  │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│  logger.debug("Evaluation context",                                         │
│      collected_data={"company_size": 10, "pain_point": "теряем клиентов"},  │
│      state="spin_situation",                                                │
│      spin_phase="situation",                                                │
│      intent_streak={"price_question": 2},                                   │
│      last_intent="info_provided"                                            │
│  )                                                                          │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────────────────┐
│  3. ПРОВЕРКА КАЖДОГО УСЛОВИЯ                                                │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│  logger.debug("Condition evaluated",                                        │
│      condition_index=0,                                                     │
│      condition_type="has_any",                                              │
│      condition_params=["company_size", "users_count"],                      │
│      result=True,                      # True | False                       │
│      matched_field="company_size"      # какое поле сработало (для has_any) │
│  )                                                                          │
│                                                                             │
│  logger.debug("Condition evaluated",                                        │
│      condition_index=1,                                                     │
│      condition_type="intent_streak",                                        │
│      condition_params={"min": 3},                                           │
│      result=False,                                                          │
│      actual_streak=2                   # текущее значение (включая текущий) │
│  )                                                                          │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────────────────┐
│  4. ФИНАЛЬНОЕ РЕШЕНИЕ                                                       │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│  # Условие сработало                                                        │
│  logger.info("Action resolved",                                             │
│      intent="price_question",                                               │
│      action="answer_with_facts",                                            │
│      resolution="condition_matched",   # "condition_matched" | "default"    │
│      matched_condition_index=0,                                             │
│      matched_condition_type="has_any"                                       │
│  )                                                                          │
│                                                                             │
│  # Ни одно условие не сработало → default                                   │
│  logger.warning("Action resolved via default",                              │
│      intent="price_question",                                               │
│      action="deflect_and_continue",                                         │
│      resolution="default",                                                  │
│      conditions_checked=2,                                                  │
│      all_conditions_failed=True                                             │
│  )                                                                          │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────────────────┐
│  5. TRANSITION RESOLVER (аналогично)                                        │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│  logger.info("Transition resolved",                                         │
│      intent="demo_request",                                                 │
│      from_state="close",                                                    │
│      to_state="success",                                                    │
│      resolution="condition_matched",                                        │
│      matched_condition_type="has_any"                                       │
│  )                                                                          │
│                                                                             │
│  # Fallback на SPIN/data_complete                                           │
│  logger.info("Transition resolved",                                         │
│      intent="demo_request",                                                 │
│      from_state="spin_situation",                                           │
│      to_state="close",                                                      │
│      resolution="spin_fallback"  # условия не сработали → SPIN логика       │
│  )                                                                          │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘

7.4 Бизнес-события (EVENT)

# Для аналитики симуляций
logger.event("conditional_rule_triggered",
    intent="price_question",
    condition_type="has_any",
    action="answer_with_facts",
    simulation_id=42
)

logger.event("conditional_rule_default_used",
    intent="price_question",
    action="deflect_and_continue",
    reason="no_pricing_data",
    simulation_id=42
)

7.5 Метрики (METRIC)

# Производительность evaluator
logger.metric("condition_evaluation",
    conditions_checked=3,
    evaluation_time_ms=0.5,
    intent="price_question"
)

# Статистика по правилам
logger.metric("conditional_rules_stats",
    total_evaluations=150,
    conditions_matched=87,
    defaults_used=63,
    simulation_batch_id="batch_001"
)

7.6 Формат вывода для симуляций

Логи conditional rules встраиваются прямо в секцию диалогов.
Каждый ход показывает rule resolution для быстрой отладки.

┌─────────────────────────────────────────────────────────────────────────────┐
│  ФОРМАТ ДИАЛОГА С RULE RESOLUTION                                           │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│  [Ход 3]                                                                    │
│  Клиент: А сколько это стоит?                                               │
│  Бот: Чтобы назвать точную цену, уточните сколько человек в команде?        │
│    (state=spin_situation, intent=price_question, action=deflect_and_continue)│
│    [RULE] conditional → DEFAULT                                             │
│           has_any(company_size,users_count)=FAIL                            │
│           intent_streak(min:3)=FAIL (streak=1)                              │
│                                                                             │
│  [Ход 5]                                                                    │
│  Клиент: Ну так сколько стоит-то?                                           │
│  Бот: При команде из 10 человек стоимость составит 15000₸ в месяц.          │
│    (state=spin_situation, intent=price_question, action=answer_with_facts)  │
│    [RULE] conditional → MATCHED[0]                                          │
│           has_any(company_size,users_count)=PASS (company_size=10)          │
│                                                                             │
│  [Ход 7]                                                                    │
│  Клиент: Расскажите про интеграции                                          │
│  Бот: Мы интегрируемся с 1С, Kaspi, WhatsApp...                             │
│    (state=spin_situation, intent=question_integrations, action=answer_and_continue)
│    [RULE] simple → answer_and_continue                                      │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘

Формат строки [RULE]:
- "simple → action"           — простое правило (строка)
- "conditional → MATCHED[N]"  — сработало условие N
- "conditional → DEFAULT"     — ни одно условие не сработало
- "none → continue_current_goal" — правило не найдено

Детали условий показываются только для conditional rules.
Формат: condition_type(params)=PASS/FAIL (details)

7.6.1 Реализация: как rule info попадает в отчёт

1. RuleResult dataclass с поддержкой обратной совместимости:

@dataclass
class RuleResult:
    """Результат apply_rules() с опциональной информацией для отладки"""
    action: str
    next_state: str
    rule_info: Optional[Dict] = None

    def __iter__(self):
        """Поддержка tuple unpacking для обратной совместимости"""
        return iter((self.action, self.next_state))

# Использование — старый код работает:
action, state = sm.apply_rules(intent)  # tuple unpacking через __iter__

# Новый код с доступом к rule_info:
result = sm.apply_rules(intent)
action = result.action
state = result.next_state
info = result.rule_info  # для отчётов симуляций

# Структура rule_info:
{
    "rule_type": "conditional",      # "simple" | "conditional" | "none"
    "resolution": "condition_matched", # "condition_matched" | "default" | "simple"
    "matched_index": 0,              # индекс сработавшего условия (или None)
    "conditions_evaluated": [        # список проверенных условий
        {
            "type": "has_any",
            "params": ["company_size", "users_count"],
            "result": True,
            "details": {"matched_field": "company_size", "value": 10}
        },
        # ... остальные условия (если первое не сработало)
    ]
}

2. Runner записывает rule_info в turn_data:

# В runner.py _run_single()
turn_data = {
    "turn": turn + 1,
    "client": client_message,
    "bot": bot_result.get("response", ""),
    "state": bot_result.get("state", ""),
    "intent": bot_result.get("intent", ""),
    "action": bot_result.get("action", ""),
    "rule_info": bot_result.get("rule_info", {}),  # NEW
}

3. ReportGenerator форматирует rule_info:

# В report.py _section_full_dialogues()
def _format_rule_info(self, rule_info: Dict) -> List[str]:
    """Форматирует rule_info для отчёта"""
    lines = []

    rule_type = rule_info.get("rule_type", "none")
    resolution = rule_info.get("resolution", "")

    if rule_type == "simple":
        lines.append(f"    [RULE] simple → {rule_info.get('action', '?')}")

    elif rule_type == "conditional":
        if resolution == "condition_matched":
            idx = rule_info.get("matched_index", 0)
            lines.append(f"    [RULE] conditional → MATCHED[{idx}]")
        else:
            lines.append(f"    [RULE] conditional → DEFAULT")

        # Детали условий
        for cond in rule_info.get("conditions_evaluated", []):
            result = "PASS" if cond["result"] else "FAIL"
            params = ",".join(str(p) for p in cond["params"]) if isinstance(cond["params"], list) else str(cond["params"])
            detail = f" ({cond['details']})" if cond.get("details") else ""
            lines.append(f"           {cond['type']}({params})={result}{detail}")

    else:
        lines.append(f"    [RULE] none → continue_current_goal")

    return lines

7.7 Конфигурация уровня логирования

# settings.yaml
logging:
  level: INFO                    # Production: INFO, Debug: DEBUG
  conditional_rules:
    enabled: true                # Включить детальное логирование rules
    level: DEBUG                 # Уровень для conditional rules
    log_context: true            # Логировать полный контекст
    log_each_condition: true     # Логировать каждое условие

# Или через environment
CONDITIONAL_RULES_LOG_LEVEL=DEBUG

7.8 Класс RuleLogger (обёртка)

class RuleLogger:
    """
    Специализированный логгер для conditional rules.
    Упрощает логирование и добавляет контекст симуляции.
    """

    def __init__(self, simulation_id: Optional[int] = None):
        self.simulation_id = simulation_id
        self.enabled = settings.get_nested("logging.conditional_rules.enabled", True)
        self.log_context = settings.get_nested("logging.conditional_rules.log_context", True)
        self.log_each_condition = settings.get_nested("logging.conditional_rules.log_each_condition", True)

    def log_resolution_start(self, intent: str, rule_type: str, state: str):
        """Начало разрешения правила"""
        if not self.enabled:
            return
        logger.debug("Resolving rule",
            intent=intent,
            rule_type=rule_type,
            state=state,
            simulation_id=self.simulation_id
        )

    def log_context(self, context: Dict):
        """Логирование контекста evaluator"""
        if not self.enabled or not self.log_context:
            return
        logger.debug("Evaluation context",
            **context,
            simulation_id=self.simulation_id
        )

    def log_condition_result(
        self,
        index: int,
        condition_type: str,
        params: Any,
        result: bool,
        details: Optional[Dict] = None
    ):
        """Результат проверки одного условия"""
        if not self.enabled or not self.log_each_condition:
            return
        log_data = {
            "condition_index": index,
            "condition_type": condition_type,
            "params": params,
            "result": result,
            "simulation_id": self.simulation_id
        }
        if details:
            log_data.update(details)
        logger.debug("Condition evaluated", **log_data)

    def log_resolution_result(
        self,
        intent: str,
        result: str,
        resolution: str,  # "condition_matched" | "default" | "simple_rule"
        matched_index: Optional[int] = None,
        matched_type: Optional[str] = None
    ):
        """Финальный результат разрешения"""
        if not self.enabled:
            return

        log_fn = logger.info if resolution == "condition_matched" else logger.warning
        log_fn("Rule resolved",
            intent=intent,
            result=result,
            resolution=resolution,
            matched_condition_index=matched_index,
            matched_condition_type=matched_type,
            simulation_id=self.simulation_id
        )

7.9 Интеграция с SimulationRunner

# В runner.py
def _run_single(self, sim_id: int, persona_name: str) -> SimulationResult:
    ...
    # Создаём логгер для этой симуляции
    rule_logger = RuleLogger(simulation_id=sim_id)

    # Передаём в бота
    bot = SalesBot(self.bot_llm, rule_logger=rule_logger)
    ...

# В state_machine.py
class StateMachine:
    def __init__(self, rule_logger: Optional[RuleLogger] = None):
        ...
        self.rule_logger = rule_logger or RuleLogger()

7.10 Пример полного лога одного хода

[12:34:56] DEBUG - Resolving rule [intent=price_question, rule_type=conditional, state=spin_situation, simulation_id=10]
[12:34:56] DEBUG - Evaluation context [collected_data={company_size: 10}, state=spin_situation, spin_phase=situation, intent_streak={price_question: 2}, simulation_id=10]
[12:34:56] DEBUG - Condition evaluated [condition_index=0, condition_type=has_any, params=['company_size', 'users_count'], result=True, matched_field=company_size, simulation_id=10]
[12:34:56] INFO - Rule resolved [intent=price_question, result=answer_with_facts, resolution=condition_matched, matched_condition_index=0, matched_condition_type=has_any, simulation_id=10]

Часть 8: РЕЗЮМЕ

Что имеем сейчас:
- Rules — простые строки
- Категории интентов — hardcoded списки в коде (OBJECTION_INTENTS, POSITIVE_INTENTS...)
- Условная логика — hardcoded костыли в state_machine.py
- Логика размазана по файлам
- 8+ if'ов с разными приоритетами в apply_rules()
- Каждый новый случай = новый if
- last_intent дублируется в 4+ местах (SM, Bot, ContextEnvelope, ObjectionFlowManager)
- ObjectionFlowManager — отдельный класс для того, что можно вычислить из истории

Что хотим:
- Rules — декларативные объекты с условиями для action
- Transitions — декларативные условия для переходов (строгое разделение)
- INTENT_CATEGORIES — категории интентов в config
- Hooks — минимальный код для side effects (tracking через IntentTracker)
- Global_rules — fallback правила для всех состояний
- IntentTracker — ЕДИНСТВЕННЫЙ источник истории интентов (заменяет ObjectionFlowManager)
- Условная логика — в config.py
- Единый источник правды
- Каждый новый случай = строка в config

Как достигнем:
- INTENT_CATEGORIES — категории интентов в config (objection, positive, go_back)
- IntentTracker — единый источник истории интентов (см. секция 3.7):
  • Заменяет: SM.last_intent, Bot.last_intent, ObjectionFlowManager
  • Методы: streak_count(), objection_consecutive(), objection_total()
  • Автоматическая категоризация через INTENT_CATEGORIES
- Hooks (_apply_hooks) — просто вызывают intent_tracker.record()
- Condition Evaluator — изолированный модуль проверки условий
- Action/Transition Resolvers — универсальные интерпретаторы правил в SM
- EvaluatorContext — типизированный контекст с current_intent, prev_intent, IntentTracker
- RuleResult — возврат apply_rules() с __iter__ (обратная совместимость)
- Python-level sharing (**SPIN_COMMON_RULES) + global_rules — без runtime магии
- Миграция — постепенная, с обратной совместимостью
- Валидация — жёсткая в CI, мягкий fallback в runtime

Решённые проблемы:
┌─────────────────────────────────────────────────────────────────────────────┐
│  #  │ Проблема                         │ Решение                           │
├─────┼──────────────────────────────────┼───────────────────────────────────┤
│  1  │ Scope узкий (только 1 костыль)   │ Полный рефакторинг apply_rules()  │
│  2  │ Hardcoded OBJECTION_INTENTS      │ INTENT_CATEGORIES в config        │
│  3  │ Hardcoded POSITIVE_INTENTS       │ INTENT_CATEGORIES в config        │
│  4  │ Hardcoded QUESTION_INTENTS       │ global_rules в config             │
│  5  │ Нет отслеживания серий интентов  │ intent_streak + IntentTracker     │
│  6  │ Нет not условия                  │ not, missing_any, missing_all     │
│  7  │ Дублирование rules в SPIN        │ **SPIN_COMMON_RULES + global_rules│
│  8  │ Контекст не специфицирован       │ EvaluatorContext dataclass        │
│  9  │ 8+ if'ов в apply_rules()         │ 4 этапа: hooks → exit → action → state │
│ 10  │ if should_soft_close() hardcoded │ условие objection_count в config  │
│ 11  │ last_intent в 4+ местах          │ IntentTracker.last_intent (единый)│
│ 12  │ ObjectionFlowManager отдельно    │ IntentTracker.objection_*() методы│
│ 13  │ Рассинхрон Bot/SM.last_intent    │ Единый IntentTracker в SM         │
│ 14  │ Breaking change в apply_rules()  │ RuleResult с __iter__ (совместим) │
│ 15  │ current_intent нет в контексте   │ current_intent + prev_intent      │
└─────────────────────────────────────────────────────────────────────────────┘

Зачем это нужно:
- Сейчас: 1 явный костыль (price_question) + 5+ неявных (hardcoded списки)
- Через месяц: 10+ костылей
- Через полгода: 30+ костылей, код нечитаем
- С рефакторингом: 0 костылей навсегда, вся логика в config
