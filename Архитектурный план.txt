Dialogue Blackboard System â€” Ğ¤Ğ¸Ğ½Ğ°Ğ»ÑŒĞ½Ñ‹Ğ¹ ĞŸĞ»Ğ°Ğ½ v2.1
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

                    âš ï¸  Ğ¡Ğ¢Ğ ĞĞ¢Ğ•Ğ“Ğ˜Ğ¯ ĞœĞ˜Ğ“Ğ ĞĞ¦Ğ˜Ğ˜: ĞŸĞĞ›ĞĞĞ¯ Ğ—ĞĞœĞ•ĞĞ  âš ï¸

    âŒ ĞĞ•Ğ¢ shadow mode          â€” Ğ½Ğµ Ğ·Ğ°Ğ¿ÑƒÑĞºĞ°ĞµĞ¼ Ğ¾Ğ±Ğµ ÑĞ¸ÑÑ‚ĞµĞ¼Ñ‹ Ğ¿Ğ°Ñ€Ğ°Ğ»Ğ»ĞµĞ»ÑŒĞ½Ğ¾
    âŒ ĞĞ•Ğ¢ gradual rollout      â€” Ğ½Ğµ 10% â†’ 25% â†’ 50% â†’ 100%
    âŒ ĞĞ•Ğ¢ legacy ĞºĞ¾Ğ´Ğ°          â€” apply_rules() Ğ£Ğ”ĞĞ›Ğ¯Ğ•Ğ¢Ğ¡Ğ¯ Ğ¿Ğ¾Ğ»Ğ½Ğ¾ÑÑ‚ÑŒÑ
    âŒ ĞĞ•Ğ¢ feature flags        â€” Ğ´Ğ»Ñ Ğ¿ĞµÑ€ĞµĞºĞ»ÑÑ‡ĞµĞ½Ğ¸Ñ Ğ¼ĞµĞ¶Ğ´Ñƒ ÑĞ¸ÑÑ‚ĞµĞ¼Ğ°Ğ¼Ğ¸

    âœ… ĞŸĞĞ›ĞĞĞ¯ Ğ·Ğ°Ğ¼ĞµĞ½Ğ°            â€” Blackboard = ĞµĞ´Ğ¸Ğ½ÑÑ‚Ğ²ĞµĞ½Ğ½Ğ°Ñ ÑĞ¸ÑÑ‚ĞµĞ¼Ğ°
    âœ… Ğ§Ğ˜Ğ¡Ğ¢Ğ«Ğ™ codebase          â€” Ğ½Ğ¸ĞºĞ°ĞºĞ¾Ğ³Ğ¾ Ğ¼Ñ‘Ñ€Ñ‚Ğ²Ğ¾Ğ³Ğ¾ ĞºĞ¾Ğ´Ğ°
    âœ… 6-8 Ğ½ĞµĞ´ĞµĞ»ÑŒ               â€” Ğ±Ñ‹ÑÑ‚Ñ€ĞµĞµ Ñ‡ĞµĞ¼ gradual approach

    Rollback: git revert (Ñ‚Ğ¾Ğ»ÑŒĞºĞ¾ emergency)

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

Ğ§Ğ°ÑÑ‚ÑŒ 1: Ğ’Ğ²ĞµĞ´ĞµĞ½Ğ¸Ğµ Ğ¸ ĞĞ°ÑƒÑ‡Ğ½Ğ°Ñ Ğ‘Ğ°Ğ·Ğ°
1. Ğ ĞµĞ·ÑĞ¼Ğµ
ĞšĞ»ÑÑ‡ĞµĞ²Ğ°Ñ Ğ¸Ğ½Ğ½Ğ¾Ğ²Ğ°Ñ†Ğ¸Ñ: Action Selection Ğ¸ State Transition â€” ĞĞ•Ğ—ĞĞ’Ğ˜Ğ¡Ğ˜ĞœĞ«Ğ• Ğ¿Ñ€Ğ¾Ñ†ĞµÑÑÑ‹, ĞºĞ¾Ñ‚Ğ¾Ñ€Ñ‹Ğµ Ğ¾Ğ±ÑŠĞµĞ´Ğ¸Ğ½ÑÑÑ‚ÑÑ ConflictResolver Ñ Ğ¿Ğ¾Ğ´Ğ´ĞµÑ€Ğ¶ĞºĞ¾Ğ¹ combinable Ñ„Ğ»Ğ°Ğ³Ğ°.

Ğ ĞµÑˆĞ°ĞµÑ‚ ĞºĞ¾Ñ€Ğ½ĞµĞ²ÑƒÑ Ğ¿Ñ€Ğ¾Ğ±Ğ»ĞµĞ¼Ñƒ: price_question + data_complete Ñ‚ĞµĞ¿ĞµÑ€ÑŒ ĞĞ• ĞºĞ¾Ğ½ĞºÑƒÑ€Ğ¸Ñ€ÑƒÑÑ‚ â€” Ğ¾Ğ±Ğ° Ğ¿Ñ€Ğ¸Ğ¼ĞµĞ½ÑÑÑ‚ÑÑ Ğ¾Ğ´Ğ½Ğ¾Ğ²Ñ€ĞµĞ¼ĞµĞ½Ğ½Ğ¾ ĞºĞ¾Ğ³Ğ´Ğ° combinable=True.

ĞšĞ¾Ğ¼Ğ¿Ğ¾Ğ½ĞµĞ½Ñ‚Ñ‹:

DialogueBlackboard â€” Ñ†ĞµĞ½Ñ‚Ñ€Ğ°Ğ»Ğ¸Ğ·Ğ¾Ğ²Ğ°Ğ½Ğ½Ğ¾Ğµ ÑĞ¾ÑÑ‚Ğ¾ÑĞ½Ğ¸Ğµ Ñ 3 ÑĞ»Ğ¾ÑĞ¼Ğ¸ (Context/Proposal/Decision)
6 Knowledge Sources â€” Ğ½ĞµĞ·Ğ°Ğ²Ğ¸ÑĞ¸Ğ¼Ñ‹Ğµ Ğ¼Ğ¾Ğ´ÑƒĞ»Ğ¸ Ñ Ñ‡Ñ‘Ñ‚ĞºĞ¸Ğ¼ Ñ€Ğ°Ğ·Ğ´ĞµĞ»ĞµĞ½Ğ¸ĞµĞ¼ Ğ¾Ñ‚Ğ²ĞµÑ‚ÑÑ‚Ğ²ĞµĞ½Ğ½Ğ¾ÑÑ‚Ğ¸
ConflictResolver â€” Ğ¾Ğ±ÑŠĞµĞ´Ğ¸Ğ½ÑĞµÑ‚ proposals Ñ Ğ¿Ğ¾Ğ»Ğ½Ğ¾Ğ¹ Ğ¿Ğ¾Ğ´Ğ´ĞµÑ€Ğ¶ĞºĞ¾Ğ¹ combinable Ğ»Ğ¾Ğ³Ğ¸ĞºĞ¸
DialogueOrchestrator â€” ĞºĞ¾Ğ¾Ñ€Ğ´Ğ¸Ğ½Ğ°Ñ‚Ğ¾Ñ€ Ğ²ÑĞµĞ³Ğ¾ Ğ¿Ñ€Ğ¾Ñ†ĞµÑÑĞ°
DialogueEventBus â€” observability Ğ¸ Ğ°Ğ½Ğ°Ğ»Ğ¸Ñ‚Ğ¸ĞºĞ°
ProposalValidator â€” Ğ²Ğ°Ğ»Ğ¸Ğ´Ğ°Ñ†Ğ¸Ñ proposals Ğ¿ĞµÑ€ĞµĞ´ resolution
Migration: 6-8 Ğ½ĞµĞ´ĞµĞ»ÑŒ Ñ Ğ¿Ğ¾Ğ»Ğ½Ğ¾Ğ¹ Ğ·Ğ°Ğ¼ĞµĞ½Ğ¾Ğ¹ ÑÑ‚Ğ°Ñ€Ğ¾Ğ¹ ÑĞ¸ÑÑ‚ĞµĞ¼Ñ‹. ĞĞ¸ĞºĞ°ĞºĞ¾Ğ³Ğ¾ legacy ĞºĞ¾Ğ´Ğ° â€” StateMachine.apply_rules() ÑƒĞ´Ğ°Ğ»ÑĞµÑ‚ÑÑ Ğ¿Ğ¾Ğ»Ğ½Ğ¾ÑÑ‚ÑŒÑ.

Persona Limits: Ğ’ĞºĞ»ÑÑ‡ĞµĞ½Ñ‹ Ğ´Ğ¸Ğ½Ğ°Ğ¼Ğ¸Ñ‡ĞµÑĞºĞ¸Ğµ Ğ»Ğ¸Ğ¼Ğ¸Ñ‚Ñ‹ Ğ¸Ğ· YAML (aggressive: 5/8, busy: 2/4).

================================================================================
                    ğŸ”Œ Ğ¡ĞĞ’ĞœĞ•Ğ¡Ğ¢Ğ˜ĞœĞĞ¡Ğ¢Ğ¬ Ğ¡ Ğ¡Ğ£Ğ©Ğ•Ğ¡Ğ¢Ğ’Ğ£Ğ®Ğ©Ğ˜Ğœ ĞšĞĞ”ĞĞœ
================================================================================

Blackboard ÑĞ¸ÑÑ‚ĞµĞ¼Ğ° ÑĞ¿Ñ€Ğ¾ĞµĞºÑ‚Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ° Ğ´Ğ»Ñ Ğ‘Ğ•Ğ¡Ğ¨ĞĞ’ĞĞĞ™ Ğ¸Ğ½Ñ‚ĞµĞ³Ñ€Ğ°Ñ†Ğ¸Ğ¸ Ñ ÑÑƒÑ‰ĞµÑÑ‚Ğ²ÑƒÑÑ‰Ğ¸Ğ¼
bot.py, DialoguePolicy Ğ¸ Generator. ĞšĞ»ÑÑ‡ĞµĞ²Ñ‹Ğµ Ñ‚Ğ¾Ñ‡ĞºĞ¸ ÑĞ¾Ğ²Ğ¼ĞµÑÑ‚Ğ¸Ğ¼Ğ¾ÑÑ‚Ğ¸:

1. ResolvedDecision.to_sm_result()
   - ĞšĞ¾Ğ½Ğ²ĞµÑ€Ñ‚Ğ¸Ñ€ÑƒĞµÑ‚ Ñ€ĞµĞ·ÑƒĞ»ÑŒÑ‚Ğ°Ñ‚ Blackboard Ğ² Ñ„Ğ¾Ñ€Ğ¼Ğ°Ñ‚ Dict[str, Any]
   - Ğ’ĞºĞ»ÑÑ‡Ğ°ĞµÑ‚ Ğ’Ğ¡Ğ• Ğ¿Ğ¾Ğ»Ñ, ĞºĞ¾Ñ‚Ğ¾Ñ€Ñ‹Ğµ Ğ¾Ğ¶Ğ¸Ğ´Ğ°ĞµÑ‚ bot.py:
     â€¢ action, next_state, prev_state
     â€¢ goal, collected_data, missing_data, optional_data
     â€¢ is_final, spin_phase, prev_phase, circular_flow, objection_flow
     â€¢ trace (Ğ´Ğ»Ñ decision_trace.py), reason_codes, resolution_trace
   - DialoguePolicy Ğ¼Ğ¾Ğ¶ĞµÑ‚ Ğ¼Ğ¾Ğ´Ğ¸Ñ„Ğ¸Ñ†Ğ¸Ñ€Ğ¾Ğ²Ğ°Ñ‚ÑŒ ÑÑ‚Ğ¾Ñ‚ dict in-place
   - _objection_limit_final Ñ„Ğ»Ğ°Ğ³ ÑƒÑÑ‚Ğ°Ğ½Ğ°Ğ²Ğ»Ğ¸Ğ²Ğ°ĞµÑ‚ÑÑ Ñ‡ĞµÑ€ĞµĞ· propose_data_update()

2. ĞŸĞ¾Ğ±Ğ¾Ñ‡Ğ½Ñ‹Ğµ ÑÑ„Ñ„ĞµĞºÑ‚Ñ‹ (Side Effects)
   DialogueOrchestrator._apply_side_effects() Ğ²Ñ‹Ğ¿Ğ¾Ğ»Ğ½ÑĞµÑ‚:
   - IntentTracker.record() â€” Ñ Ğ»Ğ¾Ğ³Ğ¸ĞºĞ¾Ğ¹ Ğ¿Ñ€Ğ¾Ğ¿ÑƒÑĞºĞ° Ğ²Ğ¾Ğ·Ñ€Ğ°Ğ¶ĞµĞ½Ğ¸Ğ¹ Ğ¿Ñ€Ğ¸ Ğ»Ğ¸Ğ¼Ğ¸Ñ‚Ğµ
   - state_machine.state = next_state
   - state_machine.last_action = action
   - state_machine.current_phase = phase
   - on_enter flags Ğ¿Ñ€Ğ¸ ÑĞ¼ĞµĞ½Ğµ ÑĞ¾ÑÑ‚Ğ¾ÑĞ½Ğ¸Ñ
   - data_updates â†’ collected_data (Ğ²ĞºĞ»ÑÑ‡Ğ°Ñ _objection_limit_final)

3. Ğ¢Ğ¾Ñ‡ĞºĞ° Ğ¸Ğ½Ñ‚ĞµĞ³Ñ€Ğ°Ñ†Ğ¸Ğ¸ (bot.py)
   Ğ‘Ğ«Ğ›Ğ:  sm_result = self.state_machine.process(intent, extracted, context_envelope)
   Ğ¡Ğ¢ĞĞ›Ğ: decision = self._orchestrator.process_turn(intent, extracted, context_envelope)
          sm_result = decision.to_sm_result()

   Ğ’Ğ¡Ğ ĞĞ¡Ğ¢ĞĞ›Ğ¬ĞĞĞ• Ğ‘Ğ•Ğ— Ğ˜Ğ—ĞœĞ•ĞĞ•ĞĞ˜Ğ™ (DialoguePolicy, Generator, metrics).

4. Out of Scope (ĞĞ• Ğ²Ñ…Ğ¾Ğ´Ğ¸Ñ‚ Ğ² Blackboard)
   Ğ¡Ğ»ĞµĞ´ÑƒÑÑ‰Ğ¸Ğµ Ğ¼ĞµÑ‚Ğ¾Ğ´Ñ‹ StateMachine Ğ²Ñ‹Ğ·Ñ‹Ğ²Ğ°ÑÑ‚ÑÑ Ğ½Ğ°Ğ¿Ñ€ÑĞ¼ÑƒÑ Ğ¸Ğ· bot.py Ğ¸
   ĞĞ• Ğ·Ğ°Ğ¼ĞµĞ½ÑÑÑ‚ÑÑ Blackboard:
   - increment_turn() â€” Ğ´Ğ»Ñ disambiguation cooldown (ÑÑ‚Ñ€Ğ¾ĞºĞ° 637)
   - in_disambiguation / enter/exit/resolve_disambiguation() â€” ÑĞ¸ÑÑ‚ĞµĞ¼Ğ°
     ÑƒÑ‚Ğ¾Ñ‡Ğ½ĞµĞ½Ğ¸Ñ Ğ¾ÑÑ‚Ğ°Ñ‘Ñ‚ÑÑ Ğ¿Ğ¾Ğ»Ğ½Ğ¾ÑÑ‚ÑŒÑ Ğ² StateMachine
   - reset() â€” ÑĞ±Ñ€Ğ¾Ñ Ğ´Ğ»Ñ Ğ½Ğ¾Ğ²Ğ¾Ğ³Ğ¾ Ñ€Ğ°Ğ·Ğ³Ğ¾Ğ²Ğ¾Ñ€Ğ°
   - ĞŸÑ€ÑĞ¼Ğ°Ñ Ğ·Ğ°Ğ¿Ğ¸ÑÑŒ state/collected_data Ğ´Ğ¾/Ğ¿Ğ¾ÑĞ»Ğµ process_turn()

ĞŸĞ¾Ğ´Ñ€Ğ¾Ğ±Ğ½Ğ¾ÑÑ‚Ğ¸: ÑĞ¼. Ğ Ğ°Ğ·Ğ´ĞµĞ» 14 "Integration with SalesBot", ÑĞµĞºÑ†Ğ¸Ñ 14.5-14.7

================================================================================

2. ĞĞ°ÑƒÑ‡Ğ½Ğ°Ñ Ğ±Ğ°Ğ·Ğ°
2.1 Blackboard Architecture
Ğ˜ÑÑ‚Ğ¾Ñ‡Ğ½Ğ¸ĞºĞ¸:

Exploring Advanced LLM Multi-Agent Systems Based on Blackboard Architecture (arxiv 2507.01701)
Blackboard System - Wikipedia
Memory in LLM-based Multi-agent Systems (TechRxiv)
ĞŸÑ€Ğ¸Ğ½Ñ†Ğ¸Ğ¿Ñ‹:

Shared workspace (blackboard) Ğ¸Ñ‚ĞµÑ€Ğ°Ñ‚Ğ¸Ğ²Ğ½Ğ¾ Ğ¾Ğ±Ğ½Ğ¾Ğ²Ğ»ÑĞµÑ‚ÑÑ ÑĞ¿ĞµÑ†Ğ¸Ğ°Ğ»Ğ¸Ğ·Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ½Ñ‹Ğ¼Ğ¸ Knowledge Sources
Knowledge Sources Ğ½ĞµĞ·Ğ°Ğ²Ğ¸ÑĞ¸Ğ¼Ñ‹ Ğ¸ Ğ½Ğµ Ğ·Ğ½Ğ°ÑÑ‚ Ğ´Ñ€ÑƒĞ³ Ğ¾ Ğ´Ñ€ÑƒĞ³Ğµ
Control Component ĞºĞ¾Ğ¾Ñ€Ğ´Ğ¸Ğ½Ğ¸Ñ€ÑƒĞµÑ‚ Ğ¿Ğ¾Ñ€ÑĞ´Ğ¾Ğº Ğ²Ñ‹Ğ¿Ğ¾Ğ»Ğ½ĞµĞ½Ğ¸Ñ Ğ¸ Ñ€Ğ°Ğ·Ñ€ĞµÑˆĞ°ĞµÑ‚ ĞºĞ¾Ğ½Ñ„Ğ»Ğ¸ĞºÑ‚Ñ‹
2.2 State Machine Based Conversation Model
Ğ˜ÑÑ‚Ğ¾Ñ‡Ğ½Ğ¸Ğº: State Machine based Human-Bot Conversation Model (PMC7266438)

ĞšĞ»ÑÑ‡ĞµĞ²Ñ‹Ğµ findings:

Hierarchical State Machines Ğ¿Ğ¾ĞºĞ°Ğ·Ñ‹Ğ²Ğ°ÑÑ‚ 56.61% ÑƒĞ»ÑƒÑ‡ÑˆĞµĞ½Ğ¸Ğµ Ğ´Ğ»Ñ multi-turn Ğ´Ğ¸Ğ°Ğ»Ğ¾Ğ³Ğ¾Ğ²
ĞŸĞ¾Ğ´Ğ´ĞµÑ€Ğ¶ĞºĞ° multi-intent Ñ‡ĞµÑ€ĞµĞ· nested state machines
Ğ¯Ğ²Ğ½Ğ¾Ğµ Ñ€Ğ°Ğ·Ğ´ĞµĞ»ĞµĞ½Ğ¸Ğµ intent fulfillment Ğ¸ state transitions
2.3 Behavior Trees vs FSM
Ğ˜ÑÑ‚Ğ¾Ñ‡Ğ½Ğ¸Ğº: Comparison between Behavior Trees and Finite State Machines (arxiv 2405.16137)

ĞšĞ»ÑÑ‡ĞµĞ²Ñ‹Ğµ findings:

O(1) Ğ¼Ğ°ÑÑˆÑ‚Ğ°Ğ±Ğ¸Ñ€ÑƒĞµĞ¼Ğ¾ÑÑ‚ÑŒ BT vs O(n) FSM
BT Ğ¾Ğ±ĞµÑĞ¿ĞµÑ‡Ğ¸Ğ²Ğ°ÑÑ‚ Ğ¼Ğ¾Ğ´ÑƒĞ»ÑŒĞ½Ğ¾ÑÑ‚ÑŒ Ñ‡ĞµÑ€ĞµĞ· ĞºĞ¾Ğ¼Ğ¿Ğ¾Ğ·Ğ¸Ñ†Ğ¸Ñ
FSM ÑÑ‚Ñ€Ğ°Ğ´Ğ°ÑÑ‚ Ğ¾Ñ‚ "state explosion" Ğ¿Ñ€Ğ¸ Ñ€Ğ¾ÑÑ‚Ğµ ÑĞ»Ğ¾Ğ¶Ğ½Ğ¾ÑÑ‚Ğ¸
2.4 Task-Oriented Dialogue Pipeline
Ğ˜ÑÑ‚Ğ¾Ñ‡Ğ½Ğ¸ĞºĞ¸:

Unified Approach for Scalable Task-Oriented Dialogue System (IJACSA)
Enhancing Task-oriented Dialogue Systems (ACL 2023)
Pipeline: NLU â†’ DST â†’ Policy â†’ NLG

ĞœĞ°Ğ¿Ğ¿Ğ¸Ğ½Ğ³ Ğ½Ğ° Blackboard:

NLU = Existing Classifier (Ğ±ĞµĞ· Ğ¸Ğ·Ğ¼ĞµĞ½ĞµĞ½Ğ¸Ğ¹)
DST = Context Layer Ğ² DialogueBlackboard
Policy = Knowledge Sources + ConflictResolver
NLG = Existing Generator (Ğ±ĞµĞ· Ğ¸Ğ·Ğ¼ĞµĞ½ĞµĞ½Ğ¸Ğ¹)
2.5 Conflict Resolution in Multi-Agent Systems
Ğ˜ÑÑ‚Ğ¾Ñ‡Ğ½Ğ¸ĞºĞ¸:

Conflict Resolution in Multi-Agent Systems (IEEE Xplore)
Conflict Resolution Techniques (Loro Journals)
ĞŸÑ€Ğ¸Ğ¼ĞµĞ½ÑĞµĞ¼Ñ‹Ğµ Ñ‚ĞµÑ…Ğ½Ğ¸ĞºĞ¸:

Priority-based resolution (highest priority wins)
Hierarchical decision structures
Combinable vs blocking actions
2.6 Enterprise Chatbot Best Practices
Ğ˜ÑÑ‚Ğ¾Ñ‡Ğ½Ğ¸ĞºĞ¸:

Chatbot Best Practices 2025 (Classic Informatics)
Sales Chatbot Deployment (Avrion)
ĞšĞ»ÑÑ‡ĞµĞ²Ñ‹Ğµ Ğ¿Ñ€Ğ°ĞºÑ‚Ğ¸ĞºĞ¸:

Human escalation triggers
Persona-based customization
Comprehensive testing before deployment
3. ĞšĞ¾Ñ€Ğ½ĞµĞ²Ğ°Ñ Ğ¿Ñ€Ğ¾Ğ±Ğ»ĞµĞ¼Ğ°
3.1 Ğ¢ĞµĞºÑƒÑ‰ĞµĞµ Ğ¿Ğ¾Ğ²ĞµĞ´ĞµĞ½Ğ¸Ğµ (Ğ¡Ğ›ĞĞœĞĞĞ)

User: "Ğ£ Ğ½Ğ°Ñ 15 Ñ‡ĞµĞ»Ğ¾Ğ²ĞµĞº. Ğ¡ĞºĞ¾Ğ»ÑŒĞºĞ¾ ÑÑ‚Ğ¾Ğ¸Ñ‚?"

Ğ¢Ğ•ĞšĞ£Ğ©Ğ˜Ğ™ FLOW:
â”œâ”€ Classifier: intent = price_question
â”œâ”€ DataExtractor: company_size = 15 âœ“ (ÑĞ¾Ñ…Ñ€Ğ°Ğ½ÑĞµÑ‚ÑÑ Ğ² collected_data)
â”œâ”€ StateMachine.apply_rules():
â”‚   â”œâ”€ IntentTracker.record("price_question", "spin_situation")
â”‚   â”œâ”€ PRIORITY 1.9: price_question detected
â”‚   â”‚   â””â”€ return ("answer_with_pricing", "spin_situation") â† EARLY RETURN!
â”‚   â”‚
â”‚   â””â”€ PRIORITY 4: data_complete check
â”‚       â””â”€ ĞĞ˜ĞšĞĞ“Ğ”Ğ ĞĞ• Ğ”ĞĞ¡Ğ¢Ğ˜Ğ“ĞĞ•Ğ¢Ğ¡Ğ¯ (early return Ğ²Ñ‹ÑˆĞµ)
â”‚
â””â”€ Ğ ĞµĞ·ÑƒĞ»ÑŒÑ‚Ğ°Ñ‚: 
   â”œâ”€ Ğ‘Ğ¾Ñ‚ Ğ¾Ñ‚Ğ²ĞµÑ‡Ğ°ĞµÑ‚ Ğ½Ğ° Ğ²Ğ¾Ğ¿Ñ€Ğ¾Ñ Ğ¾ Ñ†ĞµĞ½Ğµ âœ“
   â”œâ”€ Ğ‘Ğ¾Ñ‚ ĞĞ¡Ğ¢ĞĞĞ¢Ğ¡Ğ¯ Ğ² spin_situation âœ—
   â””â”€ Ğ‘Ğ¾Ñ‚ Ğ¿Ñ€Ğ¾Ğ´Ğ¾Ğ»Ğ¶Ğ°ĞµÑ‚ ÑĞ¿Ñ€Ğ°ÑˆĞ¸Ğ²Ğ°Ñ‚ÑŒ situation questions âœ—
   
STATE LOOP: spin_situation â†’ spin_situation â†’ spin_situation â†’ ...
3.2 ĞĞ¾Ğ²Ğ¾Ğµ Ğ¿Ğ¾Ğ²ĞµĞ´ĞµĞ½Ğ¸Ğµ (Ğ˜Ğ¡ĞŸĞ ĞĞ’Ğ›Ğ•ĞĞ)

User: "Ğ£ Ğ½Ğ°Ñ 15 Ñ‡ĞµĞ»Ğ¾Ğ²ĞµĞº. Ğ¡ĞºĞ¾Ğ»ÑŒĞºĞ¾ ÑÑ‚Ğ¾Ğ¸Ñ‚?"

ĞĞĞ’Ğ«Ğ™ FLOW (Blackboard):
â”œâ”€ Classifier: intent = price_question
â”œâ”€ DataExtractor: company_size = 15 âœ“
â”œâ”€ DialogueOrchestrator.process_turn():
â”‚   â”œâ”€ blackboard.begin_turn(intent, extracted_data)
â”‚   â”‚
â”‚   â”œâ”€ Knowledge Sources (ĞĞ•Ğ—ĞĞ’Ğ˜Ğ¡Ğ˜ĞœĞ, ĞŸĞĞ ĞĞ›Ğ›Ğ•Ğ›Ğ¬ĞĞ):
â”‚   â”‚   â”œâ”€ PriceQuestionSource.contribute(bb)
â”‚   â”‚   â”‚   â””â”€ bb.propose_action("answer_with_pricing", combinable=True)
â”‚   â”‚   â”‚
â”‚   â”‚   â”œâ”€ DataCollectorSource.contribute(bb)
â”‚   â”‚   â”‚   â””â”€ bb.propose_transition("spin_problem") â† data_complete!
â”‚   â”‚   â”‚
â”‚   â”‚   â”œâ”€ ObjectionGuardSource.contribute(bb)
â”‚   â”‚   â”‚   â””â”€ (no proposals - not an objection)
â”‚   â”‚   â”‚
â”‚   â”‚   â”œâ”€ IntentProcessorSource.contribute(bb)
â”‚   â”‚   â”‚   â””â”€ (no proposals - price handled by dedicated source)
â”‚   â”‚   â”‚
â”‚   â”‚   â”œâ”€ TransitionResolverSource.contribute(bb)
â”‚   â”‚   â”‚   â””â”€ (no proposals - no explicit transition for price_question)
â”‚   â”‚   â”‚
â”‚   â”‚   â””â”€ EscalationSource.contribute(bb)
â”‚   â”‚       â””â”€ (no proposals - no escalation triggers)
â”‚   â”‚
â”‚   â”œâ”€ ProposalValidator.validate(bb.proposals)
â”‚   â”‚   â””â”€ All proposals valid âœ“
â”‚   â”‚
â”‚   â”œâ”€ ConflictResolver.resolve(bb.proposals)
â”‚   â”‚   â”œâ”€ Action winner: "answer_with_pricing" (combinable=True)
â”‚   â”‚   â”œâ”€ Transition winner: "spin_problem"
â”‚   â”‚   â””â”€ MERGE: action + transition (because combinable=True)
â”‚   â”‚
â”‚   â””â”€ blackboard.commit_decision()
â”‚       â”œâ”€ final_action = "answer_with_pricing"
â”‚       â”œâ”€ next_state = "spin_problem"
â”‚       â””â”€ reason_codes = ["price_question_priority", "data_complete"]
â”‚
â””â”€ Ğ ĞµĞ·ÑƒĞ»ÑŒÑ‚Ğ°Ñ‚:
   â”œâ”€ Ğ‘Ğ¾Ñ‚ Ğ¾Ñ‚Ğ²ĞµÑ‡Ğ°ĞµÑ‚ Ğ½Ğ° Ğ²Ğ¾Ğ¿Ñ€Ğ¾Ñ Ğ¾ Ñ†ĞµĞ½Ğµ âœ“
   â”œâ”€ Ğ‘Ğ¾Ñ‚ ĞŸĞ•Ğ Ğ•Ğ¥ĞĞ”Ğ˜Ğ¢ Ğ² spin_problem âœ“
   â””â”€ Ğ‘Ğ¾Ñ‚ Ğ½Ğ°Ñ‡Ğ¸Ğ½Ğ°ĞµÑ‚ problem phase âœ“
ĞŸÑ€Ğ¾Ğ´Ğ¾Ğ»Ğ¶Ğ°Ñ ÑĞ¾ Ğ²Ñ‚Ğ¾Ñ€Ğ¾Ğ¹ Ñ‡Ğ°ÑÑ‚ÑŒÑ â€” ĞÑ€Ñ…Ğ¸Ñ‚ĞµĞºÑ‚ÑƒÑ€Ğ°.

Ğ¿Ñ€Ğ¾Ğ´Ğ¾Ğ¶Ğ°Ğ¹
Ğ§Ğ°ÑÑ‚ÑŒ 2: ĞÑ€Ñ…Ğ¸Ñ‚ĞµĞºÑ‚ÑƒÑ€Ğ°
4. ĞĞ±Ñ‰Ğ°Ñ Ğ°Ñ€Ñ…Ğ¸Ñ‚ĞµĞºÑ‚ÑƒÑ€Ğ°
4.1 High-Level Architecture Diagram

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                              DialogueOrchestrator                                    â”‚
â”‚                                                                                      â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚ process_turn(intent, extracted_data, context_envelope):                      â”‚   â”‚
â”‚  â”‚   1. blackboard.begin_turn(intent, extracted_data, context_envelope)         â”‚   â”‚
â”‚  â”‚   2. for source in knowledge_sources:                                        â”‚   â”‚
â”‚  â”‚        if source.should_contribute(blackboard):                              â”‚   â”‚
â”‚  â”‚            source.contribute(blackboard)                                     â”‚   â”‚
â”‚  â”‚            event_bus.emit(SourceContributed(source, blackboard.proposals))   â”‚   â”‚
â”‚  â”‚   3. validation_errors = validator.validate(blackboard.proposals)            â”‚   â”‚
â”‚  â”‚   4. if validation_errors: handle_validation_errors(validation_errors)       â”‚   â”‚
â”‚  â”‚   5. decision = conflict_resolver.resolve(blackboard.proposals)              â”‚   â”‚
â”‚  â”‚   6. blackboard.commit_decision(decision)                                    â”‚   â”‚
â”‚  â”‚   7. event_bus.emit(DecisionCommitted(decision))                             â”‚   â”‚
â”‚  â”‚   8. return decision                                                         â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                          â”‚
                                          â”‚ coordinates
                                          â–¼
        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
        â”‚                                 â”‚                                 â”‚
        â–¼                                 â–¼                                 â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”           â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”           â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ PriceQuestion     â”‚           â”‚ DataCollector     â”‚           â”‚ ObjectionGuard    â”‚
â”‚ Source            â”‚           â”‚ Source            â”‚           â”‚ Source            â”‚
â”‚                   â”‚           â”‚                   â”‚           â”‚                   â”‚
â”‚ Responsibility:   â”‚           â”‚ Responsibility:   â”‚           â”‚ Responsibility:   â”‚
â”‚ Price-related     â”‚           â”‚ Data completeness â”‚           â”‚ Objection limits  â”‚
â”‚ questions only    â”‚           â”‚ checks ONLY       â”‚           â”‚ per persona       â”‚
â”‚                   â”‚           â”‚                   â”‚           â”‚                   â”‚
â”‚ Proposes:         â”‚           â”‚ Proposes:         â”‚           â”‚ Proposes:         â”‚
â”‚ - action (comb.)  â”‚           â”‚ - transition      â”‚           â”‚ - transition      â”‚
â”‚                   â”‚           â”‚   (data_complete) â”‚           â”‚ - action          â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜           â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜           â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
          â”‚                               â”‚                               â”‚
          â”‚                               â”‚                               â”‚
        â”Œâ”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”˜
        â”‚                                 â”‚                             â”‚
        â–¼                                 â–¼                             â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”           â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”           â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ IntentProcessor   â”‚           â”‚ TransitionResolverâ”‚           â”‚ Escalation        â”‚
â”‚ Source            â”‚           â”‚ Source            â”‚           â”‚ Source            â”‚
â”‚                   â”‚           â”‚                   â”‚           â”‚                   â”‚
â”‚ Responsibility:   â”‚           â”‚ Responsibility:   â”‚           â”‚ Responsibility:   â”‚
â”‚ General intentâ†’   â”‚           â”‚ Intent-based      â”‚           â”‚ Human handoff     â”‚
â”‚ action mapping    â”‚           â”‚ transitions ONLY  â”‚           â”‚ triggers          â”‚
â”‚ (from rules)      â”‚           â”‚ (explicit config) â”‚           â”‚                   â”‚
â”‚                   â”‚           â”‚                   â”‚           â”‚ Proposes:         â”‚
â”‚ Proposes:         â”‚           â”‚ Proposes:         â”‚           â”‚ - action          â”‚
â”‚ - action          â”‚           â”‚ - transition      â”‚           â”‚   (blocking)      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜           â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜           â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
          â”‚                               â”‚                               â”‚
          â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                          â”‚
                                          â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                              DialogueBlackboard                                      â”‚
â”‚                                                                                      â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”‚
â”‚  â”‚   Context Layer      â”‚  â”‚   Proposal Layer     â”‚  â”‚   Decision Layer       â”‚    â”‚
â”‚  â”‚   (READ-ONLY)        â”‚  â”‚   (WRITE by Sources) â”‚  â”‚   (WRITE by Resolver)  â”‚    â”‚
â”‚  â”‚                      â”‚  â”‚                      â”‚  â”‚                        â”‚    â”‚
â”‚  â”‚ â€¢ state              â”‚  â”‚ â€¢ action_proposals   â”‚  â”‚ â€¢ final_action         â”‚    â”‚
â”‚  â”‚ â€¢ collected_data     â”‚  â”‚ â€¢ transition_props   â”‚  â”‚ â€¢ next_state           â”‚    â”‚
â”‚  â”‚ â€¢ current_intent     â”‚  â”‚ â€¢ data_updates       â”‚  â”‚ â€¢ reason_codes         â”‚    â”‚
â”‚  â”‚ â€¢ intent_tracker     â”‚  â”‚ â€¢ metadata           â”‚  â”‚ â€¢ rejected_proposals   â”‚    â”‚
â”‚  â”‚ â€¢ context_envelope   â”‚  â”‚                      â”‚  â”‚ â€¢ resolution_trace     â”‚    â”‚
â”‚  â”‚ â€¢ turn_number        â”‚  â”‚                      â”‚  â”‚                        â”‚    â”‚
â”‚  â”‚ â€¢ persona            â”‚  â”‚                      â”‚  â”‚                        â”‚    â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â”‚
â”‚                                                                                      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                          â”‚
                                          â”‚ proposals
                                          â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                              ProposalValidator                                       â”‚
â”‚                                                                                      â”‚
â”‚  validate(proposals) â†’ List[ValidationError]:                                        â”‚
â”‚    â€¢ Check priority is valid enum value                                              â”‚
â”‚    â€¢ Check action/transition values exist in config                                  â”‚
â”‚    â€¢ Check combinable flag is boolean                                                â”‚
â”‚    â€¢ Check reason_code is documented                                                 â”‚
â”‚    â€¢ Return list of errors (empty if all valid)                                      â”‚
â”‚                                                                                      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                          â”‚
                                          â”‚ validated proposals
                                          â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                              ConflictResolver                                        â”‚
â”‚                                                                                      â”‚
â”‚  resolve(proposals, current_state) â†’ ResolvedDecision:                               â”‚
â”‚                                                                                      â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚ ALGORITHM:                                                                   â”‚   â”‚
â”‚  â”‚                                                                              â”‚   â”‚
â”‚  â”‚ 1. Separate proposals by type:                                               â”‚   â”‚
â”‚  â”‚    action_proposals = [p for p in proposals if p.type == ACTION]             â”‚   â”‚
â”‚  â”‚    transition_proposals = [p for p in proposals if p.type == TRANSITION]     â”‚   â”‚
â”‚  â”‚                                                                              â”‚   â”‚
â”‚  â”‚ 2. Sort each list by priority (CRITICAL > HIGH > NORMAL > LOW):              â”‚   â”‚
â”‚  â”‚    action_proposals.sort(key=lambda p: p.priority.value)                     â”‚   â”‚
â”‚  â”‚    transition_proposals.sort(key=lambda p: p.priority.value)                 â”‚   â”‚
â”‚  â”‚                                                                              â”‚   â”‚
â”‚  â”‚ 3. Select winning action:                                                    â”‚   â”‚
â”‚  â”‚    winning_action = action_proposals[0] if action_proposals else None        â”‚   â”‚
â”‚  â”‚                                                                              â”‚   â”‚
â”‚  â”‚ 4. CRITICAL: Check combinable flag:                                          â”‚   â”‚
â”‚  â”‚    if winning_action and not winning_action.combinable:                      â”‚   â”‚
â”‚  â”‚        # BLOCKING action - ignore all transitions                            â”‚   â”‚
â”‚  â”‚        return ResolvedDecision(                                              â”‚   â”‚
â”‚  â”‚            action=winning_action.value,                                      â”‚   â”‚
â”‚  â”‚            next_state=current_state,  # NO STATE CHANGE                      â”‚   â”‚
â”‚  â”‚            reason_codes=[winning_action.reason_code],                        â”‚   â”‚
â”‚  â”‚            rejected_proposals=transition_proposals + action_proposals[1:]    â”‚   â”‚
â”‚  â”‚        )                                                                     â”‚   â”‚
â”‚  â”‚                                                                              â”‚   â”‚
â”‚  â”‚ 5. If combinable=True or no action, merge action + transition:               â”‚   â”‚
â”‚  â”‚    winning_transition = transition_proposals[0] if transition_proposals      â”‚   â”‚
â”‚  â”‚                         else None                                            â”‚   â”‚
â”‚  â”‚    return ResolvedDecision(                                                  â”‚   â”‚
â”‚  â”‚        action=winning_action.value if winning_action else "continue",        â”‚   â”‚
â”‚  â”‚        next_state=winning_transition.value if winning_transition             â”‚   â”‚
â”‚  â”‚                   else current_state,                                        â”‚   â”‚
â”‚  â”‚        reason_codes=[...],                                                   â”‚   â”‚
â”‚  â”‚        rejected_proposals=[...]                                              â”‚   â”‚
â”‚  â”‚    )                                                                         â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”‚                                                                                      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                          â”‚
                                          â”‚ events
                                          â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                              DialogueEventBus                                        â”‚
â”‚                                                                                      â”‚
â”‚  Events emitted:                                                                     â”‚
â”‚  â€¢ TurnStarted(turn_number, intent, state)                                           â”‚
â”‚  â€¢ SourceContributed(source_name, proposals_count, proposals_summary)                â”‚
â”‚  â€¢ ProposalValidated(valid_count, error_count, errors)                               â”‚
â”‚  â€¢ ConflictResolved(winning_action, winning_transition, rejected_count)              â”‚
â”‚  â€¢ DecisionCommitted(action, next_state, reason_codes)                               â”‚
â”‚  â€¢ StateTransitioned(from_state, to_state, trigger_reason)                           â”‚
â”‚                                                                                      â”‚
â”‚  Subscribers:                                                                        â”‚
â”‚  â€¢ MetricsCollector - Ğ·Ğ°Ğ¿Ğ¸ÑÑ‹Ğ²Ğ°ĞµÑ‚ Ğ² metrics store                                     â”‚
â”‚  â€¢ DebugLogger - Ğ¿Ğ¾Ğ´Ñ€Ğ¾Ğ±Ğ½Ñ‹Ğµ Ğ»Ğ¾Ğ³Ğ¸ Ğ´Ğ»Ñ Ğ¾Ñ‚Ğ»Ğ°Ğ´ĞºĞ¸                                          â”‚
â”‚  â€¢ AnalyticsTracker - Ğ±Ğ¸Ğ·Ğ½ĞµÑ-Ğ°Ğ½Ğ°Ğ»Ğ¸Ñ‚Ğ¸ĞºĞ°                                               â”‚
â”‚  â€¢ AlertManager - Ğ°Ğ»ĞµÑ€Ñ‚Ñ‹ Ğ¿Ñ€Ğ¸ Ğ°Ğ½Ğ¾Ğ¼Ğ°Ğ»Ğ¸ÑÑ…                                               â”‚
â”‚                                                                                      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
4.2 Data Flow Sequence Diagram

User Message: "Ğ£ Ğ½Ğ°Ñ 15 Ñ‡ĞµĞ»Ğ¾Ğ²ĞµĞº. Ğ¡ĞºĞ¾Ğ»ÑŒĞºĞ¾ ÑÑ‚Ğ¾Ğ¸Ñ‚?"
    â”‚
    â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                        SalesBot.process()                        â”‚
â”‚  (existing code - unchanged)                                     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
    â”‚
    â”‚ 1. Classify intent
    â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                     UnifiedClassifier                            â”‚
â”‚  Returns: {intent: "price_question", extracted_data: {...}}      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
    â”‚
    â”‚ 2. Extract data
    â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                     DataExtractor                                â”‚
â”‚  Returns: {company_size: "15"}                                   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
    â”‚
    â”‚ 3. Build context envelope (existing Phase 5)
    â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                     ContextEnvelope                              â”‚
â”‚  Contains: state_machine, context_window, tone_info, etc.        â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
    â”‚
    â”‚ 4. Process through Blackboard (NEW - replaces apply_rules)
    â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                   DialogueOrchestrator                           â”‚
â”‚                                                                  â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚ STEP 1: Begin Turn                                         â”‚ â”‚
â”‚  â”‚ blackboard.begin_turn(                                     â”‚ â”‚
â”‚  â”‚     intent="price_question",                               â”‚ â”‚
â”‚  â”‚     extracted_data={company_size: "15"},                   â”‚ â”‚
â”‚  â”‚     context_envelope=envelope                              â”‚ â”‚
â”‚  â”‚ )                                                          â”‚ â”‚
â”‚  â”‚                                                            â”‚ â”‚
â”‚  â”‚ Blackboard Context Layer now contains:                     â”‚ â”‚
â”‚  â”‚ â€¢ state: "spin_situation"                                  â”‚ â”‚
â”‚  â”‚ â€¢ collected_data: {company_size: "15"}  â† UPDATED!         â”‚ â”‚
â”‚  â”‚ â€¢ current_intent: "price_question"                         â”‚ â”‚
â”‚  â”‚ â€¢ persona: "default"                                       â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”‚                              â”‚                                   â”‚
â”‚                              â–¼                                   â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚ STEP 2: Knowledge Sources Contribute                       â”‚ â”‚
â”‚  â”‚                                                            â”‚ â”‚
â”‚  â”‚ PriceQuestionSource.should_contribute(bb) â†’ True           â”‚ â”‚
â”‚  â”‚ PriceQuestionSource.contribute(bb):                        â”‚ â”‚
â”‚  â”‚   bb.propose_action(                                       â”‚ â”‚
â”‚  â”‚       action="answer_with_pricing",                        â”‚ â”‚
â”‚  â”‚       priority=Priority.HIGH,                              â”‚ â”‚
â”‚  â”‚       combinable=True,              â† KEY!                 â”‚ â”‚
â”‚  â”‚       reason_code="price_question_priority"                â”‚ â”‚
â”‚  â”‚   )                                                        â”‚ â”‚
â”‚  â”‚                                                            â”‚ â”‚
â”‚  â”‚ DataCollectorSource.should_contribute(bb) â†’ True           â”‚ â”‚
â”‚  â”‚ DataCollectorSource.contribute(bb):                        â”‚ â”‚
â”‚  â”‚   required = ["company_size"]                              â”‚ â”‚
â”‚  â”‚   collected = {company_size: "15"}                         â”‚ â”‚
â”‚  â”‚   missing = []  â† ALL DATA COLLECTED!                      â”‚ â”‚
â”‚  â”‚   bb.propose_transition(                                   â”‚ â”‚
â”‚  â”‚       next_state="spin_problem",                           â”‚ â”‚
â”‚  â”‚       priority=Priority.NORMAL,                            â”‚ â”‚
â”‚  â”‚       reason_code="data_complete"                          â”‚ â”‚
â”‚  â”‚   )                                                        â”‚ â”‚
â”‚  â”‚                                                            â”‚ â”‚
â”‚  â”‚ ObjectionGuardSource.should_contribute(bb) â†’ False         â”‚ â”‚
â”‚  â”‚   (intent not in objection category)                       â”‚ â”‚
â”‚  â”‚                                                            â”‚ â”‚
â”‚  â”‚ IntentProcessorSource.should_contribute(bb) â†’ False        â”‚ â”‚
â”‚  â”‚   (price_question handled by dedicated source)             â”‚ â”‚
â”‚  â”‚                                                            â”‚ â”‚
â”‚  â”‚ TransitionResolverSource.should_contribute(bb) â†’ False     â”‚ â”‚
â”‚  â”‚   (no explicit transition mapping for price_question)      â”‚ â”‚
â”‚  â”‚                                                            â”‚ â”‚
â”‚  â”‚ EscalationSource.should_contribute(bb) â†’ False             â”‚ â”‚
â”‚  â”‚   (no escalation triggers active)                          â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”‚                              â”‚                                   â”‚
â”‚                              â–¼                                   â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚ STEP 3: Validate Proposals                                 â”‚ â”‚
â”‚  â”‚                                                            â”‚ â”‚
â”‚  â”‚ Proposals in blackboard:                                   â”‚ â”‚
â”‚  â”‚ [                                                          â”‚ â”‚
â”‚  â”‚   Proposal(ACTION, "answer_with_pricing", HIGH, comb=True),â”‚ â”‚
â”‚  â”‚   Proposal(TRANSITION, "spin_problem", NORMAL)             â”‚ â”‚
â”‚  â”‚ ]                                                          â”‚ â”‚
â”‚  â”‚                                                            â”‚ â”‚
â”‚  â”‚ validator.validate(proposals) â†’ []  (no errors)            â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”‚                              â”‚                                   â”‚
â”‚                              â–¼                                   â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚ STEP 4: Resolve Conflicts                                  â”‚ â”‚
â”‚  â”‚                                                            â”‚ â”‚
â”‚  â”‚ conflict_resolver.resolve(proposals, "spin_situation"):    â”‚ â”‚
â”‚  â”‚                                                            â”‚ â”‚
â”‚  â”‚ 1. Separate by type:                                       â”‚ â”‚
â”‚  â”‚    actions = [Proposal(ACTION, "answer_with_pricing",...)] â”‚ â”‚
â”‚  â”‚    transitions = [Proposal(TRANSITION, "spin_problem",...)]â”‚ â”‚
â”‚  â”‚                                                            â”‚ â”‚
â”‚  â”‚ 2. Sort by priority:                                       â”‚ â”‚
â”‚  â”‚    actions[0] = "answer_with_pricing" (HIGH)               â”‚ â”‚
â”‚  â”‚    transitions[0] = "spin_problem" (NORMAL)                â”‚ â”‚
â”‚  â”‚                                                            â”‚ â”‚
â”‚  â”‚ 3. Check combinable:                                       â”‚ â”‚
â”‚  â”‚    actions[0].combinable = True â† ALLOWS MERGE!            â”‚ â”‚
â”‚  â”‚                                                            â”‚ â”‚
â”‚  â”‚ 4. Return merged decision:                                 â”‚ â”‚
â”‚  â”‚    ResolvedDecision(                                       â”‚ â”‚
â”‚  â”‚        action="answer_with_pricing",                       â”‚ â”‚
â”‚  â”‚        next_state="spin_problem",    â† TRANSITION APPLIED! â”‚ â”‚
â”‚  â”‚        reason_codes=["price_question_priority",            â”‚ â”‚
â”‚  â”‚                      "data_complete"],                     â”‚ â”‚
â”‚  â”‚        rejected_proposals=[]                               â”‚ â”‚
â”‚  â”‚    )                                                       â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”‚                              â”‚                                   â”‚
â”‚                              â–¼                                   â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚ STEP 5: Commit Decision                                    â”‚ â”‚
â”‚  â”‚                                                            â”‚ â”‚
â”‚  â”‚ blackboard.commit_decision(decision)                       â”‚ â”‚
â”‚  â”‚                                                            â”‚ â”‚
â”‚  â”‚ Decision Layer now contains:                               â”‚ â”‚
â”‚  â”‚ â€¢ final_action: "answer_with_pricing"                      â”‚ â”‚
â”‚  â”‚ â€¢ next_state: "spin_problem"                               â”‚ â”‚
â”‚  â”‚ â€¢ reason_codes: ["price_question_priority", "data_complete"]â”‚
â”‚  â”‚ â€¢ rejected_proposals: []                                   â”‚ â”‚
â”‚  â”‚ â€¢ resolution_trace: {...}                                  â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”‚                              â”‚                                   â”‚
â”‚                              â–¼                                   â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚ STEP 6: Emit Events                                        â”‚ â”‚
â”‚  â”‚                                                            â”‚ â”‚
â”‚  â”‚ event_bus.emit(DecisionCommitted(                          â”‚ â”‚
â”‚  â”‚     action="answer_with_pricing",                          â”‚ â”‚
â”‚  â”‚     next_state="spin_problem",                             â”‚ â”‚
â”‚  â”‚     reason_codes=[...]                                     â”‚ â”‚
â”‚  â”‚ ))                                                         â”‚ â”‚
â”‚  â”‚                                                            â”‚ â”‚
â”‚  â”‚ event_bus.emit(StateTransitioned(                          â”‚ â”‚
â”‚  â”‚     from_state="spin_situation",                           â”‚ â”‚
â”‚  â”‚     to_state="spin_problem",                               â”‚ â”‚
â”‚  â”‚     trigger_reason="data_complete"                         â”‚ â”‚
â”‚  â”‚ ))                                                         â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
    â”‚
    â”‚ 5. Return to SalesBot
    â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                      SalesBot.process()                          â”‚
â”‚                                                                  â”‚
â”‚  action = "answer_with_pricing"                                  â”‚
â”‚  next_state = "spin_problem"                                     â”‚
â”‚                                                                  â”‚
â”‚  # Update state machine                                          â”‚
â”‚  state_machine.state = "spin_problem"                            â”‚
â”‚                                                                  â”‚
â”‚  # Generate response                                             â”‚
â”‚  response = generator.generate(action, context)                  â”‚
â”‚                                                                  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
    â”‚
    â–¼
Bot Response: "Ğ¡Ñ‚Ğ¾Ğ¸Ğ¼Ğ¾ÑÑ‚ÑŒ Ğ·Ğ°Ğ²Ğ¸ÑĞ¸Ñ‚ Ğ¾Ñ‚ Ñ€Ğ°Ğ·Ğ¼ĞµÑ€Ğ° ĞºĞ¾Ğ¼Ğ°Ğ½Ğ´Ñ‹. Ğ”Ğ»Ñ 15 Ñ‡ĞµĞ»Ğ¾Ğ²ĞµĞº..."
Next State: spin_problem (CORRECTLY TRANSITIONED!)
ĞŸÑ€Ğ¾Ğ´Ğ¾Ğ»Ğ¶Ğ°Ñ Ñ Ñ‚Ñ€ĞµÑ‚ÑŒĞµĞ¹ Ñ‡Ğ°ÑÑ‚ÑŒÑ â€” Ğ”ĞµÑ‚Ğ°Ğ»ÑŒĞ½Ğ°Ñ ÑĞ¿ĞµÑ†Ğ¸Ñ„Ğ¸ĞºĞ°Ñ†Ğ¸Ñ ĞºĞ¾Ğ¼Ğ¿Ğ¾Ğ½ĞµĞ½Ñ‚Ğ¾Ğ².

Ğ¿Ñ€Ğ¾Ğ´Ğ¾Ğ»Ğ¶Ğ°Ğ¹
Ğ§Ğ°ÑÑ‚ÑŒ 3: Ğ”ĞµÑ‚Ğ°Ğ»ÑŒĞ½Ğ°Ñ ÑĞ¿ĞµÑ†Ğ¸Ñ„Ğ¸ĞºĞ°Ñ†Ğ¸Ñ ĞºĞ¾Ğ¼Ğ¿Ğ¾Ğ½ĞµĞ½Ñ‚Ğ¾Ğ²
5. Core Data Structures
5.1 Priority Enum

# src/blackboard/enums.py

from enum import IntEnum

class Priority(IntEnum):
    """
    Priority levels for proposals.
    Lower numeric value = higher priority.
    
    Usage:
        CRITICAL - Ğ±Ğ»Ğ¾ĞºĞ¸Ñ€ÑƒÑÑ‰Ğ¸Ğµ Ğ´ĞµĞ¹ÑÑ‚Ğ²Ğ¸Ñ (rejection, escalation)
        HIGH - Ğ²Ğ°Ğ¶Ğ½Ñ‹Ğµ Ğ´ĞµĞ¹ÑÑ‚Ğ²Ğ¸Ñ (price questions, objection handling)
        NORMAL - ÑÑ‚Ğ°Ğ½Ğ´Ğ°Ñ€Ñ‚Ğ½Ñ‹Ğµ Ğ´ĞµĞ¹ÑÑ‚Ğ²Ğ¸Ñ (intent processing, data collection)
        LOW - fallback Ğ´ĞµĞ¹ÑÑ‚Ğ²Ğ¸Ñ (continue, default transitions)
    """
    CRITICAL = 0  # Highest priority - blocks everything
    HIGH = 1      # High priority - important actions
    NORMAL = 2    # Normal priority - standard processing
    LOW = 3       # Low priority - fallbacks
    
    def __lt__(self, other):
        if isinstance(other, Priority):
            return self.value < other.value
        return NotImplemented
5.1.1 Protocols (Hexagonal Architecture Ports)

# src/blackboard/protocols.py

"""
Protocols defining the contracts (ports) for Blackboard architecture.
Following Hexagonal Architecture pattern from DESIGN_PRINCIPLES.md.

These protocols enable:
- Static type checking with mypy
- Dependency Inversion (depend on abstractions, not concretions)
- Easy mocking in tests
- Clear boundaries between components
"""

from typing import Protocol, Dict, Any, Optional, List, runtime_checkable
from dataclasses import dataclass


@runtime_checkable
class IStateMachine(Protocol):
    """
    Input Port: Contract for state machine implementations.

    Allows DialogueBlackboard to work with any state machine
    that implements this protocol.

    Ğ’ĞĞ–ĞĞ: StateMachine Ğ¾ÑÑ‚Ğ°Ñ‘Ñ‚ÑÑ storage layer. Blackboard Ğ·Ğ°Ğ¼ĞµĞ½ÑĞµÑ‚ Ğ¢ĞĞ›Ğ¬ĞšĞ
    Ğ¼ĞµÑ‚Ğ¾Ğ´ process(). Ğ’ÑĞµ Ğ¾ÑÑ‚Ğ°Ğ»ÑŒĞ½Ñ‹Ğµ Ğ¼ĞµÑ‚Ğ¾Ğ´Ñ‹ (disambiguation, increment_turn)
    Ğ¾ÑÑ‚Ğ°ÑÑ‚ÑÑ Ğ² StateMachine Ğ¸ Ğ²Ñ‹Ğ·Ñ‹Ğ²Ğ°ÑÑ‚ÑÑ Ğ½Ğ°Ğ¿Ñ€ÑĞ¼ÑƒÑ Ğ¸Ğ· bot.py.

    ĞœĞµÑ‚Ğ¾Ğ´Ñ‹ ĞºĞ¾Ñ‚Ğ¾Ñ€Ñ‹Ğµ Blackboard Ğ˜Ğ¡ĞŸĞĞ›Ğ¬Ğ—Ğ£Ğ•Ğ¢ (Ñ‡ĞµÑ€ĞµĞ· protocol):
    - state (read/write)
    - collected_data (read)
    - update_data() (write)
    - current_phase (read/write)
    - last_action (write)
    - is_final()

    ĞœĞµÑ‚Ğ¾Ğ´Ñ‹ ĞºĞ¾Ñ‚Ğ¾Ñ€Ñ‹Ğµ bot.py Ğ²Ñ‹Ğ·Ñ‹Ğ²Ğ°ĞµÑ‚ ĞĞĞŸĞ Ğ¯ĞœĞ£Ğ® (out of scope Ğ´Ğ»Ñ Blackboard):
    - increment_turn() â€” Ğ´Ğ»Ñ disambiguation cooldown
    - enter_disambiguation() / exit_disambiguation() / resolve_disambiguation()
    - in_disambiguation / disambiguation_context / turns_since_last_disambiguation
    - reset() â€” Ğ´Ğ»Ñ Ğ½Ğ¾Ğ²Ğ¾Ğ³Ğ¾ Ñ€Ğ°Ğ·Ğ³Ğ¾Ğ²Ğ¾Ñ€Ğ°
    """

    @property
    def state(self) -> str:
        """Get current dialogue state."""
        ...

    @state.setter
    def state(self, value: str) -> None:
        """Set current dialogue state."""
        ...

    @property
    def collected_data(self) -> Dict[str, Any]:
        """Get collected data dictionary."""
        ...

    @property
    def current_phase(self) -> Optional[str]:
        """Get current dialogue phase (e.g., SPIN phase)."""
        ...

    @current_phase.setter
    def current_phase(self, value: Optional[str]) -> None:
        """Set current dialogue phase."""
        ...

    @property
    def last_action(self) -> Optional[str]:
        """Get last action taken."""
        ...

    @last_action.setter
    def last_action(self, value: Optional[str]) -> None:
        """Set last action taken."""
        ...

    def update_data(self, data: Dict[str, Any]) -> None:
        """
        Update collected data with new values.

        Called by _apply_side_effects() to persist data_updates
        from ResolvedDecision.
        """
        ...

    def is_final(self) -> bool:
        """Check if current state is final."""
        ...


@runtime_checkable
class IIntentTracker(Protocol):
    """
    Input Port: Contract for intent tracking.
    """

    @property
    def turn_number(self) -> int:
        """Get current turn number."""
        ...

    @property
    def prev_intent(self) -> Optional[str]:
        """Get previous intent."""
        ...

    def record(self, intent: str, state: str) -> None:
        """Record an intent."""
        ...

    def objection_consecutive(self) -> int:
        """Get consecutive objection count."""
        ...

    def objection_total(self) -> int:
        """Get total objection count."""
        ...

    def total_count(self, intent: str) -> int:
        """Get total count for specific intent."""
        ...

    def category_total(self, category: str) -> int:
        """Get total count for intent category."""
        ...


@runtime_checkable
class IFlowConfig(Protocol):
    """
    Input Port: Contract for flow configuration.
    """

    @property
    def states(self) -> Dict[str, Dict[str, Any]]:
        """Get states configuration."""
        ...

    def to_dict(self) -> Dict[str, Any]:
        """Convert to dictionary."""
        ...


@runtime_checkable
class IContextEnvelope(Protocol):
    """
    Input Port: Contract for context envelope (Phase 5).
    """

    def to_dict(self) -> Dict[str, Any]:
        """Convert to dictionary."""
        ...


@runtime_checkable
class ITenantConfig(Protocol):
    """
    Input Port: Contract for tenant configuration.

    Supports multi-tenancy as described in DESIGN_PRINCIPLES.md Section 6.
    """

    @property
    def tenant_id(self) -> str:
        """Unique tenant identifier."""
        ...

    @property
    def bot_name(self) -> str:
        """Tenant's bot name."""
        ...

    @property
    def tone(self) -> str:
        """Tenant's preferred tone (professional, friendly, formal)."""
        ...

    @property
    def features(self) -> Dict[str, bool]:
        """Tenant-specific feature flags."""
        ...

    @property
    def persona_limits_override(self) -> Optional[Dict[str, Dict[str, int]]]:
        """Tenant-specific persona limits override."""
        ...


@dataclass
class TenantConfig:
    """
    Default implementation of ITenantConfig.

    Can be loaded from YAML or database per tenant.
    """
    tenant_id: str
    bot_name: str = "Assistant"
    tone: str = "professional"
    features: Dict[str, bool] = None
    persona_limits_override: Optional[Dict[str, Dict[str, int]]] = None

    def __post_init__(self):
        if self.features is None:
            self.features = {}


# Default tenant for single-tenant deployments
DEFAULT_TENANT = TenantConfig(tenant_id="default")

5.2 ProposalType Enum

# src/blackboard/enums.py

from enum import Enum, auto

class ProposalType(Enum):
    """
    Types of proposals that Knowledge Sources can make.
    
    ACTION - Ğ¿Ñ€ĞµĞ´Ğ»Ğ°Ğ³Ğ°ĞµÑ‚ Ğ²Ñ‹Ğ¿Ğ¾Ğ»Ğ½Ğ¸Ñ‚ÑŒ Ğ´ĞµĞ¹ÑÑ‚Ğ²Ğ¸Ğµ (generate response, handle objection)
    TRANSITION - Ğ¿Ñ€ĞµĞ´Ğ»Ğ°Ğ³Ğ°ĞµÑ‚ Ğ¿ĞµÑ€ĞµĞ¹Ñ‚Ğ¸ Ğ² Ğ´Ñ€ÑƒĞ³Ğ¾Ğµ ÑĞ¾ÑÑ‚Ğ¾ÑĞ½Ğ¸Ğµ
    DATA_UPDATE - Ğ¿Ñ€ĞµĞ´Ğ»Ğ°Ğ³Ğ°ĞµÑ‚ Ğ¾Ğ±Ğ½Ğ¾Ğ²Ğ¸Ñ‚ÑŒ collected_data
    FLAG_SET - Ğ¿Ñ€ĞµĞ´Ğ»Ğ°Ğ³Ğ°ĞµÑ‚ ÑƒÑÑ‚Ğ°Ğ½Ğ¾Ğ²Ğ¸Ñ‚ÑŒ Ñ„Ğ»Ğ°Ğ³ (for on_enter actions)
    """
    ACTION = auto()
    TRANSITION = auto()
    DATA_UPDATE = auto()
    FLAG_SET = auto()
5.3 Proposal Dataclass

# src/blackboard/models.py

from dataclasses import dataclass, field
from typing import Any, Optional, List
from datetime import datetime
from .enums import Priority, ProposalType

@dataclass
class Proposal:
    """
    A proposal made by a Knowledge Source.
    
    Attributes:
        type: Type of proposal (ACTION, TRANSITION, DATA_UPDATE, FLAG_SET)
        value: The proposed value (action name, state name, data dict, flag dict)
        priority: Priority level for conflict resolution
        source_name: Name of the Knowledge Source that made this proposal
        reason_code: Documented reason code for auditability
        combinable: Whether this action can coexist with transitions
                    Only applicable for ACTION type.
                    True = action can be merged with transitions
                    False = action blocks all transitions (e.g., rejection)
        metadata: Additional context about the proposal
        created_at: Timestamp when proposal was created
    """
    type: ProposalType
    value: Any
    priority: Priority
    source_name: str
    reason_code: str
    combinable: bool = True  # Default: actions can coexist with transitions
    metadata: dict = field(default_factory=dict)
    created_at: datetime = field(default_factory=datetime.now)
    
    def validate(self) -> List[str]:
        """
        Validate the proposal.
        
        Returns:
            List of validation error messages (empty if valid)
        """
        errors = []
        
        # Check priority is valid
        if not isinstance(self.priority, Priority):
            errors.append(f"Invalid priority: {self.priority}. Must be Priority enum.")
        
        # Check type is valid
        if not isinstance(self.type, ProposalType):
            errors.append(f"Invalid type: {self.type}. Must be ProposalType enum.")
        
        # Check value is not None
        if self.value is None:
            errors.append("Proposal value cannot be None.")
        
        # Check reason_code is not empty
        if not self.reason_code or not self.reason_code.strip():
            errors.append("Proposal must have a non-empty reason_code.")
        
        # Check source_name is not empty
        if not self.source_name or not self.source_name.strip():
            errors.append("Proposal must have a non-empty source_name.")
        
        # Type-specific validation
        if self.type == ProposalType.ACTION:
            if not isinstance(self.value, str):
                errors.append(f"ACTION value must be string, got {type(self.value)}")
        
        elif self.type == ProposalType.TRANSITION:
            if not isinstance(self.value, str):
                errors.append(f"TRANSITION value must be string, got {type(self.value)}")
            # combinable is not applicable for transitions
            if not self.combinable:
                errors.append("TRANSITION proposals cannot have combinable=False")
        
        elif self.type == ProposalType.DATA_UPDATE:
            if not isinstance(self.value, dict):
                errors.append(f"DATA_UPDATE value must be dict, got {type(self.value)}")
        
        elif self.type == ProposalType.FLAG_SET:
            if not isinstance(self.value, dict):
                errors.append(f"FLAG_SET value must be dict, got {type(self.value)}")
        
        return errors
    
    def __repr__(self):
        comb_str = f", combinable={self.combinable}" if self.type == ProposalType.ACTION else ""
        return (f"Proposal({self.type.name}, '{self.value}', {self.priority.name}, "
                f"source='{self.source_name}', reason='{self.reason_code}'{comb_str})")
5.4 ResolvedDecision Dataclass

# src/blackboard/models.py

from dataclasses import dataclass, field
from typing import List, Optional, Dict, Any, TYPE_CHECKING

if TYPE_CHECKING:
    from src.state_machine import StateMachine

@dataclass
class ResolvedDecision:
    """
    The final decision after conflict resolution.

    Ğ’ĞĞ–ĞĞ: Ğ­Ñ‚Ğ¾Ñ‚ ĞºĞ»Ğ°ÑÑ Ğ´Ğ¾Ğ»Ğ¶ĞµĞ½ Ğ¾Ğ±ĞµÑĞ¿ĞµÑ‡Ğ¸Ğ²Ğ°Ñ‚ÑŒ Ğ¿Ğ¾Ğ»Ğ½ÑƒÑ ÑĞ¾Ğ²Ğ¼ĞµÑÑ‚Ğ¸Ğ¼Ğ¾ÑÑ‚ÑŒ Ñ ÑÑƒÑ‰ĞµÑÑ‚Ğ²ÑƒÑÑ‰Ğ¸Ğ¼
    Ğ¸Ğ½Ñ‚ĞµÑ€Ñ„ĞµĞ¹ÑĞ¾Ğ¼ state_machine.process() Ğ´Ğ»Ñ Ğ±ĞµÑÑˆĞ¾Ğ²Ğ½Ğ¾Ğ¹ Ğ¸Ğ½Ñ‚ĞµĞ³Ñ€Ğ°Ñ†Ğ¸Ğ¸ Ñ bot.py.

    Attributes:
        action: The action to execute (e.g., "answer_with_pricing")
        next_state: The state to transition to (or current state if no transition)
        reason_codes: List of reason codes that contributed to this decision
        rejected_proposals: Proposals that were not selected (for debugging)
        resolution_trace: Detailed trace of the resolution process
        data_updates: Data fields to update in collected_data
        flags_to_set: Flags to set after transition

        # === COMPATIBILITY FIELDS (Ğ´Ğ»Ñ ÑĞ¾Ğ²Ğ¼ĞµÑÑ‚Ğ¸Ğ¼Ğ¾ÑÑ‚Ğ¸ Ñ bot.py) ===
        prev_state: State before this decision (needed for metrics, state change detection)
        goal: Goal from state configuration (needed for generator context)
        collected_data: Full collected_data dict AFTER applying data_updates
        missing_data: List of missing required data fields
        optional_data: List of missing optional data fields
        is_final: Whether next_state is a final state
        spin_phase: Current phase (from state config)
        circular_flow: CircularFlowManager stats
        objection_flow: Objection tracking stats
    """
    # === CORE FIELDS ===
    action: str
    next_state: str
    reason_codes: List[str] = field(default_factory=list)
    rejected_proposals: List['Proposal'] = field(default_factory=list)
    resolution_trace: Dict[str, Any] = field(default_factory=dict)
    data_updates: Dict[str, Any] = field(default_factory=dict)
    flags_to_set: Dict[str, Any] = field(default_factory=dict)

    # === COMPATIBILITY FIELDS (Ğ·Ğ°Ğ¿Ğ¾Ğ»Ğ½ÑÑÑ‚ÑÑ Orchestrator'Ğ¾Ğ¼) ===
    prev_state: str = ""
    goal: str = ""
    collected_data: Dict[str, Any] = field(default_factory=dict)
    missing_data: List[str] = field(default_factory=list)
    optional_data: List[str] = field(default_factory=list)
    is_final: bool = False
    spin_phase: Optional[str] = None
    prev_phase: Optional[str] = None  # Phase before transition (for decision_trace)
    circular_flow: Dict[str, Any] = field(default_factory=dict)
    objection_flow: Dict[str, Any] = field(default_factory=dict)

    def to_dict(self) -> Dict[str, Any]:
        """Convert to dictionary for serialization/logging."""
        return {
            "action": self.action,
            "next_state": self.next_state,
            "reason_codes": self.reason_codes,
            "rejected_proposals_count": len(self.rejected_proposals),
            "rejected_proposals": [str(p) for p in self.rejected_proposals],
            "resolution_trace": self.resolution_trace,
            "data_updates": self.data_updates,
            "flags_to_set": self.flags_to_set,
            # Compatibility fields
            "prev_state": self.prev_state,
            "goal": self.goal,
            "is_final": self.is_final,
            "spin_phase": self.spin_phase,
        }

    def to_sm_result(self) -> Dict[str, Any]:
        """
        Convert to legacy sm_result format for full compatibility with bot.py.

        ĞšĞ Ğ˜Ğ¢Ğ˜Ğ§Ğ•Ğ¡ĞšĞ˜ Ğ’ĞĞ–ĞĞ: bot.py Ğ¾Ğ¶Ğ¸Ğ´Ğ°ĞµÑ‚ Dict Ñ Ğ¾Ğ¿Ñ€ĞµĞ´ĞµĞ»Ñ‘Ğ½Ğ½Ñ‹Ğ¼Ğ¸ Ğ¿Ğ¾Ğ»ÑĞ¼Ğ¸.
        DialoguePolicy Ğ¼Ğ¾Ğ´Ğ¸Ñ„Ğ¸Ñ†Ğ¸Ñ€ÑƒĞµÑ‚ ÑÑ‚Ğ¾Ñ‚ dict in-place.
        Generator Ğ¸ÑĞ¿Ğ¾Ğ»ÑŒĞ·ÑƒĞµÑ‚ goal, collected_data, missing_data, spin_phase.

        Returns:
            Dict Ğ² Ñ„Ğ¾Ñ€Ğ¼Ğ°Ñ‚Ğµ, Ğ¸Ğ´ĞµĞ½Ñ‚Ğ¸Ñ‡Ğ½Ğ¾Ğ¼ state_machine.process() output
        """
        result = {
            # Core fields (from Blackboard)
            "action": self.action,
            "next_state": self.next_state,

            # Compatibility fields (Ğ·Ğ°Ğ¿Ğ¾Ğ»Ğ½ĞµĞ½Ñ‹ Orchestrator'Ğ¾Ğ¼)
            "prev_state": self.prev_state,
            "goal": self.goal,
            "collected_data": self.collected_data,
            "missing_data": self.missing_data,
            "optional_data": self.optional_data,
            "is_final": self.is_final,
            "spin_phase": self.spin_phase,
            "prev_phase": self.prev_phase,  # For decision_trace phase tracking
            "circular_flow": self.circular_flow,
            "objection_flow": self.objection_flow,

            # New fields (Blackboard-specific, Ğ´Ğ»Ñ ÑƒĞ»ÑƒÑ‡ÑˆĞµĞ½Ğ½Ğ¾Ğ¹ Ñ‚Ñ€Ğ°ÑÑĞ¸Ñ€Ğ¾Ğ²ĞºĞ¸)
            "reason_codes": self.reason_codes,
            "resolution_trace": self.resolution_trace,
        }

        # Add trace field for decision_trace.py compatibility
        # (decision_trace.record_state_machine reads sm_result.get("trace"))
        if self.resolution_trace:
            result["trace"] = self.resolution_trace

        return result

    def __repr__(self):
        return (f"ResolvedDecision(action='{self.action}', next_state='{self.next_state}', "
                f"reasons={self.reason_codes}, rejected={len(self.rejected_proposals)})")
5.5 ContextSnapshot Dataclass

# src/blackboard/models.py

from dataclasses import dataclass, field
from typing import Dict, Any, Optional, List, TYPE_CHECKING
from src.intent_tracker import IntentTracker
from src.context_envelope import ContextEnvelope

# Import TenantConfig for multi-tenancy support
if TYPE_CHECKING:
    from .protocols import TenantConfig

@dataclass(frozen=True)  # Immutable!
class ContextSnapshot:
    """
    Immutable snapshot of dialogue context for Knowledge Sources.

    This is the read-only view that Knowledge Sources use to make decisions.
    Sources cannot modify this directly - they can only propose changes.

    Attributes:
        state: Current dialogue state (e.g., "spin_situation")
        collected_data: All collected data fields (immutable copy)
        current_intent: The intent of the current user message
        intent_tracker: Reference to IntentTracker (for history queries)
        context_envelope: Full context envelope from Phase 5
        turn_number: Current turn number in the conversation
        persona: Detected user persona (for dynamic limits)
        state_config: Configuration for current state
        flow_config: Configuration for current flow
        tenant_id: Tenant identifier for multi-tenancy support
        tenant_config: Tenant-specific configuration (feature flags, limits)
    """
    state: str
    collected_data: Dict[str, Any]
    current_intent: str
    intent_tracker: IntentTracker
    context_envelope: Optional[ContextEnvelope]
    turn_number: int
    persona: str
    state_config: Dict[str, Any]
    flow_config: Dict[str, Any]
    # Multi-tenancy support (DESIGN_PRINCIPLES.md Section 6)
    tenant_id: str = "default"
    tenant_config: Optional['TenantConfig'] = None
    
    # Computed properties for convenience
    @property
    def last_intent(self) -> Optional[str]:
        """Get the previous intent (before current)."""
        return self.intent_tracker.prev_intent
    
    @property
    def objection_consecutive(self) -> int:
        """Get consecutive objection count."""
        return self.intent_tracker.objection_consecutive()
    
    @property
    def objection_total(self) -> int:
        """Get total objection count."""
        return self.intent_tracker.objection_total()
    
    @property
    def required_data(self) -> List[str]:
        """Get required data fields for current state."""
        return self.state_config.get("required_data", [])
    
    @property
    def optional_data(self) -> List[str]:
        """Get optional data fields for current state."""
        return self.state_config.get("optional_data", [])
    
    @property
    def current_phase(self) -> Optional[str]:
        """Get current SPIN phase."""
        return self.state_config.get("phase")
    
    def get_missing_required_data(self) -> List[str]:
        """Get list of required fields that are not yet collected."""
        return [
            field for field in self.required_data 
            if not self.collected_data.get(field)
        ]
    
    def has_all_required_data(self) -> bool:
        """Check if all required data has been collected."""
        return len(self.get_missing_required_data()) == 0
    
    def get_transition(self, trigger: str) -> Optional[str]:
        """Get transition target for a trigger."""
        transitions = self.state_config.get("transitions", {})
        return transitions.get(trigger)
    
    def get_rule(self, intent: str) -> Optional[Any]:
        """Get rule for an intent in current state."""
        rules = self.state_config.get("rules", {})
        return rules.get(intent)

    def get_persona_limit(self, persona: str, limit_type: str) -> Optional[int]:
        """
        Get persona-specific limit with tenant override support.

        Multi-tenancy: Tenant config can override global persona limits.

        Args:
            persona: Persona name (e.g., "aggressive", "busy")
            limit_type: Limit type ("consecutive" or "total")

        Returns:
            Limit value or None if not configured
        """
        # Check tenant override first
        if self.tenant_config and self.tenant_config.persona_limits_override:
            tenant_limits = self.tenant_config.persona_limits_override.get(persona, {})
            if limit_type in tenant_limits:
                return tenant_limits[limit_type]

        # Fall back to global config (passed via flow_config.constants)
        global_limits = self.flow_config.get("persona_limits", {}).get(persona, {})
        return global_limits.get(limit_type)

    def is_tenant_feature_enabled(self, feature_name: str) -> bool:
        """
        Check if a feature is enabled for current tenant.

        Args:
            feature_name: Feature flag name

        Returns:
            True if feature is enabled, False otherwise
        """
        if self.tenant_config and self.tenant_config.features:
            return self.tenant_config.features.get(feature_name, True)
        return True  # Default: all features enabled

6. DialogueBlackboard

# src/blackboard/blackboard.py

from dataclasses import dataclass, field
from typing import Dict, Any, Optional, List, TYPE_CHECKING
from datetime import datetime
import logging

from .models import Proposal, ResolvedDecision, ContextSnapshot
from .enums import Priority, ProposalType
from .protocols import (
    IStateMachine,
    IIntentTracker,
    IFlowConfig,
    TenantConfig,
    DEFAULT_TENANT,
)
from src.intent_tracker import IntentTracker
from src.context_envelope import ContextEnvelope
from src.config_loader import FlowConfig

logger = logging.getLogger(__name__)


class DialogueBlackboard:
    """
    Central shared workspace for dialogue management.

    Implements the Blackboard architectural pattern with three layers:
    1. Context Layer (read-only) - current dialogue state
    2. Proposal Layer (write by sources) - proposed actions/transitions
    3. Decision Layer (write by resolver) - final resolved decision

    Hexagonal Architecture:
        DialogueBlackboard depends on protocols (IStateMachine, IIntentTracker, IFlowConfig)
        rather than concrete implementations. This allows easy testing and swapping
        implementations without changing Blackboard code.

    Multi-Tenancy:
        Supports tenant-specific configuration via TenantConfig. Each tenant can have
        custom persona limits, feature flags, and other settings.

    Usage:
        bb = DialogueBlackboard(state_machine, flow_config)
        bb.begin_turn(intent, extracted_data, context_envelope)

        # Knowledge Sources contribute
        source.contribute(bb)

        # Get context snapshot (read-only)
        ctx = bb.get_context()

        # Propose changes
        bb.propose_action("answer_with_pricing", Priority.HIGH, combinable=True)
        bb.propose_transition("spin_problem", Priority.NORMAL)

        # Resolve and commit
        decision = resolver.resolve(bb.get_proposals())
        bb.commit_decision(decision)
    """

    def __init__(
        self,
        state_machine: 'IStateMachine',  # Protocol type for Hexagonal Architecture
        flow_config: 'IFlowConfig',
        intent_tracker: Optional['IIntentTracker'] = None,
        tenant_config: Optional['TenantConfig'] = None  # Multi-tenancy support
    ):
        """
        Initialize the blackboard.

        Args:
            state_machine: State machine implementing IStateMachine protocol
            flow_config: Flow configuration implementing IFlowConfig protocol
            intent_tracker: Intent tracker implementing IIntentTracker protocol
                           (uses state_machine's if not provided)
            tenant_config: Tenant-specific configuration (optional, uses DEFAULT_TENANT if not provided)
        """
        self._state_machine = state_machine
        self._flow_config = flow_config
        self._intent_tracker = intent_tracker or state_machine._intent_tracker
        self._tenant_config = tenant_config or DEFAULT_TENANT

        # === Context Layer (populated on begin_turn) ===
        self._context: Optional[ContextSnapshot] = None

        # === Proposal Layer ===
        self._action_proposals: List[Proposal] = []
        self._transition_proposals: List[Proposal] = []
        self._data_updates: Dict[str, Any] = {}
        self._flags_to_set: Dict[str, Any] = {}

        # === Decision Layer ===
        self._decision: Optional[ResolvedDecision] = None

        # === Metadata ===
        self._turn_start_time: Optional[datetime] = None
        self._current_intent: Optional[str] = None

    @property
    def tenant_id(self) -> str:
        """Get current tenant ID."""
        return self._tenant_config.tenant_id

    @property
    def tenant_config(self) -> 'TenantConfig':
        """Get current tenant configuration."""
        return self._tenant_config
        
    # =========================================================================
    # CONTEXT LAYER (Read-Only)
    # =========================================================================
    
    def begin_turn(
        self,
        intent: str,
        extracted_data: Dict[str, Any],
        context_envelope: Optional[ContextEnvelope] = None
    ) -> None:
        """
        Begin a new dialogue turn.
        
        This method:
        1. Records the intent in IntentTracker
        2. Updates collected_data with extracted_data
        3. Creates an immutable ContextSnapshot
        4. Clears previous proposals and decision
        
        Args:
            intent: Classified intent for this turn
            extracted_data: Data extracted from user message
            context_envelope: Full context envelope (Phase 5)
        """
        self._turn_start_time = datetime.now()
        self._current_intent = intent

        # Record intent in tracker (MUST happen first, before condition evaluation)
        # Ğ˜Ğ¡ĞšĞ›Ğ®Ğ§Ğ•ĞĞ˜Ğ•: ĞŸÑ€Ğ¾Ğ¿ÑƒÑĞºĞ°ĞµĞ¼ Ğ·Ğ°Ğ¿Ğ¸ÑÑŒ Ğ²Ğ¾Ğ·Ñ€Ğ°Ğ¶ĞµĞ½Ğ¸Ğ¹ ĞµÑĞ»Ğ¸ Ğ»Ğ¸Ğ¼Ğ¸Ñ‚ ÑƒĞ¶Ğµ Ğ´Ğ¾ÑÑ‚Ğ¸Ğ³Ğ½ÑƒÑ‚
        # Ñ‡Ñ‚Ğ¾Ğ±Ñ‹ Ğ¿Ñ€ĞµĞ´Ğ¾Ñ‚Ğ²Ñ€Ğ°Ñ‚Ğ¸Ñ‚ÑŒ Ğ¿ĞµÑ€ĞµĞ¿Ğ¾Ğ»Ğ½ĞµĞ½Ğ¸Ğµ ÑÑ‡Ñ‘Ñ‚Ñ‡Ğ¸ĞºĞ° (3â†’6) Ğ¿Ñ€Ğ¸ Ğ¿Ñ€Ğ¾Ğ´Ğ¾Ğ»Ğ¶ĞµĞ½Ğ¸Ğ¸ soft_close
        if not self._should_skip_objection_recording(intent):
            self._intent_tracker.record(intent, self._state_machine.state)
        
        # Update collected_data with newly extracted data
        current_collected = dict(self._state_machine.collected_data)
        for key, value in extracted_data.items():
            if value is not None and value != "":
                current_collected[key] = value
        
        # Get current state configuration
        state_config = self._flow_config.states.get(
            self._state_machine.state, {}
        )
        
        # Detect persona from collected data
        persona = current_collected.get("persona", "default")
        
        # Create immutable context snapshot
        self._context = ContextSnapshot(
            state=self._state_machine.state,
            collected_data=current_collected,
            current_intent=intent,
            intent_tracker=self._intent_tracker,
            context_envelope=context_envelope,
            turn_number=self._intent_tracker.turn_number,
            persona=persona,
            state_config=state_config,
            flow_config=self._flow_config.to_dict() if hasattr(self._flow_config, 'to_dict') else {},
            # Multi-tenancy support
            tenant_id=self._tenant_config.tenant_id,
            tenant_config=self._tenant_config,
        )
        
        # Clear proposal layer
        self._action_proposals.clear()
        self._transition_proposals.clear()
        self._data_updates.clear()
        self._flags_to_set.clear()
        
        # Clear decision layer
        self._decision = None
        
        logger.debug(
            f"Blackboard turn started: intent={intent}, state={self._state_machine.state}, "
            f"turn={self._intent_tracker.turn_number}"
        )

    def _should_skip_objection_recording(self, intent: str) -> bool:
        """
        Check if objection recording should be skipped.

        Prevents counter from growing beyond limit when soft_close
        continues the dialog (e.g., when is_final=false).

        This mirrors StateMachine._should_skip_objection_recording() for
        compatibility with existing objection handling logic.

        Args:
            intent: The intent to check

        Returns:
            True if recording should be skipped (limit already reached)
        """
        from src.yaml_config.constants import OBJECTION_INTENTS

        if intent not in OBJECTION_INTENTS:
            return False

        # Get limits from flow config or use defaults
        max_consecutive = self._flow_config.states.get("_limits", {}).get(
            "max_consecutive_objections", 3
        )
        max_total = self._flow_config.states.get("_limits", {}).get(
            "max_total_objections", 5
        )

        # Check if limit already reached
        consecutive = self._intent_tracker.objection_consecutive()
        total = self._intent_tracker.objection_total()

        if consecutive >= max_consecutive or total >= max_total:
            logger.debug(
                f"Skipping objection recording - limit already reached: "
                f"consecutive={consecutive}, total={total}"
            )
            return True
        return False

    def get_context(self) -> ContextSnapshot:
        """
        Get the immutable context snapshot.
        
        This is the primary way Knowledge Sources access dialogue state.
        The snapshot is read-only - sources cannot modify it directly.
        
        Returns:
            ContextSnapshot with current dialogue state
            
        Raises:
            RuntimeError: If called before begin_turn()
        """
        if self._context is None:
            raise RuntimeError("Blackboard.get_context() called before begin_turn()")
        return self._context
    
    @property
    def current_intent(self) -> str:
        """Get the current turn's intent."""
        if self._current_intent is None:
            raise RuntimeError("Blackboard accessed before begin_turn()")
        return self._current_intent
    
    @property
    def current_state(self) -> str:
        """Get the current dialogue state."""
        return self._state_machine.state
    
    @property
    def collected_data(self) -> Dict[str, Any]:
        """Get collected data (from context snapshot)."""
        return self._context.collected_data if self._context else {}
    
    # =========================================================================
    # PROPOSAL LAYER (Write by Sources)
    # =========================================================================
    
    def propose_action(
        self,
        action: str,
        priority: Priority = Priority.NORMAL,
        combinable: bool = True,
        reason_code: str = "",
        source_name: str = "unknown",
        metadata: Optional[Dict[str, Any]] = None
    ) -> None:
        """
        Propose an action to be executed.
        
        Args:
            action: Name of the action (e.g., "answer_with_pricing")
            priority: Priority level (CRITICAL, HIGH, NORMAL, LOW)
            combinable: If True, this action can coexist with transitions.
                        If False, this action blocks all transitions.
            reason_code: Documented reason for this proposal
            source_name: Name of the Knowledge Source making this proposal
            metadata: Additional context about the proposal
        """
        proposal = Proposal(
            type=ProposalType.ACTION,
            value=action,
            priority=priority,
            source_name=source_name,
            reason_code=reason_code or f"action_{action}",
            combinable=combinable,
            metadata=metadata or {},
        )
        
        self._action_proposals.append(proposal)
        
        logger.debug(
            f"Action proposed: {action} (priority={priority.name}, "
            f"combinable={combinable}, source={source_name})"
        )
    
    def propose_transition(
        self,
        next_state: str,
        priority: Priority = Priority.NORMAL,
        reason_code: str = "",
        source_name: str = "unknown",
        metadata: Optional[Dict[str, Any]] = None
    ) -> None:
        """
        Propose a state transition.
        
        Args:
            next_state: Target state name (e.g., "spin_problem")
            priority: Priority level (CRITICAL, HIGH, NORMAL, LOW)
            reason_code: Documented reason for this proposal
            source_name: Name of the Knowledge Source making this proposal
            metadata: Additional context about the proposal
        """
        proposal = Proposal(
            type=ProposalType.TRANSITION,
            value=next_state,
            priority=priority,
            source_name=source_name,
            reason_code=reason_code or f"transition_to_{next_state}",
            combinable=True,  # Transitions are always combinable
            metadata=metadata or {},
        )
        
        self._transition_proposals.append(proposal)
        
        logger.debug(
            f"Transition proposed: {next_state} (priority={priority.name}, "
            f"source={source_name})"
        )
    
    def propose_data_update(
        self,
        field: str,
        value: Any,
        source_name: str = "unknown",
        reason_code: str = ""
    ) -> None:
        """
        Propose a data field update.
        
        Args:
            field: Field name to update
            value: New value for the field
            source_name: Name of the Knowledge Source making this proposal
            reason_code: Documented reason for this proposal
        """
        self._data_updates[field] = value
        
        logger.debug(
            f"Data update proposed: {field}={value} (source={source_name})"
        )
    
    def propose_flag_set(
        self,
        flag: str,
        value: Any,
        source_name: str = "unknown",
        reason_code: str = ""
    ) -> None:
        """
        Propose setting a flag.
        
        Args:
            flag: Flag name to set
            value: Value to set
            source_name: Name of the Knowledge Source making this proposal
            reason_code: Documented reason for this proposal
        """
        self._flags_to_set[flag] = value
        
        logger.debug(
            f"Flag set proposed: {flag}={value} (source={source_name})"
        )
    
    def get_proposals(self) -> List[Proposal]:
        """
        Get all proposals (actions + transitions).
        
        Returns:
            Combined list of all proposals
        """
        return self._action_proposals + self._transition_proposals
    
    def get_action_proposals(self) -> List[Proposal]:
        """Get only action proposals."""
        return list(self._action_proposals)
    
    def get_transition_proposals(self) -> List[Proposal]:
        """Get only transition proposals."""
        return list(self._transition_proposals)
    
    def get_data_updates(self) -> Dict[str, Any]:
        """Get proposed data updates."""
        return dict(self._data_updates)
    
    def get_flags_to_set(self) -> Dict[str, Any]:
        """Get proposed flags to set."""
        return dict(self._flags_to_set)
    
    # =========================================================================
    # DECISION LAYER (Write by Resolver)
    # =========================================================================
    
    def commit_decision(self, decision: ResolvedDecision) -> None:
        """
        Commit the resolved decision.
        
        This method:
        1. Stores the decision in the decision layer
        2. Applies data updates to state machine
        3. Applies flags to state machine
        
        Note: State transition is NOT applied here - it's done by the caller
        (SalesBot) to maintain compatibility with existing code.
        
        Args:
            decision: The resolved decision from ConflictResolver
        """
        self._decision = decision
        
        # Apply data updates
        for field, value in decision.data_updates.items():
            self._state_machine.collected_data[field] = value
        
        # Apply any additional data updates from proposals
        for field, value in self._data_updates.items():
            self._state_machine.collected_data[field] = value
        
        # Store flags (applied on state entry)
        for flag, value in decision.flags_to_set.items():
            self._flags_to_set[flag] = value
        
        logger.info(
            f"Decision committed: action={decision.action}, "
            f"next_state={decision.next_state}, "
            f"reasons={decision.reason_codes}"
        )
    
    def get_decision(self) -> Optional[ResolvedDecision]:
        """
        Get the committed decision.
        
        Returns:
            ResolvedDecision if committed, None otherwise
        """
        return self._decision
    
    # =========================================================================
    # UTILITY METHODS
    # =========================================================================
    
    def get_turn_summary(self) -> Dict[str, Any]:
        """
        Get a summary of the current turn for logging/debugging.
        
        Returns:
            Dictionary with turn summary
        """
        return {
            "turn_number": self._intent_tracker.turn_number,
            "intent": self._current_intent,
            "state": self._state_machine.state,
            "action_proposals_count": len(self._action_proposals),
            "transition_proposals_count": len(self._transition_proposals),
            "action_proposals": [str(p) for p in self._action_proposals],
            "transition_proposals": [str(p) for p in self._transition_proposals],
            "data_updates": self._data_updates,
            "decision": self._decision.to_dict() if self._decision else None,
            "turn_duration_ms": (
                (datetime.now() - self._turn_start_time).total_seconds() * 1000
                if self._turn_start_time else None
            ),
        }
7. Knowledge Source Base Class

# src/blackboard/knowledge_source.py

from abc import ABC, abstractmethod
from typing import Optional, List, Dict, Any
import logging

from .blackboard import DialogueBlackboard
from .models import ContextSnapshot

logger = logging.getLogger(__name__)


class KnowledgeSource(ABC):
    """
    Abstract base class for Knowledge Sources.
    
    Knowledge Sources are independent modules that contribute proposals
    to the Blackboard. Each source has a specific responsibility and
    should not know about other sources.
    
    Lifecycle:
        1. should_contribute(bb) - Quick check if source should run
        2. contribute(bb) - Make proposals to the blackboard
    
    Guidelines for implementing Knowledge Sources:
        - Single Responsibility: Each source should have ONE clear purpose
        - No Side Effects: Sources should only propose, never modify state directly
        - Idempotent: Multiple calls with same context should produce same proposals
        - Fast: should_contribute() must be O(1), contribute() should be efficient
    """
    
    def __init__(self, name: Optional[str] = None):
        """
        Initialize the knowledge source.
        
        Args:
            name: Optional name for the source (defaults to class name)
        """
        self._name = name or self.__class__.__name__
        self._enabled = True
    
    @property
    def name(self) -> str:
        """Get the source name."""
        return self._name
    
    @property
    def enabled(self) -> bool:
        """Check if source is enabled."""
        return self._enabled
    
    def enable(self) -> None:
        """Enable the source."""
        self._enabled = True
    
    def disable(self) -> None:
        """Disable the source."""
        self._enabled = False
    
    def should_contribute(self, blackboard: DialogueBlackboard) -> bool:
        """
        Quick check whether this source should contribute.
        
        This method is called before contribute() and should be FAST (O(1)).
        Use it to avoid expensive computation when the source is not relevant.
        
        Default implementation returns True (always contribute).
        Override this method for performance optimization.
        
        Args:
            blackboard: The dialogue blackboard
            
        Returns:
            True if contribute() should be called, False to skip
        """
        return self._enabled
    
    @abstractmethod
    def contribute(self, blackboard: DialogueBlackboard) -> None:
        """
        Contribute proposals to the blackboard.
        
        This method should:
        1. Read context from blackboard.get_context()
        2. Evaluate conditions based on context
        3. Call blackboard.propose_action() / propose_transition() as needed
        
        Args:
            blackboard: The dialogue blackboard to contribute to
        """
        pass
    
    def _log_contribution(
        self,
        action: Optional[str] = None,
        transition: Optional[str] = None,
        reason: str = ""
    ) -> None:
        """Helper to log contributions."""
        if action:
            logger.debug(f"[{self._name}] Proposing action: {action} ({reason})")
        if transition:
            logger.debug(f"[{self._name}] Proposing transition: {transition} ({reason})")
        if not action and not transition:
            logger.debug(f"[{self._name}] No proposals ({reason})")
7.1 SourceRegistry (Plugin System)

# src/blackboard/source_registry.py

from typing import Dict, Type, List, Optional, Any, Callable
from dataclasses import dataclass, field
import logging

from .knowledge_source import KnowledgeSource

logger = logging.getLogger(__name__)


@dataclass
class SourceRegistration:
    """
    Registration entry for a Knowledge Source.

    Attributes:
        source_class: The KnowledgeSource class (not instance)
        name: Unique name for this source
        priority_order: Order in which sources are called (lower = earlier)
        enabled_by_default: Whether source is enabled by default
        config_key: Key in constants.yaml for source-specific config
        description: Human-readable description
    """
    source_class: Type[KnowledgeSource]
    name: str
    priority_order: int = 100
    enabled_by_default: bool = True
    config_key: Optional[str] = None
    description: str = ""

    def __post_init__(self):
        if not self.name:
            self.name = self.source_class.__name__


class SourceRegistry:
    """
    Registry for Knowledge Sources following Plugin Architecture pattern.

    This registry allows:
        - Dynamic registration of Knowledge Sources
        - Configuration-driven enabling/disabling of sources
        - Ordered instantiation of sources
        - Runtime addition of custom sources

    Usage:
        # Register built-in sources (typically in sources/__init__.py)
        SourceRegistry.register(
            PriceQuestionSource,
            name="PriceQuestionSource",
            priority_order=10,
            config_key="price_question"
        )

        # Get all enabled source instances
        sources = SourceRegistry.create_sources(config)

        # Register custom source at runtime
        SourceRegistry.register(MyCustomSource, priority_order=50)

    Design Principles:
        - Open/Closed: New sources can be added without modifying existing code
        - Configuration-driven: Sources can be enabled/disabled via YAML
        - Deterministic: Sources are always instantiated in priority_order
    """

    _registry: Dict[str, SourceRegistration] = {}
    _frozen: bool = False

    @classmethod
    def register(
        cls,
        source_class: Type[KnowledgeSource],
        name: Optional[str] = None,
        priority_order: int = 100,
        enabled_by_default: bool = True,
        config_key: Optional[str] = None,
        description: str = "",
    ) -> None:
        """
        Register a Knowledge Source class.

        Args:
            source_class: The KnowledgeSource class to register
            name: Unique name (defaults to class name)
            priority_order: Execution order (lower = earlier)
            enabled_by_default: Whether enabled when not in config
            config_key: Key in constants.yaml for source config
            description: Human-readable description

        Raises:
            ValueError: If name is already registered
            TypeError: If source_class is not a KnowledgeSource subclass
        """
        if not issubclass(source_class, KnowledgeSource):
            raise TypeError(
                f"{source_class} must be a subclass of KnowledgeSource"
            )

        registration_name = name or source_class.__name__

        if registration_name in cls._registry and cls._frozen:
            raise ValueError(
                f"Source '{registration_name}' is already registered and registry is frozen"
            )

        cls._registry[registration_name] = SourceRegistration(
            source_class=source_class,
            name=registration_name,
            priority_order=priority_order,
            enabled_by_default=enabled_by_default,
            config_key=config_key,
            description=description,
        )

        logger.debug(f"Registered Knowledge Source: {registration_name} (order={priority_order})")

    @classmethod
    def unregister(cls, name: str) -> bool:
        """
        Unregister a Knowledge Source.

        Args:
            name: Name of the source to unregister

        Returns:
            True if source was unregistered, False if not found
        """
        if cls._frozen:
            raise RuntimeError("Cannot unregister from frozen registry")

        if name in cls._registry:
            del cls._registry[name]
            logger.debug(f"Unregistered Knowledge Source: {name}")
            return True
        return False

    @classmethod
    def get_registration(cls, name: str) -> Optional[SourceRegistration]:
        """Get registration info for a source."""
        return cls._registry.get(name)

    @classmethod
    def list_registered(cls) -> List[str]:
        """List all registered source names in priority order."""
        sorted_regs = sorted(
            cls._registry.values(),
            key=lambda r: r.priority_order
        )
        return [r.name for r in sorted_regs]

    @classmethod
    def create_sources(
        cls,
        config: Optional[Dict[str, Any]] = None,
        source_configs: Optional[Dict[str, Dict[str, Any]]] = None,
    ) -> List[KnowledgeSource]:
        """
        Create instances of all enabled Knowledge Sources.

        Args:
            config: Global config dict (checks 'sources.{name}.enabled')
            source_configs: Per-source configuration dicts

        Returns:
            List of KnowledgeSource instances in priority order
        """
        config = config or {}
        source_configs = source_configs or {}

        # Get sources config section
        sources_config = config.get("sources", {})

        # Sort registrations by priority
        sorted_regs = sorted(
            cls._registry.values(),
            key=lambda r: r.priority_order
        )

        sources: List[KnowledgeSource] = []

        for reg in sorted_regs:
            # Check if enabled
            source_cfg = sources_config.get(reg.name, {})
            is_enabled = source_cfg.get("enabled", reg.enabled_by_default)

            if not is_enabled:
                logger.debug(f"Source {reg.name} is disabled by config")
                continue

            # Get source-specific config
            init_kwargs = source_configs.get(reg.name, {})
            init_kwargs["name"] = reg.name

            # Create instance
            try:
                source = reg.source_class(**init_kwargs)
                sources.append(source)
                logger.debug(f"Created source instance: {reg.name}")
            except Exception as e:
                logger.error(f"Failed to create source {reg.name}: {e}")
                raise

        logger.info(f"Created {len(sources)} Knowledge Sources")
        return sources

    @classmethod
    def freeze(cls) -> None:
        """Freeze registry to prevent further modifications."""
        cls._frozen = True
        logger.info("SourceRegistry frozen")

    @classmethod
    def reset(cls) -> None:
        """Reset registry (mainly for testing)."""
        cls._registry.clear()
        cls._frozen = False
        logger.debug("SourceRegistry reset")


# === Decorator for easy registration ===

def register_source(
    name: Optional[str] = None,
    priority_order: int = 100,
    enabled_by_default: bool = True,
    config_key: Optional[str] = None,
    description: str = "",
) -> Callable[[Type[KnowledgeSource]], Type[KnowledgeSource]]:
    """
    Decorator to register a Knowledge Source class.

    Usage:
        @register_source(priority_order=10, description="Handles price questions")
        class PriceQuestionSource(KnowledgeSource):
            ...
    """
    def decorator(cls: Type[KnowledgeSource]) -> Type[KnowledgeSource]:
        SourceRegistry.register(
            source_class=cls,
            name=name,
            priority_order=priority_order,
            enabled_by_default=enabled_by_default,
            config_key=config_key,
            description=description,
        )
        return cls
    return decorator


# === Built-in sources registration ===
# This is called when the module is imported

def register_builtin_sources() -> None:
    """
    Register all built-in Knowledge Sources.

    Called automatically when blackboard module is imported.
    Sources are registered in recommended execution order.
    """
    from .sources.price_question import PriceQuestionSource
    from .sources.data_collector import DataCollectorSource
    from .sources.objection_guard import ObjectionGuardSource
    from .sources.intent_processor import IntentProcessorSource
    from .sources.transition_resolver import TransitionResolverSource
    from .sources.escalation import EscalationSource

    # Register in recommended order (lower priority_order = earlier execution)
    SourceRegistry.register(
        PriceQuestionSource,
        name="PriceQuestionSource",
        priority_order=10,
        config_key="price_question",
        description="Handles price-related questions with combinable actions"
    )

    SourceRegistry.register(
        DataCollectorSource,
        name="DataCollectorSource",
        priority_order=20,
        config_key="data_collector",
        description="Tracks data completeness and proposes transitions"
    )

    SourceRegistry.register(
        ObjectionGuardSource,
        name="ObjectionGuardSource",
        priority_order=30,
        config_key="objection_guard",
        description="Monitors objection limits per persona"
    )

    SourceRegistry.register(
        IntentProcessorSource,
        name="IntentProcessorSource",
        priority_order=40,
        config_key="intent_processor",
        description="Maps intents to actions via rules"
    )

    SourceRegistry.register(
        TransitionResolverSource,
        name="TransitionResolverSource",
        priority_order=50,
        config_key="transition_resolver",
        description="Handles intent-based state transitions"
    )

    SourceRegistry.register(
        EscalationSource,
        name="EscalationSource",
        priority_order=60,
        config_key="escalation",
        description="Detects escalation triggers for human handoff"
    )

    logger.info(f"Registered {len(SourceRegistry.list_registered())} built-in sources")

ĞŸÑ€Ğ¾Ğ´Ğ¾Ğ»Ğ¶Ğ°Ñ Ñ Ñ‡ĞµÑ‚Ğ²Ñ‘Ñ€Ñ‚Ğ¾Ğ¹ Ñ‡Ğ°ÑÑ‚ÑŒÑ â€” Ğ ĞµĞ°Ğ»Ğ¸Ğ·Ğ°Ñ†Ğ¸Ñ Knowledge Sources.

Ğ¿Ñ€Ğ¾Ğ´Ğ¾Ğ»Ğ¶Ğ°Ğ¹
Ğ§Ğ°ÑÑ‚ÑŒ 4: Ğ ĞµĞ°Ğ»Ğ¸Ğ·Ğ°Ñ†Ğ¸Ñ Knowledge Sources
8. Knowledge Sources Implementation
8.1 PriceQuestionSource

# src/blackboard/sources/price_question.py

from typing import Set, Optional
import logging

from ..knowledge_source import KnowledgeSource
from ..blackboard import DialogueBlackboard
from ..enums import Priority

logger = logging.getLogger(__name__)


class PriceQuestionSource(KnowledgeSource):
    """
    Knowledge Source for handling price-related questions.
    
    Responsibility:
        - Detect price-related intents
        - Propose "answer_with_pricing" action
        - Always combinable=True (allows state transitions to proceed)
    
    Intents handled:
        - price_question
        - pricing_details
        - cost_inquiry
        - discount_request
        - payment_terms
    
    This source addresses the core problem: price questions should be answered
    WITHOUT blocking data_complete transitions.
    """
    
    # Default price-related intents (can be overridden from config)
    DEFAULT_PRICE_INTENTS: Set[str] = {
        "price_question",
        "pricing_details", 
        "cost_inquiry",
        "discount_request",
        "payment_terms",
        "pricing_comparison",
        "budget_question",
    }
    
    def __init__(
        self,
        price_intents: Optional[Set[str]] = None,
        name: str = "PriceQuestionSource"
    ):
        """
        Initialize the price question source.
        
        Args:
            price_intents: Set of intents considered price-related.
                           Defaults to DEFAULT_PRICE_INTENTS.
            name: Source name for logging
        """
        super().__init__(name)
        self._price_intents = price_intents or self.DEFAULT_PRICE_INTENTS
    
    def should_contribute(self, blackboard: DialogueBlackboard) -> bool:
        """
        Quick check: is current intent price-related?
        
        O(1) check against price intents set.
        """
        if not self._enabled:
            return False
        
        return blackboard.current_intent in self._price_intents
    
    def contribute(self, blackboard: DialogueBlackboard) -> None:
        """
        Propose answer_with_pricing action for price questions.
        
        Key design decision: combinable=True
        This allows the action to coexist with transitions (e.g., data_complete).
        The bot will answer the price question AND transition to the next phase.
        """
        ctx = blackboard.get_context()
        intent = ctx.current_intent
        
        if intent not in self._price_intents:
            self._log_contribution(reason="Intent not price-related")
            return
        
        # Determine specific action based on intent
        if intent == "discount_request":
            action = "handle_discount_request"
        elif intent == "payment_terms":
            action = "explain_payment_terms"
        else:
            action = "answer_with_pricing"
        
        # Check if we have pricing data available
        has_pricing = bool(ctx.collected_data.get("pricing_tier"))
        
        # Propose action with HIGH priority (but combinable!)
        blackboard.propose_action(
            action=action,
            priority=Priority.HIGH,
            combinable=True,  # KEY: Allows coexistence with transitions
            reason_code="price_question_priority",
            source_name=self.name,
            metadata={
                "original_intent": intent,
                "has_pricing_data": has_pricing,
            }
        )
        
        self._log_contribution(
            action=action,
            reason=f"Price intent detected: {intent}"
        )
8.2 DataCollectorSource

# src/blackboard/sources/data_collector.py

from typing import List, Optional, Dict, Any
import logging

from ..knowledge_source import KnowledgeSource
from ..blackboard import DialogueBlackboard
from ..enums import Priority

logger = logging.getLogger(__name__)


class DataCollectorSource(KnowledgeSource):
    """
    Knowledge Source for monitoring data collection progress.
    
    Responsibility:
        - Check if required data for current state is complete
        - Propose data_complete transition when all required data is collected
        - DOES NOT handle intent-based transitions (that's TransitionResolverSource)
    
    This is a critical source that ensures automatic phase progression
    when users provide required information (even in combination with other intents).
    
    Clear boundary with TransitionResolverSource:
        - DataCollectorSource: data_complete transitions ONLY
        - TransitionResolverSource: intent-based transitions ONLY
    """
    
    def __init__(self, name: str = "DataCollectorSource"):
        """
        Initialize the data collector source.
        
        Args:
            name: Source name for logging
        """
        super().__init__(name)
    
    def should_contribute(self, blackboard: DialogueBlackboard) -> bool:
        """
        Quick check: does current state have required_data?
        
        Skip if:
        - Source is disabled
        - State has no required_data defined
        - State is final
        """
        if not self._enabled:
            return False
        
        ctx = blackboard.get_context()
        
        # Skip if state is final
        if ctx.state_config.get("is_final", False):
            return False
        
        # Skip if no required_data defined
        required = ctx.state_config.get("required_data", [])
        if not required:
            return False
        
        return True
    
    def contribute(self, blackboard: DialogueBlackboard) -> None:
        """
        Check data completeness and propose transition if complete.
        
        Algorithm:
        1. Get required_data from state config
        2. Check each field in collected_data
        3. If all required fields present -> propose data_complete transition
        """
        ctx = blackboard.get_context()
        
        required_fields = ctx.required_data
        collected = ctx.collected_data
        
        # Find missing fields
        missing_fields = []
        for field in required_fields:
            value = collected.get(field)
            if value is None or value == "" or value == []:
                missing_fields.append(field)
        
        if missing_fields:
            # Not all data collected yet
            self._log_contribution(
                reason=f"Missing required data: {missing_fields}"
            )
            return
        
        # All required data is present!
        # Check if there's a data_complete transition defined
        data_complete_target = ctx.get_transition("data_complete")
        
        if not data_complete_target:
            # No data_complete transition defined for this state
            self._log_contribution(
                reason="Data complete but no transition defined"
            )
            return
        
        # Propose the transition
        blackboard.propose_transition(
            next_state=data_complete_target,
            priority=Priority.NORMAL,
            reason_code="data_complete",
            source_name=self.name,
            metadata={
                "required_fields": required_fields,
                "collected_fields": list(collected.keys()),
            }
        )
        
        self._log_contribution(
            transition=data_complete_target,
            reason=f"All required data collected: {required_fields}"
        )
8.3 ObjectionGuardSource

# src/blackboard/sources/objection_guard.py

from typing import Dict, Optional, Set
import logging

from ..knowledge_source import KnowledgeSource
from ..blackboard import DialogueBlackboard
from ..enums import Priority

logger = logging.getLogger(__name__)


class ObjectionGuardSource(KnowledgeSource):
    """
    Knowledge Source for monitoring objection limits per persona.
    
    Responsibility:
        - Track consecutive and total objections
        - Apply persona-specific limits
        - Propose soft_close transition when limits exceeded
        - Propose objection_limit_reached action for appropriate messaging
    
    Persona limits (from constants.yaml):
        aggressive:      consecutive=5, total=8
        price_sensitive: consecutive=4, total=7
        skeptical:       consecutive=4, total=6
        busy:            consecutive=2, total=4
        default:         consecutive=3, total=5
    
    Design decision: When limit is reached, we propose BLOCKING action
    (combinable=False) because we want to stop normal processing and
    redirect to soft close.
    """
    
    # Default persona limits (loaded from constants.yaml in production)
    DEFAULT_PERSONA_LIMITS: Dict[str, Dict[str, int]] = {
        "aggressive": {"consecutive": 5, "total": 8},
        "price_sensitive": {"consecutive": 4, "total": 7},
        "skeptical": {"consecutive": 4, "total": 6},
        "busy": {"consecutive": 2, "total": 4},
        "analytical": {"consecutive": 4, "total": 6},
        "friendly": {"consecutive": 4, "total": 7},
        "default": {"consecutive": 3, "total": 5},
    }
    
    # Intents considered as objections
    DEFAULT_OBJECTION_INTENTS: Set[str] = {
        "objection_price",
        "objection_competitor", 
        "objection_timing",
        "objection_authority",
        "objection_need",
        "objection_trust",
        "objection_budget",
        "objection_features",
        "objection_complexity",
        "objection_support",
        "objection_integration",
        "objection_security",
        "objection_scalability",
        "objection_contract",
        "objection_implementation",
        "objection_training",
        "objection_roi",
        "objection_change",
        "objection_generic",
    }
    
    def __init__(
        self,
        persona_limits: Optional[Dict[str, Dict[str, int]]] = None,
        objection_intents: Optional[Set[str]] = None,
        name: str = "ObjectionGuardSource"
    ):
        """
        Initialize the objection guard source.
        
        Args:
            persona_limits: Dict mapping persona -> {consecutive, total} limits.
                           Defaults to DEFAULT_PERSONA_LIMITS.
            objection_intents: Set of intents considered as objections.
                              Defaults to DEFAULT_OBJECTION_INTENTS.
            name: Source name for logging
        """
        super().__init__(name)
        self._persona_limits = persona_limits or self.DEFAULT_PERSONA_LIMITS
        self._objection_intents = objection_intents or self.DEFAULT_OBJECTION_INTENTS
    
    def should_contribute(self, blackboard: DialogueBlackboard) -> bool:
        """
        Quick check: is current intent an objection?
        
        We only need to check limits when an objection is detected.
        """
        if not self._enabled:
            return False
        
        return blackboard.current_intent in self._objection_intents
    
    def contribute(self, blackboard: DialogueBlackboard) -> None:
        """
        Check objection limits and propose soft_close if exceeded.
        
        Algorithm:
        1. Get persona from collected_data (default: "default")
        2. Get limits for persona
        3. Get consecutive and total objection counts from IntentTracker
        4. If either limit exceeded -> propose blocking action + transition
        """
        ctx = blackboard.get_context()
        
        # Get persona (default if not detected)
        persona = ctx.persona
        if persona not in self._persona_limits:
            persona = "default"
        
        limits = self._persona_limits[persona]
        max_consecutive = limits["consecutive"]
        max_total = limits["total"]
        
        # Get objection counts from IntentTracker
        consecutive = ctx.objection_consecutive
        total = ctx.objection_total
        
        # Check if limits exceeded
        consecutive_exceeded = consecutive >= max_consecutive
        total_exceeded = total >= max_total
        
        if not consecutive_exceeded and not total_exceeded:
            # Within limits - let other sources handle the objection
            self._log_contribution(
                reason=f"Within limits: consecutive={consecutive}/{max_consecutive}, "
                       f"total={total}/{max_total} (persona={persona})"
            )
            return
        
        # Limits exceeded - propose blocking action and transition
        exceeded_reason = []
        if consecutive_exceeded:
            exceeded_reason.append(f"consecutive={consecutive}>={max_consecutive}")
        if total_exceeded:
            exceeded_reason.append(f"total={total}>={max_total}")
        
        reason_str = ", ".join(exceeded_reason)
        
        # Propose BLOCKING action (combinable=False)
        # This prevents any other actions from being merged
        blackboard.propose_action(
            action="objection_limit_reached",
            priority=Priority.HIGH,
            combinable=False,  # BLOCKING: prevents other actions
            reason_code="objection_limit_exceeded",
            source_name=self.name,
            metadata={
                "persona": persona,
                "consecutive": consecutive,
                "total": total,
                "max_consecutive": max_consecutive,
                "max_total": max_total,
                "exceeded": exceeded_reason,
            }
        )
        
        # Propose transition to soft_close
        blackboard.propose_transition(
            next_state="soft_close",
            priority=Priority.HIGH,
            reason_code="objection_limit_exceeded",
            source_name=self.name,
            metadata={
                "persona": persona,
                "trigger": reason_str,
            }
        )

        # CRITICAL: Set _objection_limit_final flag for is_final override
        # This ensures soft_close triggered by objection limit is always final
        # (prevents dialogue continuation and objection counter overflow)
        blackboard.propose_data_update(
            field="_objection_limit_final",
            value=True,
            source_name=self.name,
            reason_code="objection_limit_exceeded"
        )

        self._log_contribution(
            action="objection_limit_reached",
            transition="soft_close",
            reason=f"Objection limit exceeded for persona={persona}: {reason_str}"
        )
        
        logger.warning(
            f"Objection limit reached: persona={persona}, {reason_str}"
        )
8.4 IntentProcessorSource

# src/blackboard/sources/intent_processor.py

from typing import Optional, Dict, Any, List, Union
import logging

from ..knowledge_source import KnowledgeSource
from ..blackboard import DialogueBlackboard
from ..enums import Priority
from src.rules.resolver import RuleResolver
from src.conditions.state_machine.registry import ConditionRegistry

logger = logging.getLogger(__name__)


class IntentProcessorSource(KnowledgeSource):
    """
    Knowledge Source for general intent-to-action mapping.
    
    Responsibility:
        - Map intents to actions based on state rules
        - Use RuleResolver for conditional rule evaluation
        - Handle rules defined in state configuration
    
    DOES NOT handle:
        - Price questions (handled by PriceQuestionSource)
        - Objection limits (handled by ObjectionGuardSource)
        - State transitions (handled by TransitionResolverSource)
        - Data completeness (handled by DataCollectorSource)
    
    Rule formats supported:
        1. Simple string: "unclear": "probe_situation"
        2. Conditional dict: {"when": "condition", "then": "action"}
        3. Conditional chain: [{"when": "cond1", "then": "act1"}, "default"]
    """
    
    # Intents handled by dedicated sources (skip here)
    DEDICATED_SOURCE_INTENTS = {
        # Price questions handled by PriceQuestionSource
        "price_question",
        "pricing_details",
        "cost_inquiry",
        "discount_request",
        "payment_terms",
        "pricing_comparison",
        "budget_question",
    }
    
    def __init__(
        self,
        rule_resolver: Optional[RuleResolver] = None,
        condition_registry: Optional[ConditionRegistry] = None,
        name: str = "IntentProcessorSource"
    ):
        """
        Initialize the intent processor source.
        
        Args:
            rule_resolver: RuleResolver instance for conditional rules.
                          Created if not provided.
            condition_registry: ConditionRegistry for condition evaluation.
                               Created if not provided.
            name: Source name for logging
        """
        super().__init__(name)
        self._rule_resolver = rule_resolver or RuleResolver()
        self._condition_registry = condition_registry or ConditionRegistry()
    
    def should_contribute(self, blackboard: DialogueBlackboard) -> bool:
        """
        Quick check: should we process this intent?
        
        Skip if:
        - Source is disabled
        - Intent is handled by a dedicated source
        - No rules defined for current state
        """
        if not self._enabled:
            return False
        
        intent = blackboard.current_intent
        
        # Skip intents handled by dedicated sources
        if intent in self.DEDICATED_SOURCE_INTENTS:
            return False
        
        return True
    
    def contribute(self, blackboard: DialogueBlackboard) -> None:
        """
        Map intent to action using state rules.
        
        Algorithm:
        1. Get rules from current state config
        2. Check if intent has a rule defined
        3. If conditional rule, evaluate using RuleResolver
        4. Propose resolved action
        """
        ctx = blackboard.get_context()
        intent = ctx.current_intent
        
        # Skip dedicated source intents
        if intent in self.DEDICATED_SOURCE_INTENTS:
            self._log_contribution(
                reason=f"Intent {intent} handled by dedicated source"
            )
            return
        
        # Get rules from state config
        rules = ctx.state_config.get("rules", {})
        
        # Check if intent has a rule
        if intent not in rules:
            self._log_contribution(
                reason=f"No rule defined for intent: {intent}"
            )
            return
        
        rule = rules[intent]
        
        # Resolve the rule (handles simple string, conditional dict, chain)
        action = self._resolve_rule(rule, ctx)
        
        if not action:
            self._log_contribution(
                reason=f"Rule for {intent} evaluated to None"
            )
            return
        
        # Determine if action should be combinable
        # Most actions are combinable, but some block transitions
        blocking_actions = {
            "handle_rejection",
            "emergency_escalate",
            "end_conversation",
        }
        combinable = action not in blocking_actions
        
        # Propose the action
        blackboard.propose_action(
            action=action,
            priority=Priority.NORMAL,
            combinable=combinable,
            reason_code=f"rule_{intent}",
            source_name=self.name,
            metadata={
                "intent": intent,
                "rule_type": type(rule).__name__,
            }
        )
        
        self._log_contribution(
            action=action,
            reason=f"Rule matched for intent: {intent}"
        )
    
    def _resolve_rule(
        self,
        rule: Union[str, Dict, List],
        ctx
    ) -> Optional[str]:
        """
        Resolve a rule to an action.
        
        Args:
            rule: Rule definition (string, dict, or list)
            ctx: Context snapshot
            
        Returns:
            Resolved action name or None
        """
        # Simple string rule
        if isinstance(rule, str):
            return rule
        
        # Conditional dict rule: {"when": "condition", "then": "action"}
        if isinstance(rule, dict):
            condition = rule.get("when")
            action = rule.get("then")
            
            if condition and action:
                # Build evaluation context for condition registry
                eval_ctx = self._build_eval_context(ctx)
                
                if self._condition_registry.evaluate(condition, eval_ctx):
                    return action
            
            return None
        
        # Conditional chain: [{"when": "c1", "then": "a1"}, ..., "default"]
        if isinstance(rule, list):
            for item in rule:
                if isinstance(item, str):
                    # Default fallback
                    return item
                
                if isinstance(item, dict):
                    condition = item.get("when")
                    action = item.get("then")
                    
                    if condition and action:
                        eval_ctx = self._build_eval_context(ctx)
                        
                        if self._condition_registry.evaluate(condition, eval_ctx):
                            return action
            
            return None
        
        logger.warning(f"Unknown rule type: {type(rule)}")
        return None
    
    def _build_eval_context(self, ctx) -> Dict[str, Any]:
        """Build evaluation context for condition registry."""
        return {
            "current_intent": ctx.current_intent,
            "state": ctx.state,
            "collected_data": ctx.collected_data,
            "intent_tracker": ctx.intent_tracker,
            "context_envelope": ctx.context_envelope,
        }
8.5 TransitionResolverSource

# src/blackboard/sources/transition_resolver.py

from typing import Optional, Dict, Any, List, Union, Set
import logging

from ..knowledge_source import KnowledgeSource
from ..blackboard import DialogueBlackboard
from ..enums import Priority
from src.conditions.state_machine.registry import ConditionRegistry

logger = logging.getLogger(__name__)


class TransitionResolverSource(KnowledgeSource):
    """
    Knowledge Source for intent-based state transitions.
    
    Responsibility:
        - Detect explicit intent-to-transition mappings
        - Handle conditional transitions
        - Propose state transitions based on intent
    
    DOES NOT handle:
        - data_complete transitions (handled by DataCollectorSource)
        - Objection limit transitions (handled by ObjectionGuardSource)
        - "any" fallback transitions (handled separately in Orchestrator)
    
    Clear boundary with DataCollectorSource:
        - TransitionResolverSource: intent-based transitions (e.g., "rejection" -> "soft_close")
        - DataCollectorSource: data-based transitions (data_complete only)
    """
    
    # Transition triggers handled by other sources
    EXCLUDED_TRIGGERS: Set[str] = {
        "data_complete",  # Handled by DataCollectorSource
        "any",            # Handled separately as fallback
    }
    
    def __init__(
        self,
        condition_registry: Optional[ConditionRegistry] = None,
        name: str = "TransitionResolverSource"
    ):
        """
        Initialize the transition resolver source.
        
        Args:
            condition_registry: ConditionRegistry for conditional transitions.
                               Created if not provided.
            name: Source name for logging
        """
        super().__init__(name)
        self._condition_registry = condition_registry or ConditionRegistry()
    
    def should_contribute(self, blackboard: DialogueBlackboard) -> bool:
        """
        Quick check: does current state have transitions defined?
        """
        if not self._enabled:
            return False
        
        ctx = blackboard.get_context()
        transitions = ctx.state_config.get("transitions", {})
        
        return len(transitions) > 0
    
    def contribute(self, blackboard: DialogueBlackboard) -> None:
        """
        Check for intent-based transitions and propose if matched.
        
        Algorithm:
        1. Get transitions from state config
        2. Check if current intent matches a transition trigger
        3. Handle conditional transitions
        4. Propose transition with appropriate priority
        """
        ctx = blackboard.get_context()
        intent = ctx.current_intent
        transitions = ctx.state_config.get("transitions", {})
        
        # Skip excluded triggers
        if intent in self.EXCLUDED_TRIGGERS:
            self._log_contribution(
                reason=f"Trigger {intent} handled by dedicated source"
            )
            return
        
        # Check if intent has a transition defined
        if intent not in transitions:
            self._log_contribution(
                reason=f"No transition defined for intent: {intent}"
            )
            return
        
        transition_def = transitions[intent]
        
        # Resolve the transition
        next_state = self._resolve_transition(transition_def, ctx)
        
        if not next_state:
            self._log_contribution(
                reason=f"Transition for {intent} evaluated to None"
            )
            return
        
        # Determine priority based on intent type
        high_priority_intents = {
            "rejection",
            "hard_no",
            "end_conversation",
            "explicit_close_request",
        }
        
        priority = Priority.HIGH if intent in high_priority_intents else Priority.NORMAL
        
        # Propose the transition
        blackboard.propose_transition(
            next_state=next_state,
            priority=priority,
            reason_code=f"intent_transition_{intent}",
            source_name=self.name,
            metadata={
                "trigger_intent": intent,
                "transition_type": type(transition_def).__name__,
            }
        )
        
        self._log_contribution(
            transition=next_state,
            reason=f"Intent-based transition: {intent} -> {next_state}"
        )
    
    def _resolve_transition(
        self,
        transition_def: Union[str, Dict, List],
        ctx
    ) -> Optional[str]:
        """
        Resolve a transition definition to a target state.
        
        Args:
            transition_def: Transition definition (string, dict, or list)
            ctx: Context snapshot
            
        Returns:
            Target state name or None
        """
        # Simple string transition
        if isinstance(transition_def, str):
            return transition_def
        
        # Conditional dict: {"when": "condition", "then": "state"}
        if isinstance(transition_def, dict):
            condition = transition_def.get("when")
            target = transition_def.get("then")
            
            if condition and target:
                eval_ctx = self._build_eval_context(ctx)
                
                if self._condition_registry.evaluate(condition, eval_ctx):
                    return target
            
            return None
        
        # Conditional chain: [{"when": "c1", "then": "s1"}, ..., "default"]
        if isinstance(transition_def, list):
            for item in transition_def:
                if isinstance(item, str):
                    # Default fallback
                    return item
                
                if isinstance(item, dict):
                    condition = item.get("when")
                    target = item.get("then")
                    
                    if condition and target:
                        eval_ctx = self._build_eval_context(ctx)
                        
                        if self._condition_registry.evaluate(condition, eval_ctx):
                            return target
            
            return None
        
        logger.warning(f"Unknown transition type: {type(transition_def)}")
        return None
    
    def _build_eval_context(self, ctx) -> Dict[str, Any]:
        """Build evaluation context for condition registry."""
        return {
            "current_intent": ctx.current_intent,
            "state": ctx.state,
            "collected_data": ctx.collected_data,
            "intent_tracker": ctx.intent_tracker,
            "context_envelope": ctx.context_envelope,
        }
8.6 EscalationSource

# src/blackboard/sources/escalation.py

from typing import Optional, Dict, Set
import logging

from ..knowledge_source import KnowledgeSource
from ..blackboard import DialogueBlackboard
from ..enums import Priority

logger = logging.getLogger(__name__)


class EscalationSource(KnowledgeSource):
    """
    Knowledge Source for human escalation triggers.
    
    Responsibility:
        - Detect situations requiring human intervention
        - Propose escalation action when triggers are met
        - Block all other processing (combinable=False)
    
    Escalation triggers:
        1. Explicit request: user asks for human/manager
        2. Frustration threshold: repeated failures or angry sentiment
        3. Repeated misunderstandings: multiple "unclear" intents
        4. Sensitive topics: legal, compliance, complaints
        5. High-value lead: detected enterprise/large deal
    
    Based on enterprise chatbot best practices:
    - Human escalation is critical for user satisfaction
    - Should be triggered proactively, not just reactively
    """
    
    # Intents that explicitly request human
    EXPLICIT_ESCALATION_INTENTS: Set[str] = {
        "request_human",
        "speak_to_manager",
        "talk_to_person",
        "need_help",
        "not_a_bot",
        "real_person",
        "human_please",
        "escalate",
    }
    
    # Intents indicating frustration
    FRUSTRATION_INTENTS: Set[str] = {
        "frustrated",
        "angry",
        "complaint",
        "this_is_useless",
        "not_helpful",
        "waste_of_time",
    }
    
    # Sensitive topics requiring human
    SENSITIVE_INTENTS: Set[str] = {
        "legal_question",
        "compliance_question",
        "formal_complaint",
        "refund_request",
        "contract_dispute",
        "data_deletion",
        "gdpr_request",
    }
    
    def __init__(
        self,
        frustration_threshold: int = 3,
        misunderstanding_threshold: int = 4,
        high_value_threshold: int = 100,  # company_size threshold
        name: str = "EscalationSource"
    ):
        """
        Initialize the escalation source.
        
        Args:
            frustration_threshold: Number of frustration signals to trigger escalation
            misunderstanding_threshold: Number of "unclear" intents to trigger escalation
            high_value_threshold: Company size to consider high-value lead
            name: Source name for logging
        """
        super().__init__(name)
        self._frustration_threshold = frustration_threshold
        self._misunderstanding_threshold = misunderstanding_threshold
        self._high_value_threshold = high_value_threshold
    
    def should_contribute(self, blackboard: DialogueBlackboard) -> bool:
        """
        Quick check: any escalation signals present?
        """
        if not self._enabled:
            return False
        
        intent = blackboard.current_intent
        
        # Always check for explicit escalation requests
        if intent in self.EXPLICIT_ESCALATION_INTENTS:
            return True
        
        # Always check for sensitive topics
        if intent in self.SENSITIVE_INTENTS:
            return True
        
        # Always check for frustration signals
        if intent in self.FRUSTRATION_INTENTS:
            return True
        
        # Check for repeated misunderstandings
        ctx = blackboard.get_context()
        unclear_count = ctx.intent_tracker.total_count("unclear")
        if unclear_count >= self._misunderstanding_threshold - 1:  # About to exceed
            return True
        
        return False
    
    def contribute(self, blackboard: DialogueBlackboard) -> None:
        """
        Check escalation triggers and propose if needed.
        
        Priority order:
        1. Explicit request -> immediate escalation
        2. Sensitive topic -> immediate escalation
        3. Frustration threshold -> escalation
        4. Misunderstanding threshold -> escalation
        5. High-value lead + complex question -> optional escalation
        """
        ctx = blackboard.get_context()
        intent = ctx.current_intent
        
        escalation_reason = None
        escalation_priority = Priority.HIGH
        
        # Check explicit escalation request
        if intent in self.EXPLICIT_ESCALATION_INTENTS:
            escalation_reason = "explicit_request"
            escalation_priority = Priority.CRITICAL  # Highest priority
        
        # Check sensitive topics
        elif intent in self.SENSITIVE_INTENTS:
            escalation_reason = "sensitive_topic"
            escalation_priority = Priority.CRITICAL
        
        # Check frustration signals
        elif intent in self.FRUSTRATION_INTENTS:
            frustration_count = ctx.intent_tracker.category_total("frustration")
            if frustration_count >= self._frustration_threshold:
                escalation_reason = "frustration_threshold"
        
        # Check repeated misunderstandings
        if not escalation_reason:
            unclear_count = ctx.intent_tracker.total_count("unclear")
            if unclear_count >= self._misunderstanding_threshold:
                escalation_reason = "misunderstanding_threshold"
        
        # Check high-value lead with complex question
        if not escalation_reason:
            company_size = ctx.collected_data.get("company_size")
            if company_size and isinstance(company_size, int):
                if company_size >= self._high_value_threshold:
                    # High-value lead - check if complex question
                    complex_intents = {"custom_integration", "enterprise_features", "sla_question"}
                    if intent in complex_intents:
                        escalation_reason = "high_value_complex"
        
        if not escalation_reason:
            self._log_contribution(reason="No escalation triggers met")
            return
        
        # Propose BLOCKING escalation action
        blackboard.propose_action(
            action="escalate_to_human",
            priority=escalation_priority,
            combinable=False,  # BLOCKING: stops all other processing
            reason_code=f"escalation_{escalation_reason}",
            source_name=self.name,
            metadata={
                "trigger": escalation_reason,
                "intent": intent,
                "turn_number": ctx.turn_number,
            }
        )
        
        # Propose transition to escalation state
        blackboard.propose_transition(
            next_state="human_handoff",
            priority=escalation_priority,
            reason_code=f"escalation_{escalation_reason}",
            source_name=self.name,
            metadata={
                "trigger": escalation_reason,
            }
        )
        
        self._log_contribution(
            action="escalate_to_human",
            transition="human_handoff",
            reason=f"Escalation triggered: {escalation_reason}"
        )
        
        logger.info(
            f"Human escalation triggered: reason={escalation_reason}, "
            f"intent={intent}, turn={ctx.turn_number}"
        )
ĞŸÑ€Ğ¾Ğ´Ğ¾Ğ»Ğ¶Ğ°Ñ Ñ Ğ¿ÑÑ‚Ğ¾Ğ¹ Ñ‡Ğ°ÑÑ‚ÑŒÑ â€” ConflictResolver, ProposalValidator, EventBus Ğ¸ Orchestrator.

Ğ¿Ñ€Ğ¾Ğ´Ğ¾Ğ»Ğ¶Ğ°Ğ¹
Ğ§Ğ°ÑÑ‚ÑŒ 5: ConflictResolver, ProposalValidator, EventBus Ğ¸ Orchestrator
9. ProposalValidator

# src/blackboard/proposal_validator.py

from typing import List, Dict, Any, Set, Optional
from dataclasses import dataclass
import logging

from .models import Proposal
from .enums import Priority, ProposalType

logger = logging.getLogger(__name__)


@dataclass
class ValidationError:
    """
    Represents a validation error for a proposal.
    
    Attributes:
        proposal: The proposal that failed validation
        error_code: Machine-readable error code
        message: Human-readable error message
        severity: "error" (blocks resolution) or "warning" (logged only)
    """
    proposal: Proposal
    error_code: str
    message: str
    severity: str = "error"  # "error" or "warning"
    
    def __repr__(self):
        return f"ValidationError({self.error_code}: {self.message})"


class ProposalValidator:
    """
    Validates proposals before conflict resolution.
    
    Responsibilities:
        - Validate proposal structure (required fields, types)
        - Validate action names against allowed actions
        - Validate state names against defined states
        - Validate reason codes against documented codes
        - Log warnings for non-critical issues
    
    Validation is critical for:
        - Catching configuration errors early
        - Ensuring auditability (valid reason codes)
        - Preventing runtime errors in ConflictResolver
    """
    
    def __init__(
        self,
        valid_actions: Optional[Set[str]] = None,
        valid_states: Optional[Set[str]] = None,
        valid_reason_codes: Optional[Set[str]] = None,
        strict_mode: bool = False
    ):
        """
        Initialize the validator.
        
        Args:
            valid_actions: Set of valid action names. If None, action validation is skipped.
            valid_states: Set of valid state names. If None, state validation is skipped.
            valid_reason_codes: Set of documented reason codes. If None, logs warning only.
            strict_mode: If True, treat warnings as errors.
        """
        self._valid_actions = valid_actions
        self._valid_states = valid_states
        self._valid_reason_codes = valid_reason_codes
        self._strict_mode = strict_mode
    
    def validate(self, proposals: List[Proposal]) -> List[ValidationError]:
        """
        Validate a list of proposals.
        
        Args:
            proposals: List of proposals to validate
            
        Returns:
            List of ValidationError objects (empty if all valid)
        """
        errors: List[ValidationError] = []
        
        for proposal in proposals:
            errors.extend(self._validate_proposal(proposal))
        
        # Log validation results
        error_count = sum(1 for e in errors if e.severity == "error")
        warning_count = sum(1 for e in errors if e.severity == "warning")
        
        if error_count > 0:
            logger.error(f"Proposal validation failed: {error_count} errors, {warning_count} warnings")
        elif warning_count > 0:
            logger.warning(f"Proposal validation: {warning_count} warnings")
        else:
            logger.debug(f"Proposal validation passed: {len(proposals)} proposals valid")
        
        return errors
    
    def _validate_proposal(self, proposal: Proposal) -> List[ValidationError]:
        """Validate a single proposal."""
        errors: List[ValidationError] = []
        
        # 1. Basic structure validation (from Proposal.validate())
        structure_errors = proposal.validate()
        for error_msg in structure_errors:
            errors.append(ValidationError(
                proposal=proposal,
                error_code="INVALID_STRUCTURE",
                message=error_msg,
                severity="error"
            ))
        
        # 2. Validate action names
        if proposal.type == ProposalType.ACTION and self._valid_actions is not None:
            if proposal.value not in self._valid_actions:
                errors.append(ValidationError(
                    proposal=proposal,
                    error_code="INVALID_ACTION",
                    message=f"Unknown action: '{proposal.value}'. Valid actions: {sorted(self._valid_actions)[:10]}...",
                    severity="warning" if not self._strict_mode else "error"
                ))
        
        # 3. Validate state names
        if proposal.type == ProposalType.TRANSITION and self._valid_states is not None:
            if proposal.value not in self._valid_states:
                errors.append(ValidationError(
                    proposal=proposal,
                    error_code="INVALID_STATE",
                    message=f"Unknown state: '{proposal.value}'. Valid states: {sorted(self._valid_states)[:10]}...",
                    severity="error"  # Invalid state is always an error
                ))
        
        # 4. Validate reason codes
        if self._valid_reason_codes is not None:
            if proposal.reason_code not in self._valid_reason_codes:
                errors.append(ValidationError(
                    proposal=proposal,
                    error_code="UNDOCUMENTED_REASON_CODE",
                    message=f"Undocumented reason code: '{proposal.reason_code}'",
                    severity="warning"  # Undocumented is a warning, not error
                ))
        
        # 5. Validate combinable flag consistency
        if proposal.type == ProposalType.TRANSITION and not proposal.combinable:
            errors.append(ValidationError(
                proposal=proposal,
                error_code="INVALID_COMBINABLE",
                message="TRANSITION proposals cannot have combinable=False",
                severity="error"
            ))
        
        # 6. Validate priority for blocking actions
        if proposal.type == ProposalType.ACTION and not proposal.combinable:
            if proposal.priority == Priority.LOW:
                errors.append(ValidationError(
                    proposal=proposal,
                    error_code="BLOCKING_LOW_PRIORITY",
                    message="Blocking actions (combinable=False) should not have LOW priority",
                    severity="warning"
                ))
        
        return errors
    
    def get_errors_only(self, validation_results: List[ValidationError]) -> List[ValidationError]:
        """Filter to get only errors (not warnings)."""
        return [e for e in validation_results if e.severity == "error"]
    
    def get_warnings_only(self, validation_results: List[ValidationError]) -> List[ValidationError]:
        """Filter to get only warnings (not errors)."""
        return [e for e in validation_results if e.severity == "warning"]
    
    def has_blocking_errors(self, validation_results: List[ValidationError]) -> bool:
        """Check if there are any blocking errors."""
        return any(e.severity == "error" for e in validation_results)
10. ConflictResolver

# src/blackboard/conflict_resolver.py

from typing import List, Dict, Any, Optional, Tuple
from dataclasses import dataclass, field
import logging

from .models import Proposal, ResolvedDecision
from .enums import Priority, ProposalType

logger = logging.getLogger(__name__)


@dataclass
class ResolutionTrace:
    """
    Detailed trace of the resolution process for debugging.
    
    Attributes:
        action_proposals: All action proposals received
        transition_proposals: All transition proposals received
        action_ranking: Actions sorted by priority
        transition_ranking: Transitions sorted by priority
        winning_action: Selected action proposal
        winning_transition: Selected transition proposal (may be None)
        merge_decision: Whether action and transition were merged
        blocking_reason: If action blocked transition, why
    """
    action_proposals: List[Proposal] = field(default_factory=list)
    transition_proposals: List[Proposal] = field(default_factory=list)
    action_ranking: List[Tuple[str, Priority, str]] = field(default_factory=list)
    transition_ranking: List[Tuple[str, Priority, str]] = field(default_factory=list)
    winning_action: Optional[Proposal] = None
    winning_transition: Optional[Proposal] = None
    merge_decision: str = ""
    blocking_reason: Optional[str] = None
    
    def to_dict(self) -> Dict[str, Any]:
        """Convert to dictionary for logging/serialization."""
        return {
            "action_proposals_count": len(self.action_proposals),
            "transition_proposals_count": len(self.transition_proposals),
            "action_ranking": self.action_ranking,
            "transition_ranking": self.transition_ranking,
            "winning_action": str(self.winning_action) if self.winning_action else None,
            "winning_transition": str(self.winning_transition) if self.winning_transition else None,
            "merge_decision": self.merge_decision,
            "blocking_reason": self.blocking_reason,
        }


class ConflictResolver:
    """
    Resolves conflicts between proposals from multiple Knowledge Sources.
    
    Core Algorithm:
        1. Separate proposals by type (ACTION vs TRANSITION)
        2. Sort each list by priority (CRITICAL > HIGH > NORMAL > LOW)
        3. Select winning action (highest priority)
        4. Check combinable flag:
           - If combinable=False: action BLOCKS all transitions
           - If combinable=True: action can MERGE with transition
        5. Select winning transition (if not blocked)
        6. Return ResolvedDecision with both action and next_state
    
    Key Innovation:
        The combinable flag allows actions like "answer_with_pricing" to coexist
        with transitions like "data_complete -> spin_problem". This solves the
        core problem where price questions blocked phase progression.
    
    Priority Semantics:
        CRITICAL (0): Blocking actions (rejection, escalation) - always wins
        HIGH (1): Important actions (price questions, objection handling)
        NORMAL (2): Standard processing (intent rules, data collection)
        LOW (3): Fallback actions (continue, default behavior)
    """
    
    def __init__(self, default_action: str = "continue"):
        """
        Initialize the conflict resolver.
        
        Args:
            default_action: Action to use when no action proposals exist
        """
        self._default_action = default_action
    
    def resolve(
        self,
        proposals: List[Proposal],
        current_state: str,
        data_updates: Optional[Dict[str, Any]] = None,
        flags_to_set: Optional[Dict[str, Any]] = None
    ) -> ResolvedDecision:
        """
        Resolve conflicts between proposals and produce final decision.
        
        Args:
            proposals: List of all proposals from Knowledge Sources
            current_state: Current dialogue state (used if no transition)
            data_updates: Data updates to include in decision
            flags_to_set: Flags to include in decision
            
        Returns:
            ResolvedDecision with final action, next_state, and metadata
        """
        trace = ResolutionTrace()
        
        # Step 1: Separate proposals by type
        action_proposals = [p for p in proposals if p.type == ProposalType.ACTION]
        transition_proposals = [p for p in proposals if p.type == ProposalType.TRANSITION]
        
        trace.action_proposals = action_proposals
        trace.transition_proposals = transition_proposals
        
        logger.debug(
            f"Resolving conflicts: {len(action_proposals)} actions, "
            f"{len(transition_proposals)} transitions"
        )
        
        # Step 2: Sort by priority (lower value = higher priority)
        action_proposals.sort(key=lambda p: p.priority.value)
        transition_proposals.sort(key=lambda p: p.priority.value)
        
        # Record rankings for trace
        trace.action_ranking = [
            (p.value, p.priority, p.source_name) for p in action_proposals
        ]
        trace.transition_ranking = [
            (p.value, p.priority, p.source_name) for p in transition_proposals
        ]
        
        # Step 3: Select winning action
        winning_action: Optional[Proposal] = None
        if action_proposals:
            winning_action = action_proposals[0]
            trace.winning_action = winning_action
            
            logger.debug(
                f"Winning action: {winning_action.value} "
                f"(priority={winning_action.priority.name}, "
                f"combinable={winning_action.combinable}, "
                f"source={winning_action.source_name})"
            )
        
        # Step 4: Check combinable flag and decide on transition
        winning_transition: Optional[Proposal] = None
        rejected_proposals: List[Proposal] = []
        
        if winning_action and not winning_action.combinable:
            # BLOCKING action - reject all transitions
            trace.blocking_reason = (
                f"Action '{winning_action.value}' has combinable=False, "
                f"blocking {len(transition_proposals)} transition(s)"
            )
            trace.merge_decision = "BLOCKED"
            
            rejected_proposals.extend(transition_proposals)
            rejected_proposals.extend(action_proposals[1:])  # Non-winning actions
            
            logger.debug(
                f"Blocking action detected: {winning_action.value}. "
                f"Transitions blocked: {[p.value for p in transition_proposals]}"
            )
        else:
            # COMBINABLE action (or no action) - can merge with transition
            if transition_proposals:
                winning_transition = transition_proposals[0]
                trace.winning_transition = winning_transition
                trace.merge_decision = "MERGED" if winning_action else "TRANSITION_ONLY"
                
                rejected_proposals.extend(transition_proposals[1:])  # Non-winning transitions
                
                logger.debug(
                    f"Winning transition: {winning_transition.value} "
                    f"(priority={winning_transition.priority.name}, "
                    f"source={winning_transition.source_name})"
                )
            else:
                trace.merge_decision = "ACTION_ONLY" if winning_action else "NO_PROPOSALS"
            
            if winning_action:
                rejected_proposals.extend(action_proposals[1:])  # Non-winning actions
        
        # Step 5: Build reason codes
        reason_codes: List[str] = []
        if winning_action:
            reason_codes.append(winning_action.reason_code)
        if winning_transition:
            reason_codes.append(winning_transition.reason_code)
        
        # Step 6: Construct final decision
        final_action = winning_action.value if winning_action else self._default_action
        next_state = winning_transition.value if winning_transition else current_state
        
        decision = ResolvedDecision(
            action=final_action,
            next_state=next_state,
            reason_codes=reason_codes,
            rejected_proposals=rejected_proposals,
            resolution_trace=trace.to_dict(),
            data_updates=data_updates or {},
            flags_to_set=flags_to_set or {},
        )
        
        logger.info(
            f"Conflict resolved: action='{final_action}', next_state='{next_state}', "
            f"merge={trace.merge_decision}, rejected={len(rejected_proposals)}"
        )
        
        return decision
    
    def resolve_with_fallback(
        self,
        proposals: List[Proposal],
        current_state: str,
        fallback_transition: Optional[str] = None,
        data_updates: Optional[Dict[str, Any]] = None,
        flags_to_set: Optional[Dict[str, Any]] = None
    ) -> ResolvedDecision:
        """
        Resolve conflicts with a fallback transition (e.g., "any" transition).
        
        This method first tries normal resolution. If no transition is selected
        and a fallback is provided, it applies the fallback transition.
        
        Args:
            proposals: List of all proposals from Knowledge Sources
            current_state: Current dialogue state
            fallback_transition: Fallback transition target (e.g., from "any" trigger)
            data_updates: Data updates to include in decision
            flags_to_set: Flags to include in decision
            
        Returns:
            ResolvedDecision with final action, next_state, and metadata
        """
        decision = self.resolve(
            proposals=proposals,
            current_state=current_state,
            data_updates=data_updates,
            flags_to_set=flags_to_set,
        )
        
        # Apply fallback if no transition was selected and fallback is available
        if decision.next_state == current_state and fallback_transition:
            # Check if action allows fallback (must be combinable or no action)
            action_blocked = any(
                p.type == ProposalType.ACTION and not p.combinable
                for p in proposals
                if p.value == decision.action
            )
            
            if not action_blocked:
                logger.debug(
                    f"Applying fallback transition: {fallback_transition}"
                )
                decision.next_state = fallback_transition
                decision.reason_codes.append("fallback_any_transition")
                decision.resolution_trace["fallback_applied"] = True
        
        return decision
11. DialogueEventBus

# src/blackboard/event_bus.py

from typing import Dict, Any, List, Callable, Optional
from dataclasses import dataclass, field
from datetime import datetime
from enum import Enum, auto
import logging
import threading
from queue import Queue

logger = logging.getLogger(__name__)


class EventType(Enum):
    """Types of events emitted by the Blackboard system."""
    TURN_STARTED = auto()
    SOURCE_CONTRIBUTED = auto()
    PROPOSAL_VALIDATED = auto()
    CONFLICT_RESOLVED = auto()
    DECISION_COMMITTED = auto()
    STATE_TRANSITIONED = auto()
    ERROR_OCCURRED = auto()


@dataclass
class DialogueEvent:
    """
    Base class for all dialogue events.
    
    Attributes:
        event_type: Type of the event
        timestamp: When the event occurred
        turn_number: Dialogue turn number
        data: Event-specific data
    """
    event_type: EventType
    timestamp: datetime = field(default_factory=datetime.now)
    turn_number: int = 0
    data: Dict[str, Any] = field(default_factory=dict)
    
    def to_dict(self) -> Dict[str, Any]:
        """Convert to dictionary for serialization."""
        return {
            "event_type": self.event_type.name,
            "timestamp": self.timestamp.isoformat(),
            "turn_number": self.turn_number,
            "data": self.data,
        }


@dataclass
class TurnStartedEvent(DialogueEvent):
    """Event emitted when a new turn begins."""
    
    def __init__(self, turn_number: int, intent: str, state: str, **kwargs):
        super().__init__(
            event_type=EventType.TURN_STARTED,
            turn_number=turn_number,
            data={
                "intent": intent,
                "state": state,
                **kwargs
            }
        )


@dataclass
class SourceContributedEvent(DialogueEvent):
    """Event emitted when a Knowledge Source contributes proposals."""
    
    def __init__(
        self,
        turn_number: int,
        source_name: str,
        proposals_count: int,
        proposals_summary: List[str],
        execution_time_ms: float,
        **kwargs
    ):
        super().__init__(
            event_type=EventType.SOURCE_CONTRIBUTED,
            turn_number=turn_number,
            data={
                "source_name": source_name,
                "proposals_count": proposals_count,
                "proposals_summary": proposals_summary,
                "execution_time_ms": execution_time_ms,
                **kwargs
            }
        )


@dataclass
class ProposalValidatedEvent(DialogueEvent):
    """Event emitted after proposal validation."""
    
    def __init__(
        self,
        turn_number: int,
        valid_count: int,
        error_count: int,
        warning_count: int,
        errors: List[str],
        **kwargs
    ):
        super().__init__(
            event_type=EventType.PROPOSAL_VALIDATED,
            turn_number=turn_number,
            data={
                "valid_count": valid_count,
                "error_count": error_count,
                "warning_count": warning_count,
                "errors": errors,
                **kwargs
            }
        )


@dataclass
class ConflictResolvedEvent(DialogueEvent):
    """Event emitted after conflict resolution."""
    
    def __init__(
        self,
        turn_number: int,
        winning_action: str,
        winning_transition: Optional[str],
        rejected_count: int,
        merge_decision: str,
        resolution_time_ms: float,
        **kwargs
    ):
        super().__init__(
            event_type=EventType.CONFLICT_RESOLVED,
            turn_number=turn_number,
            data={
                "winning_action": winning_action,
                "winning_transition": winning_transition,
                "rejected_count": rejected_count,
                "merge_decision": merge_decision,
                "resolution_time_ms": resolution_time_ms,
                **kwargs
            }
        )


@dataclass
class DecisionCommittedEvent(DialogueEvent):
    """Event emitted when decision is committed to blackboard."""
    
    def __init__(
        self,
        turn_number: int,
        action: str,
        next_state: str,
        reason_codes: List[str],
        **kwargs
    ):
        super().__init__(
            event_type=EventType.DECISION_COMMITTED,
            turn_number=turn_number,
            data={
                "action": action,
                "next_state": next_state,
                "reason_codes": reason_codes,
                **kwargs
            }
        )


@dataclass
class StateTransitionedEvent(DialogueEvent):
    """Event emitted when state actually changes."""
    
    def __init__(
        self,
        turn_number: int,
        from_state: str,
        to_state: str,
        trigger_reason: str,
        **kwargs
    ):
        super().__init__(
            event_type=EventType.STATE_TRANSITIONED,
            turn_number=turn_number,
            data={
                "from_state": from_state,
                "to_state": to_state,
                "trigger_reason": trigger_reason,
                **kwargs
            }
        )


@dataclass
class ErrorOccurredEvent(DialogueEvent):
    """Event emitted when an error occurs."""
    
    def __init__(
        self,
        turn_number: int,
        error_type: str,
        error_message: str,
        component: str,
        **kwargs
    ):
        super().__init__(
            event_type=EventType.ERROR_OCCURRED,
            turn_number=turn_number,
            data={
                "error_type": error_type,
                "error_message": error_message,
                "component": component,
                **kwargs
            }
        )


# Type alias for event handlers
EventHandler = Callable[[DialogueEvent], None]


class DialogueEventBus:
    """
    Event bus for observability and analytics in the Blackboard system.
    
    Responsibilities:
        - Publish events from Blackboard components
        - Allow subscribers to listen for specific event types
        - Support async processing to avoid blocking main flow
        - Provide event history for debugging
    
    Subscribers can include:
        - MetricsCollector: records metrics for monitoring
        - DebugLogger: detailed logging for debugging
        - AnalyticsTracker: business analytics
        - AlertManager: alerts on anomalies
    """
    
    def __init__(
        self,
        async_mode: bool = False,
        history_size: int = 100
    ):
        """
        Initialize the event bus.
        
        Args:
            async_mode: If True, process events asynchronously
            history_size: Number of recent events to keep in history
        """
        self._handlers: Dict[EventType, List[EventHandler]] = {
            event_type: [] for event_type in EventType
        }
        self._global_handlers: List[EventHandler] = []
        self._history: List[DialogueEvent] = []
        self._history_size = history_size
        self._async_mode = async_mode
        self._event_queue: Optional[Queue] = Queue() if async_mode else None
        self._worker_thread: Optional[threading.Thread] = None
        self._running = False
        
        if async_mode:
            self._start_worker()
    
    def subscribe(
        self,
        event_type: EventType,
        handler: EventHandler
    ) -> None:
        """
        Subscribe to a specific event type.
        
        Args:
            event_type: Type of event to subscribe to
            handler: Callback function to handle the event
        """
        self._handlers[event_type].append(handler)
        logger.debug(f"Handler subscribed to {event_type.name}")
    
    def subscribe_all(self, handler: EventHandler) -> None:
        """
        Subscribe to all event types.
        
        Args:
            handler: Callback function to handle all events
        """
        self._global_handlers.append(handler)
        logger.debug("Global handler subscribed to all events")
    
    def unsubscribe(
        self,
        event_type: EventType,
        handler: EventHandler
    ) -> None:
        """
        Unsubscribe from a specific event type.
        
        Args:
            event_type: Type of event to unsubscribe from
            handler: Handler to remove
        """
        if handler in self._handlers[event_type]:
            self._handlers[event_type].remove(handler)
            logger.debug(f"Handler unsubscribed from {event_type.name}")
    
    def emit(self, event: DialogueEvent) -> None:
        """
        Emit an event to all subscribers.
        
        Args:
            event: Event to emit
        """
        # Add to history
        self._history.append(event)
        if len(self._history) > self._history_size:
            self._history.pop(0)
        
        if self._async_mode and self._event_queue:
            # Queue for async processing
            self._event_queue.put(event)
        else:
            # Process synchronously
            self._process_event(event)
    
    def _process_event(self, event: DialogueEvent) -> None:
        """Process an event by calling all handlers."""
        # Call type-specific handlers
        for handler in self._handlers[event.event_type]:
            try:
                handler(event)
            except Exception as e:
                logger.error(
                    f"Error in event handler for {event.event_type.name}: {e}"
                )
        
        # Call global handlers
        for handler in self._global_handlers:
            try:
                handler(event)
            except Exception as e:
                logger.error(f"Error in global event handler: {e}")
    
    def _start_worker(self) -> None:
        """Start the async worker thread."""
        self._running = True
        self._worker_thread = threading.Thread(
            target=self._worker_loop,
            daemon=True
        )
        self._worker_thread.start()
        logger.debug("Event bus async worker started")
    
    def _worker_loop(self) -> None:
        """Worker loop for async event processing."""
        while self._running:
            try:
                event = self._event_queue.get(timeout=1.0)
                self._process_event(event)
            except Exception:
                pass  # Timeout, continue loop
    
    def stop(self) -> None:
        """Stop the async worker."""
        self._running = False
        if self._worker_thread:
            self._worker_thread.join(timeout=2.0)
            logger.debug("Event bus async worker stopped")
    
    def get_history(
        self,
        event_type: Optional[EventType] = None,
        limit: int = 10
    ) -> List[DialogueEvent]:
        """
        Get recent events from history.
        
        Args:
            event_type: Filter by event type (None for all)
            limit: Maximum number of events to return
            
        Returns:
            List of recent events (most recent last)
        """
        events = self._history
        
        if event_type:
            events = [e for e in events if e.event_type == event_type]
        
        return events[-limit:]
    
    def clear_history(self) -> None:
        """Clear event history."""
        self._history.clear()


# === Pre-built Subscribers ===

class MetricsCollector:
    """
    Subscriber that collects metrics from events.
    
    Metrics collected:
        - Turn count
        - Action distribution
        - Transition distribution
        - Source contribution counts
        - Resolution times
        - Error rates
    """
    
    def __init__(self):
        self.metrics: Dict[str, Any] = {
            "turn_count": 0,
            "action_counts": {},
            "transition_counts": {},
            "source_contribution_counts": {},
            "total_resolution_time_ms": 0,
            "error_count": 0,
            "state_loop_count": 0,
        }
    
    def handle_event(self, event: DialogueEvent) -> None:
        """Handle an event and update metrics."""
        if event.event_type == EventType.TURN_STARTED:
            self.metrics["turn_count"] += 1
        
        elif event.event_type == EventType.SOURCE_CONTRIBUTED:
            source = event.data.get("source_name", "unknown")
            if source not in self.metrics["source_contribution_counts"]:
                self.metrics["source_contribution_counts"][source] = 0
            self.metrics["source_contribution_counts"][source] += 1
        
        elif event.event_type == EventType.CONFLICT_RESOLVED:
            action = event.data.get("winning_action", "unknown")
            if action not in self.metrics["action_counts"]:
                self.metrics["action_counts"][action] = 0
            self.metrics["action_counts"][action] += 1
            
            self.metrics["total_resolution_time_ms"] += event.data.get(
                "resolution_time_ms", 0
            )
        
        elif event.event_type == EventType.STATE_TRANSITIONED:
            from_state = event.data.get("from_state")
            to_state = event.data.get("to_state")
            
            transition_key = f"{from_state}->{to_state}"
            if transition_key not in self.metrics["transition_counts"]:
                self.metrics["transition_counts"][transition_key] = 0
            self.metrics["transition_counts"][transition_key] += 1
            
            # Detect state loops
            if from_state == to_state:
                self.metrics["state_loop_count"] += 1
        
        elif event.event_type == EventType.ERROR_OCCURRED:
            self.metrics["error_count"] += 1
    
    def get_metrics(self) -> Dict[str, Any]:
        """Get current metrics."""
        return dict(self.metrics)
    
    def reset(self) -> None:
        """Reset all metrics."""
        self.metrics = {
            "turn_count": 0,
            "action_counts": {},
            "transition_counts": {},
            "source_contribution_counts": {},
            "total_resolution_time_ms": 0,
            "error_count": 0,
            "state_loop_count": 0,
        }


class DebugLogger:
    """
    Subscriber that logs detailed debug information.
    """
    
    def __init__(self, log_level: int = logging.DEBUG):
        self._logger = logging.getLogger("blackboard.debug")
        self._log_level = log_level
    
    def handle_event(self, event: DialogueEvent) -> None:
        """Log event details."""
        self._logger.log(
            self._log_level,
            f"[Turn {event.turn_number}] {event.event_type.name}: {event.data}"
        )
12. DialogueOrchestrator

# src/blackboard/orchestrator.py

from typing import List, Dict, Any, Optional, Tuple, Type
from datetime import datetime
import logging
import time

from .blackboard import DialogueBlackboard
from .knowledge_source import KnowledgeSource
from .conflict_resolver import ConflictResolver
from .proposal_validator import ProposalValidator, ValidationError
from .event_bus import (
    DialogueEventBus,
    TurnStartedEvent,
    SourceContributedEvent,
    ProposalValidatedEvent,
    ConflictResolvedEvent,
    DecisionCommittedEvent,
    StateTransitionedEvent,
    ErrorOccurredEvent,
)
from .models import ResolvedDecision
from .enums import Priority

# Hexagonal Architecture: Import protocols (ports)
from .protocols import (
    IStateMachine,
    IFlowConfig,
    TenantConfig,
    DEFAULT_TENANT,
)

# Import SourceRegistry (Plugin System)
from .source_registry import SourceRegistry, register_builtin_sources

logger = logging.getLogger(__name__)

# Register built-in sources on module import
register_builtin_sources()


class DialogueOrchestrator:
    """
    Main coordinator for the Dialogue Blackboard System.

    Hexagonal Architecture:
        Orchestrator is the APPLICATION LAYER that coordinates domain logic.
        It depends on PROTOCOLS (ports) rather than concrete implementations:
        - IStateMachine: input port for state management
        - IFlowConfig: input port for configuration
        - IContextEnvelope: input port for context data

    Responsibilities:
        - Initialize and manage Knowledge Sources
        - Coordinate the turn processing pipeline
        - Handle validation and error recovery
        - Emit events for observability

    Multi-Tenancy:
        Supports tenant-specific configuration via TenantConfig.
        Each tenant can have custom feature flags, persona limits, etc.

    Pipeline:
        1. begin_turn() - Initialize blackboard for new turn
        2. Knowledge Sources contribute proposals
        3. Validate proposals
        4. Resolve conflicts
        5. Commit decision
        6. Return result to caller (SalesBot)

    Usage:
        orchestrator = DialogueOrchestrator(state_machine, flow_config)
        decision = orchestrator.process_turn(intent, extracted_data, context_envelope)
        # decision.action, decision.next_state, decision.reason_codes
    """

    def __init__(
        self,
        state_machine: 'IStateMachine',  # Protocol type (Hexagonal Architecture port)
        flow_config: 'IFlowConfig',       # Protocol type (Hexagonal Architecture port)
        event_bus: Optional[DialogueEventBus] = None,
        enable_validation: bool = True,
        strict_validation: bool = False,
        persona_limits: Optional[Dict[str, Dict[str, int]]] = None,
        tenant_config: Optional['TenantConfig'] = None,  # Multi-tenancy support
    ):
        """
        Initialize the orchestrator.

        Args:
            state_machine: State machine implementing IStateMachine protocol
            flow_config: Flow configuration implementing IFlowConfig protocol
            event_bus: Event bus for observability (created if not provided)
            enable_validation: Whether to validate proposals
            strict_validation: Whether to treat warnings as errors
            persona_limits: Custom persona limits for ObjectionGuardSource
            tenant_config: Tenant-specific configuration (uses DEFAULT_TENANT if not provided)
        """
        self._state_machine = state_machine
        self._flow_config = flow_config
        self._tenant_config = tenant_config or DEFAULT_TENANT

        # Initialize blackboard with tenant config
        self._blackboard = DialogueBlackboard(
            state_machine=state_machine,
            flow_config=flow_config,
            tenant_config=self._tenant_config,
        )
        
        # Initialize event bus
        self._event_bus = event_bus or DialogueEventBus()
        
        # Initialize validator
        self._enable_validation = enable_validation
        self._validator = ProposalValidator(
            valid_states=set(flow_config.states.keys()) if hasattr(flow_config, 'states') else None,
            strict_mode=strict_validation,
        )
        
        # Initialize conflict resolver
        self._resolver = ConflictResolver(default_action="continue")
        
        # Initialize Knowledge Sources via Registry (Plugin System)
        # Sources are created in priority_order from SourceRegistry
        # Configuration can enable/disable individual sources
        source_configs = {
            "ObjectionGuardSource": {"persona_limits": persona_limits},
        }

        self._sources: List[KnowledgeSource] = SourceRegistry.create_sources(
            config=self._get_sources_config(),
            source_configs=source_configs,
        )

        logger.info(
            f"DialogueOrchestrator initialized with {len(self._sources)} sources: "
            f"{[s.name for s in self._sources]}"
        )

    def _get_sources_config(self) -> Dict[str, Any]:
        """
        Get sources configuration from flow_config or constants.

        Returns:
            Dict with 'sources' key containing per-source enabled flags
        """
        # Try to get from flow_config
        if hasattr(self._flow_config, 'constants'):
            return self._flow_config.constants.get('blackboard', {})
        return {}
    
    @property
    def blackboard(self) -> DialogueBlackboard:
        """Get the blackboard instance."""
        return self._blackboard
    
    @property
    def event_bus(self) -> DialogueEventBus:
        """Get the event bus instance."""
        return self._event_bus
    
    @property
    def sources(self) -> List[KnowledgeSource]:
        """Get list of Knowledge Sources."""
        return list(self._sources)
    
    def add_source(self, source: KnowledgeSource) -> None:
        """
        Add a new Knowledge Source.
        
        Args:
            source: Knowledge Source to add
        """
        self._sources.append(source)
        logger.info(f"Added Knowledge Source: {source.name}")
    
    def remove_source(self, source_name: str) -> bool:
        """
        Remove a Knowledge Source by name.
        
        Args:
            source_name: Name of source to remove
            
        Returns:
            True if source was removed, False if not found
        """
        for source in self._sources:
            if source.name == source_name:
                self._sources.remove(source)
                logger.info(f"Removed Knowledge Source: {source_name}")
                return True
        return False
    
    def process_turn(
        self,
        intent: str,
        extracted_data: Dict[str, Any],
        context_envelope: Optional[Any] = None,
    ) -> ResolvedDecision:
        """
        Process a dialogue turn through the Blackboard system.
        
        This is the main entry point, replacing StateMachine.apply_rules().
        
        Args:
            intent: Classified intent for this turn
            extracted_data: Data extracted from user message
            context_envelope: Full context envelope (Phase 5)
            
        Returns:
            ResolvedDecision with action, next_state, and metadata
        """
        turn_start_time = time.time()
        turn_number = self._blackboard._intent_tracker.turn_number + 1
        current_state = self._state_machine.state
        
        try:
            # === STEP 1: Begin Turn ===
            self._blackboard.begin_turn(
                intent=intent,
                extracted_data=extracted_data,
                context_envelope=context_envelope,
            )
            
            self._event_bus.emit(TurnStartedEvent(
                turn_number=turn_number,
                intent=intent,
                state=current_state,
            ))
            
            logger.debug(
                f"Turn {turn_number} started: intent={intent}, state={current_state}"
            )
            
            # === STEP 2: Knowledge Sources Contribute ===
            for source in self._sources:
                source_start_time = time.time()
                
                # Check if source should contribute
                if not source.should_contribute(self._blackboard):
                    logger.debug(f"Source {source.name} skipped (should_contribute=False)")
                    continue
                
                # Let source contribute
                try:
                    source.contribute(self._blackboard)
                except Exception as e:
                    logger.error(f"Error in source {source.name}: {e}")
                    self._event_bus.emit(ErrorOccurredEvent(
                        turn_number=turn_number,
                        error_type=type(e).__name__,
                        error_message=str(e),
                        component=source.name,
                    ))
                    continue
                
                source_time_ms = (time.time() - source_start_time) * 1000
                
                # Get proposals from this source
                proposals_summary = [
                    str(p) for p in self._blackboard.get_proposals()
                    if p.source_name == source.name
                ]
                
                self._event_bus.emit(SourceContributedEvent(
                    turn_number=turn_number,
                    source_name=source.name,
                    proposals_count=len(proposals_summary),
                    proposals_summary=proposals_summary,
                    execution_time_ms=source_time_ms,
                ))
            
            # === STEP 3: Validate Proposals ===
            proposals = self._blackboard.get_proposals()
            validation_errors: List[ValidationError] = []
            
            if self._enable_validation:
                validation_errors = self._validator.validate(proposals)
                
                error_count = len(self._validator.get_errors_only(validation_errors))
                warning_count = len(self._validator.get_warnings_only(validation_errors))
                
                self._event_bus.emit(ProposalValidatedEvent(
                    turn_number=turn_number,
                    valid_count=len(proposals) - error_count,
                    error_count=error_count,
                    warning_count=warning_count,
                    errors=[str(e) for e in validation_errors],
                ))
                
                # Handle blocking validation errors
                if self._validator.has_blocking_errors(validation_errors):
                    logger.error(
                        f"Blocking validation errors: {validation_errors}"
                    )
                    # Return safe fallback decision
                    return self._create_fallback_decision(
                        current_state=current_state,
                        reason="validation_error",
                        turn_number=turn_number,
                    )
            
            # === STEP 4: Resolve Conflicts ===
            resolve_start_time = time.time()
            
            # Get fallback transition (from "any" trigger)
            fallback_transition = self._get_fallback_transition()
            
            decision = self._resolver.resolve_with_fallback(
                proposals=proposals,
                current_state=current_state,
                fallback_transition=fallback_transition,
                data_updates=self._blackboard.get_data_updates(),
                flags_to_set=self._blackboard.get_flags_to_set(),
            )
            
            resolve_time_ms = (time.time() - resolve_start_time) * 1000
            
            self._event_bus.emit(ConflictResolvedEvent(
                turn_number=turn_number,
                winning_action=decision.action,
                winning_transition=decision.next_state if decision.next_state != current_state else None,
                rejected_count=len(decision.rejected_proposals),
                merge_decision=decision.resolution_trace.get("merge_decision", "unknown"),
                resolution_time_ms=resolve_time_ms,
            ))
            
            # === STEP 5: Commit Decision ===
            self._blackboard.commit_decision(decision)

            self._event_bus.emit(DecisionCommittedEvent(
                turn_number=turn_number,
                action=decision.action,
                next_state=decision.next_state,
                reason_codes=decision.reason_codes,
            ))

            # Emit state transition event if state changed
            state_changed = decision.next_state != current_state
            if state_changed:
                self._event_bus.emit(StateTransitionedEvent(
                    turn_number=turn_number,
                    from_state=current_state,
                    to_state=decision.next_state,
                    trigger_reason=", ".join(decision.reason_codes),
                ))

            # === STEP 6: Apply Side Effects (CRITICAL for bot.py compatibility) ===
            # Ğ­Ñ‚Ğ¸ Ğ¿Ğ¾Ğ±Ğ¾Ñ‡Ğ½Ñ‹Ğµ ÑÑ„Ñ„ĞµĞºÑ‚Ñ‹ Ñ€Ğ°Ğ½ĞµĞµ Ğ²Ñ‹Ğ¿Ğ¾Ğ»Ğ½ÑĞ»Ğ¸ÑÑŒ Ğ² state_machine.process()
            # Ğ¸ ĞĞ‘Ğ¯Ğ—ĞĞ¢Ğ•Ğ›Ğ¬ĞĞ« Ğ´Ğ»Ñ ĞºĞ¾Ñ€Ñ€ĞµĞºÑ‚Ğ½Ğ¾Ğ¹ Ñ€Ğ°Ğ±Ğ¾Ñ‚Ñ‹ bot.py
            self._apply_side_effects(decision, current_state, state_changed)

            # === STEP 7: Fill Compatibility Fields ===
            # bot.py Ğ¾Ğ¶Ğ¸Ğ´Ğ°ĞµÑ‚ Ğ¿Ğ¾Ğ»Ğ½Ñ‹Ğ¹ sm_result dict Ñ ÑÑ‚Ğ¸Ğ¼Ğ¸ Ğ¿Ğ¾Ğ»ÑĞ¼Ğ¸
            self._fill_compatibility_fields(decision, current_state)

            turn_time_ms = (time.time() - turn_start_time) * 1000

            logger.info(
                f"Turn {turn_number} completed in {turn_time_ms:.1f}ms: "
                f"action={decision.action}, next_state={decision.next_state}"
            )

            return decision
            
        except Exception as e:
            logger.exception(f"Error processing turn {turn_number}: {e}")
            
            self._event_bus.emit(ErrorOccurredEvent(
                turn_number=turn_number,
                error_type=type(e).__name__,
                error_message=str(e),
                component="DialogueOrchestrator",
            ))
            
            # Return safe fallback
            return self._create_fallback_decision(
                current_state=current_state,
                reason="processing_error",
                turn_number=turn_number,
            )
    
    def _get_fallback_transition(self) -> Optional[str]:
        """
        Get fallback transition from "any" trigger in current state.
        
        Returns:
            Target state for "any" transition, or None
        """
        ctx = self._blackboard.get_context()
        return ctx.get_transition("any")
    
    def _create_fallback_decision(
        self,
        current_state: str,
        reason: str,
        turn_number: int,
    ) -> ResolvedDecision:
        """
        Create a safe fallback decision when processing fails.
        
        Args:
            current_state: Current dialogue state
            reason: Reason for fallback
            turn_number: Current turn number
            
        Returns:
            Safe ResolvedDecision that continues conversation
        """
        logger.warning(
            f"Creating fallback decision: reason={reason}, state={current_state}"
        )
        
        fallback = ResolvedDecision(
            action="continue_current_goal",
            next_state=current_state,  # Stay in current state
            reason_codes=[f"fallback_{reason}"],
            rejected_proposals=[],
            resolution_trace={"fallback": True, "reason": reason},
        )
        # Fill compatibility fields even for fallback
        self._fill_compatibility_fields(fallback, current_state)
        return fallback

    # =========================================================================
    # COMPATIBILITY METHODS (Ğ´Ğ»Ñ Ğ¸Ğ½Ñ‚ĞµĞ³Ñ€Ğ°Ñ†Ğ¸Ğ¸ Ñ bot.py)
    # =========================================================================

    def _apply_side_effects(
        self,
        decision: ResolvedDecision,
        prev_state: str,
        state_changed: bool,
    ) -> None:
        """
        Apply side effects that were previously in state_machine.process().

        ĞšĞ Ğ˜Ğ¢Ğ˜Ğ§Ğ•Ğ¡ĞšĞ˜ Ğ’ĞĞ–ĞĞ: Ğ­Ñ‚Ğ¸ Ğ¿Ğ¾Ğ±Ğ¾Ñ‡Ğ½Ñ‹Ğµ ÑÑ„Ñ„ĞµĞºÑ‚Ñ‹ Ğ½ĞµĞ¾Ğ±Ñ…Ğ¾Ğ´Ğ¸Ğ¼Ñ‹ Ğ´Ğ»Ñ ĞºĞ¾Ñ€Ñ€ĞµĞºÑ‚Ğ½Ğ¾Ğ¹ Ñ€Ğ°Ğ±Ğ¾Ñ‚Ñ‹:
        1. IntentTracker.record() â€” Ğ¸ÑÑ‚Ğ¾Ñ€Ğ¸Ñ Ğ¸Ğ½Ñ‚ĞµĞ½Ñ‚Ğ¾Ğ² Ğ´Ğ»Ñ conditions
        2. state update â€” Ğ¿ĞµÑ€ĞµÑ…Ğ¾Ğ´ ÑĞ¾ÑÑ‚Ğ¾ÑĞ½Ğ¸Ñ
        3. last_action update â€” Ğ´Ğ»Ñ ĞºĞ¾Ğ½Ñ‚ĞµĞºÑÑ‚Ğ½Ğ¾Ğ¹ ĞºĞ»Ğ°ÑÑĞ¸Ñ„Ğ¸ĞºĞ°Ñ†Ğ¸Ğ¸
        4. current_phase update â€” Ğ´Ğ»Ñ SPIN-Ñ„Ğ°Ğ·Ñ‹
        5. on_enter flags â€” Ñ„Ğ»Ğ°Ğ³Ğ¸ Ğ¿Ñ€Ğ¸ Ğ²Ñ…Ğ¾Ğ´Ğµ Ğ² ÑĞ¾ÑÑ‚Ğ¾ÑĞ½Ğ¸Ğµ

        OUT OF SCOPE (Ğ²Ñ‹Ğ·Ñ‹Ğ²Ğ°ÑÑ‚ÑÑ Ğ½Ğ°Ğ¿Ñ€ÑĞ¼ÑƒÑ Ğ¸Ğ· bot.py):
        - increment_turn() â€” Ğ²Ñ‹Ğ·Ñ‹Ğ²Ğ°ĞµÑ‚ÑÑ bot.py ÑÑ‚Ñ€Ğ¾ĞºĞ° 637 Ğ”Ğ process_turn()
                             Ğ´Ğ»Ñ tracking disambiguation cooldown
        - disambiguation methods â€” enter/exit/resolve Ğ²Ñ‹Ğ·Ñ‹Ğ²Ğ°ÑÑ‚ÑÑ Ğ½Ğ°Ğ¿Ñ€ÑĞ¼ÑƒÑ
        - reset() â€” Ğ²Ñ‹Ğ·Ñ‹Ğ²Ğ°ĞµÑ‚ÑÑ Ğ´Ğ»Ñ Ğ½Ğ¾Ğ²Ğ¾Ğ³Ğ¾ Ñ€Ğ°Ğ·Ğ³Ğ¾Ğ²Ğ¾Ñ€Ğ°

        ĞŸĞĞ Ğ¯Ğ”ĞĞš Ğ’Ğ«Ğ—ĞĞ’ĞĞ’ Ğ² bot.py:
        1. state_machine.increment_turn()           # bot.py line 637
        2. state_machine.state = skip_next_state    # bot.py line 743 (fallback)
        3. collected_data["competitor"] = ...       # bot.py lines 773-776
        4. orchestrator.process_turn()              # bot.py â†’ Ğ¢Ğ£Ğ¢ ĞœĞ«
        5. state_machine.state = policy_next_state  # bot.py line 944 (override)

        Args:
            decision: The resolved decision
            prev_state: State before this turn
            state_changed: Whether state transition occurred
        """
        # 1. Update state machine state
        self._state_machine.state = decision.next_state

        # 2. Update last_action for context
        self._state_machine.last_action = decision.action

        # 3. Update current phase from state config
        next_config = self._flow_config.states.get(decision.next_state, {})
        self._state_machine.current_phase = (
            next_config.get("phase") or next_config.get("spin_phase")
        )

        # 4. Apply data_updates to collected_data
        if decision.data_updates:
            self._state_machine.update_data(decision.data_updates)

        # 5. Apply on_enter flags when state changes
        if state_changed:
            on_enter_flags = self._flow_config.get_state_on_enter_flags(decision.next_state)
            for flag_name, flag_value in on_enter_flags.items():
                self._state_machine.collected_data[flag_name] = flag_value

            # 6. Apply on_enter action override if configured
            on_enter = next_config.get("on_enter")
            if on_enter:
                on_enter_action = (
                    on_enter.get("action") if isinstance(on_enter, dict) else on_enter
                )
                if on_enter_action:
                    decision.action = on_enter_action
                    logger.debug(f"on_enter action override: {on_enter_action}")

        # 7. Apply flags_to_set from decision
        if decision.flags_to_set:
            for flag_name, flag_value in decision.flags_to_set.items():
                self._state_machine.collected_data[flag_name] = flag_value

    def _fill_compatibility_fields(
        self,
        decision: ResolvedDecision,
        prev_state: str,
    ) -> None:
        """
        Fill compatibility fields in ResolvedDecision for bot.py.

        bot.py Ğ¾Ğ¶Ğ¸Ğ´Ğ°ĞµÑ‚ ÑĞ»ĞµĞ´ÑƒÑÑ‰Ğ¸Ğµ Ğ¿Ğ¾Ğ»Ñ Ğ² sm_result:
        - prev_state: Ğ´Ğ»Ñ Ğ¼ĞµÑ‚Ñ€Ğ¸Ğº Ğ¸ Ğ¾Ğ¿Ñ€ĞµĞ´ĞµĞ»ĞµĞ½Ğ¸Ñ Ğ¸Ğ·Ğ¼ĞµĞ½ĞµĞ½Ğ¸Ñ ÑĞ¾ÑÑ‚Ğ¾ÑĞ½Ğ¸Ñ
        - goal: Ğ´Ğ»Ñ ĞºĞ¾Ğ½Ñ‚ĞµĞºÑÑ‚Ğ° Ğ³ĞµĞ½ĞµÑ€Ğ°Ñ‚Ğ¾Ñ€Ğ°
        - collected_data: Ğ¿Ğ¾Ğ»Ğ½Ñ‹Ğ¹ dict Ğ¿Ğ¾ÑĞ»Ğµ Ğ¿Ñ€Ğ¸Ğ¼ĞµĞ½ĞµĞ½Ğ¸Ñ updates
        - missing_data: ÑĞ¿Ğ¸ÑĞ¾Ğº Ğ½ĞµĞ´Ğ¾ÑÑ‚Ğ°ÑÑ‰Ğ¸Ñ… Ğ¾Ğ±ÑĞ·Ğ°Ñ‚ĞµĞ»ÑŒĞ½Ñ‹Ñ… Ğ¿Ğ¾Ğ»ĞµĞ¹
        - optional_data: ÑĞ¿Ğ¸ÑĞ¾Ğº Ğ½ĞµĞ´Ğ¾ÑÑ‚Ğ°ÑÑ‰Ğ¸Ñ… Ğ¾Ğ¿Ñ†Ğ¸Ğ¾Ğ½Ğ°Ğ»ÑŒĞ½Ñ‹Ñ… Ğ¿Ğ¾Ğ»ĞµĞ¹
        - is_final: ÑĞ²Ğ»ÑĞµÑ‚ÑÑ Ğ»Ğ¸ ÑĞ¾ÑÑ‚Ğ¾ÑĞ½Ğ¸Ğµ Ñ„Ğ¸Ğ½Ğ°Ğ»ÑŒĞ½Ñ‹Ğ¼
        - spin_phase: Ñ‚ĞµĞºÑƒÑ‰Ğ°Ñ SPIN-Ñ„Ğ°Ğ·Ğ°
        - circular_flow: ÑÑ‚Ğ°Ñ‚Ğ¸ÑÑ‚Ğ¸ĞºĞ° CircularFlowManager
        - objection_flow: ÑÑ‚Ğ°Ñ‚Ğ¸ÑÑ‚Ğ¸ĞºĞ° Ğ²Ğ¾Ğ·Ñ€Ğ°Ğ¶ĞµĞ½Ğ¸Ğ¹

        Args:
            decision: ResolvedDecision to fill
            prev_state: State before this turn
        """
        # Get state configuration
        next_config = self._flow_config.states.get(decision.next_state, {})
        required = next_config.get("required_data", [])
        optional = next_config.get("optional_data", [])

        # Fill compatibility fields
        decision.prev_state = prev_state
        decision.goal = next_config.get("goal", "")
        decision.collected_data = self._state_machine.collected_data.copy()
        decision.missing_data = [
            f for f in required
            if not self._state_machine.collected_data.get(f)
        ]
        decision.optional_data = [
            f for f in optional
            if not self._state_machine.collected_data.get(f)
        ]

        # Determine is_final (with objection limit override)
        decision.is_final = next_config.get("is_final", False)
        # Override: soft_close triggered by objection limit is always final
        if (decision.next_state == "soft_close" and
            self._state_machine.collected_data.get("_objection_limit_final")):
            decision.is_final = True

        # Fill phase info
        decision.spin_phase = (
            next_config.get("phase") or next_config.get("spin_phase")
        )

        # Fill prev_phase for decision_trace phase tracking
        prev_config = self._flow_config.states.get(prev_state, {})
        decision.prev_phase = (
            prev_config.get("phase") or prev_config.get("spin_phase")
        )

        # Fill stats
        decision.circular_flow = self._state_machine.circular_flow.get_stats()
        decision.objection_flow = self._get_objection_stats()

    def _get_objection_stats(self) -> Dict[str, Any]:
        """
        Get objection statistics from IntentTracker.

        Mirrors state_machine._get_objection_stats() for compatibility.
        """
        tracker = self._blackboard._intent_tracker
        return {
            "consecutive_objections": tracker.objection_consecutive(),
            "total_objections": tracker.objection_total(),
            "history": [
                (r.intent, r.state)
                for r in tracker.get_intents_by_category("objection")
            ],
            "return_state": self._state_machine._state_before_objection,
        }

    def get_turn_summary(self) -> Dict[str, Any]:
        """Get summary of the last processed turn."""
        return self._blackboard.get_turn_summary()


# === Factory function for easy setup ===

def create_orchestrator(
    state_machine: 'IStateMachine',
    flow_config: 'IFlowConfig',
    persona_limits: Optional[Dict[str, Dict[str, int]]] = None,
    enable_metrics: bool = True,
    enable_debug_logging: bool = False,
    custom_sources: Optional[List[Type[KnowledgeSource]]] = None,
    tenant_config: Optional['TenantConfig'] = None,  # Multi-tenancy support
) -> DialogueOrchestrator:
    """
    Factory function to create a fully configured DialogueOrchestrator.

    This is the COMPOSITION ROOT for the Blackboard system (DESIGN_PRINCIPLES.md).
    All dependencies are wired here, not scattered throughout the codebase.

    Hexagonal Architecture:
        - state_machine must implement IStateMachine protocol
        - flow_config must implement IFlowConfig protocol
        - This allows easy testing with mock implementations

    Multi-Tenancy:
        Pass tenant_config to customize behavior per tenant.

    Args:
        state_machine: State machine implementing IStateMachine protocol
        flow_config: Flow config implementing IFlowConfig protocol
        persona_limits: Custom persona limits (uses defaults if None)
        enable_metrics: Whether to enable metrics collection
        enable_debug_logging: Whether to enable debug event logging
        custom_sources: Optional list of custom KnowledgeSource classes to register
        tenant_config: Tenant-specific configuration (optional)

    Returns:
        Configured DialogueOrchestrator instance

    Example:
        # Basic usage (uses all built-in sources)
        orchestrator = create_orchestrator(state_machine, flow_config)

        # With custom source
        class MyCustomSource(KnowledgeSource):
            ...

        orchestrator = create_orchestrator(
            state_machine,
            flow_config,
            custom_sources=[MyCustomSource]
        )

        # With tenant configuration
        tenant = TenantConfig(
            tenant_id="acme_corp",
            bot_name="ACME Sales Assistant",
            tone="friendly",
            features={"escalation": True},
        )
        orchestrator = create_orchestrator(
            state_machine,
            flow_config,
            tenant_config=tenant
        )
    """
    from .event_bus import MetricsCollector, DebugLogger
    from .protocols import DEFAULT_TENANT

    # Use default tenant if not provided
    tenant_config = tenant_config or DEFAULT_TENANT

    # Register custom sources if provided
    if custom_sources:
        for source_class in custom_sources:
            if not SourceRegistry.get_registration(source_class.__name__):
                SourceRegistry.register(
                    source_class,
                    priority_order=200,  # Custom sources run after built-in
                    description=f"Custom source: {source_class.__name__}"
                )
                logger.info(f"Registered custom source: {source_class.__name__}")

    # Create event bus
    event_bus = DialogueEventBus()

    # Add metrics collector
    if enable_metrics:
        metrics_collector = MetricsCollector()
        event_bus.subscribe_all(metrics_collector.handle_event)

    # Add debug logger
    if enable_debug_logging:
        debug_logger = DebugLogger()
        event_bus.subscribe_all(debug_logger.handle_event)

    # Create orchestrator (sources loaded via SourceRegistry)
    orchestrator = DialogueOrchestrator(
        state_machine=state_machine,
        flow_config=flow_config,
        event_bus=event_bus,
        enable_validation=True,
        persona_limits=persona_limits,
        tenant_config=tenant_config,
    )

    return orchestrator
ĞŸÑ€Ğ¾Ğ´Ğ¾Ğ»Ğ¶Ğ°Ñ Ñ ÑˆĞµÑÑ‚Ğ¾Ğ¹ Ñ‡Ğ°ÑÑ‚ÑŒÑ â€” Configuration, Migration Plan Ğ¸ Testing.

Ğ¿Ñ€Ğ¾Ğ´Ğ¾Ğ»Ğ¶Ğ°Ğ¹
Ğ§Ğ°ÑÑ‚ÑŒ 6: Configuration, Migration Plan Ğ¸ Testing
13. Configuration (YAML)
13.1 ĞĞ±Ğ½Ğ¾Ğ²Ğ»ĞµĞ½Ğ¸Ğµ constants.yaml

# src/yaml_config/constants.yaml

# ==============================================================================
# BLACKBOARD SYSTEM CONFIGURATION
# ==============================================================================
#
# NOTE: Blackboard â€” Ğ•Ğ”Ğ˜ĞĞ¡Ğ¢Ğ’Ğ•ĞĞĞĞ¯ ÑĞ¸ÑÑ‚ĞµĞ¼Ğ° ÑƒĞ¿Ñ€Ğ°Ğ²Ğ»ĞµĞ½Ğ¸Ñ Ğ´Ğ¸Ğ°Ğ»Ğ¾Ğ³Ğ¾Ğ¼.
#       ĞĞ•Ğ¢ feature flags Ğ´Ğ»Ñ Ğ²ĞºĞ»ÑÑ‡ĞµĞ½Ğ¸Ñ/Ğ²Ñ‹ĞºĞ»ÑÑ‡ĞµĞ½Ğ¸Ñ.
#       ĞĞ•Ğ¢ shadow mode.
#       ĞĞ•Ğ¢ gradual rollout.

blackboard:
  # Validation settings
  validation:
    enabled: true
    strict_mode: false  # Treat warnings as errors

  # Event bus settings
  event_bus:
    async_mode: false  # Set true for high-throughput scenarios
    history_size: 100

  # Default action when no proposals
  default_action: "continue_current_goal"

  # Debug logging (can be toggled without redeployment)
  debug_logging: false

# Ğ£Ğ”ĞĞ›Ğ•ĞĞ (Ğ´Ğ»Ñ ÑĞ¿Ñ€Ğ°Ğ²ĞºĞ¸):
# - enabled: flag â€” Blackboard Ğ’Ğ¡Ğ•Ğ“Ğ”Ğ Ğ²ĞºĞ»ÑÑ‡Ñ‘Ğ½
# - shadow_mode: â€” ÑƒĞ´Ğ°Ğ»Ñ‘Ğ½ Ğ¿Ğ¾Ğ»Ğ½Ğ¾ÑÑ‚ÑŒÑ
# - shadow_mode_log_divergences: â€” ÑƒĞ´Ğ°Ğ»Ñ‘Ğ½ Ğ¿Ğ¾Ğ»Ğ½Ğ¾ÑÑ‚ÑŒÑ

# ==============================================================================
# KNOWLEDGE SOURCES CONFIGURATION (Plugin System)
# ==============================================================================
# Each source can be enabled/disabled independently via configuration.
# Sources are loaded via SourceRegistry in priority_order.

sources:
  PriceQuestionSource:
    enabled: true
    priority_order: 10
    description: "Handles price-related questions with combinable actions"

  DataCollectorSource:
    enabled: true
    priority_order: 20
    description: "Tracks data completeness and proposes transitions"

  ObjectionGuardSource:
    enabled: true
    priority_order: 30
    description: "Monitors objection limits per persona"

  IntentProcessorSource:
    enabled: true
    priority_order: 40
    description: "Maps intents to actions via rules"

  TransitionResolverSource:
    enabled: true
    priority_order: 50
    description: "Handles intent-based state transitions"

  EscalationSource:
    enabled: true
    priority_order: 60
    description: "Detects escalation triggers for human handoff"

  # Example: To disable a source, set enabled: false
  # MyCustomSource:
  #   enabled: true
  #   priority_order: 200
  #   description: "Custom source for specific business logic"

# ==============================================================================
# PERSONA LIMITS (for ObjectionGuardSource)
# ==============================================================================

persona_limits:
  aggressive:
    consecutive_objections: 5
    total_objections: 8
    description: "Aggressive negotiators - allow more pushback"
    
  price_sensitive:
    consecutive_objections: 4
    total_objections: 7
    description: "Price-focused buyers - moderate tolerance"
    
  skeptical:
    consecutive_objections: 4
    total_objections: 6
    description: "Skeptical prospects - lower tolerance"
    
  busy:
    consecutive_objections: 2
    total_objections: 4
    description: "Time-constrained buyers - minimal tolerance"
    
  analytical:
    consecutive_objections: 4
    total_objections: 6
    description: "Detail-oriented buyers - moderate tolerance"
    
  friendly:
    consecutive_objections: 4
    total_objections: 7
    description: "Positive prospects - moderate tolerance"
    
  default:
    consecutive_objections: 3
    total_objections: 5
    description: "Default limits when persona not detected"

# ==============================================================================
# ESCALATION THRESHOLDS (for EscalationSource)
# ==============================================================================

escalation:
  frustration_threshold: 3      # Number of frustration signals
  misunderstanding_threshold: 4  # Number of "unclear" intents
  high_value_threshold: 100      # Company size for high-value treatment
  
  # Intents that trigger immediate escalation
  explicit_intents:
    - request_human
    - speak_to_manager
    - talk_to_person
    - need_help
    - real_person
    - human_please
    - escalate
    
  # Sensitive topics requiring human
  sensitive_intents:
    - legal_question
    - compliance_question
    - formal_complaint
    - refund_request
    - contract_dispute
    - data_deletion
    - gdpr_request

# ==============================================================================
# PRICE-RELATED INTENTS (for PriceQuestionSource)
# ==============================================================================

price_related_intents:
  - price_question
  - pricing_details
  - cost_inquiry
  - discount_request
  - payment_terms
  - pricing_comparison
  - budget_question
  - roi_question
  - total_cost_ownership

# ==============================================================================
# REASON CODES DOCUMENTATION
# ==============================================================================

reason_codes:
  # PriceQuestionSource
  price_question_priority:
    description: "Price-related question detected, answering with pricing info"
    source: "PriceQuestionSource"
    combinable: true
    
  # DataCollectorSource  
  data_complete:
    description: "All required data for current state collected"
    source: "DataCollectorSource"
    combinable: true
    
  # ObjectionGuardSource
  objection_limit_exceeded:
    description: "Persona-specific objection limit reached"
    source: "ObjectionGuardSource"
    combinable: false
    
  # IntentProcessorSource
  rule_matched:
    description: "Intent matched a rule in state configuration"
    source: "IntentProcessorSource"
    combinable: true
    
  # TransitionResolverSource
  intent_transition:
    description: "Explicit intent-to-transition mapping matched"
    source: "TransitionResolverSource"
    combinable: true
    
  # EscalationSource
  escalation_explicit_request:
    description: "User explicitly requested human assistance"
    source: "EscalationSource"
    combinable: false
    
  escalation_sensitive_topic:
    description: "Sensitive topic requiring human handling"
    source: "EscalationSource"
    combinable: false
    
  escalation_frustration_threshold:
    description: "User frustration threshold exceeded"
    source: "EscalationSource"
    combinable: false
    
  escalation_misunderstanding_threshold:
    description: "Too many misunderstandings in conversation"
    source: "EscalationSource"
    combinable: false
    
  # ConflictResolver
  fallback_any_transition:
    description: "No explicit transition, using 'any' fallback"
    source: "ConflictResolver"
    combinable: true

# ==============================================================================
# BLOCKING ACTIONS (combinable=False)
# ==============================================================================

blocking_actions:
  - handle_rejection
  - objection_limit_reached
  - escalate_to_human
  - emergency_escalate
  - end_conversation
  - hard_close

# ==============================================================================
# EXISTING CONFIGURATION (unchanged)
# ==============================================================================

limits:
  max_consecutive_objections: 3  # Legacy - use persona_limits instead
  max_total_objections: 5        # Legacy - use persona_limits instead
  max_gobacks: 2

circular_flow:
  allowed_gobacks:
    spin_implication: spin_situation
    spin_problem: greeting
    spin_need_payoff: spin_problem

# Intent categories (existing - unchanged)
intents:
  objection:
    - objection_price
    - objection_competitor
    - objection_timing
    - objection_authority
    - objection_need
    - objection_trust
    - objection_budget
    - objection_features
    - objection_complexity
    - objection_support
    - objection_integration
    - objection_security
    - objection_scalability
    - objection_contract
    - objection_implementation
    - objection_training
    - objection_roi
    - objection_change
    - objection_generic
    
  positive:
    - agreement
    - positive_feedback
    - interest_expressed
    - ready_to_proceed
    - schedule_meeting
    - request_demo
    - request_proposal
    - request_quote
    - confirm_understanding
    - appreciation
    # ... (rest of existing intents)
    
  question:
    - price_question
    - question_features
    - question_integration
    - question_support
    - question_security
    - question_timeline
    - question_process
    - question_comparison
    - question_customization
    - question_training
    # ... (rest of existing intents)
13.2 Feature Flags (settings.yaml update) â€” Ğ£ĞŸĞ ĞĞ©ĞĞĞĞĞ¯ Ğ’Ğ•Ğ Ğ¡Ğ˜Ğ¯

# settings.yaml (ĞŸĞĞ¡Ğ›Ğ• ĞœĞ˜Ğ“Ğ ĞĞ¦Ğ˜Ğ˜)
#
# Ğ£Ğ”ĞĞ›Ğ•ĞĞ Ğ²ÑÑ‘ Ñ‡Ñ‚Ğ¾ ÑĞ²ÑĞ·Ğ°Ğ½Ğ¾ Ñ legacy/blackboard switching:
# - blackboard_enabled (Ğ±Ğ¾Ğ»ÑŒÑˆĞµ Ğ½Ğµ Ğ½ÑƒĞ¶ĞµĞ½ â€” Ğ²ÑĞµĞ³Ğ´Ğ° Blackboard)
# - blackboard_shadow_mode (ÑƒĞ´Ğ°Ğ»Ñ‘Ğ½ shadow mode)
# - blackboard_traffic_percentage (ÑƒĞ´Ğ°Ğ»Ñ‘Ğ½ gradual rollout)

feature_flags:
  # === EXISTING FLAGS (unchanged) ===
  tone_analysis: true           # Phase 2
  conversation_guard: true       # Phase 1
  objection_handler: true        # Phase 3
  lead_scoring: true             # Phase 3
  metrics_tracking: true         # Phase 0
  confidence_router: true        # Phase 4
  context_full_envelope: true    # Phase 5
  dialogue_policy: true          # Phase 5

  # === BLACKBOARD OPERATIONAL FLAGS ===
  # (ĞĞ• Ğ´Ğ»Ñ switching Ğ¼ĞµĞ¶Ğ´Ñƒ ÑĞ¸ÑÑ‚ĞµĞ¼Ğ°Ğ¼Ğ¸ â€” Ñ‚Ğ¾Ğ»ÑŒĞºĞ¾ Ğ´Ğ»Ñ tuning)

  # Enable detailed Blackboard logging (for debugging)
  blackboard_debug_logging: false

  # Enable Blackboard metrics collection
  blackboard_metrics: true

  # Enable proposal validation
  blackboard_validation: true

# Ğ£Ğ”ĞĞ›ĞĞĞĞ«Ğ• FLAGS (Ğ´Ğ»Ñ ÑĞ¿Ñ€Ğ°Ğ²ĞºĞ¸):
#
# blackboard_enabled: Ğ£Ğ”ĞĞ›ĞĞ â€” Blackboard Ñ‚ĞµĞ¿ĞµÑ€ÑŒ ĞµĞ´Ğ¸Ğ½ÑÑ‚Ğ²ĞµĞ½Ğ½Ğ°Ñ ÑĞ¸ÑÑ‚ĞµĞ¼Ğ°
# blackboard_shadow_mode: Ğ£Ğ”ĞĞ›ĞĞ â€” Ğ½ĞµÑ‚ shadow mode
# blackboard_traffic_percentage: Ğ£Ğ”ĞĞ›ĞĞ â€” Ğ½ĞµÑ‚ gradual rollout
# blackboard_source_*: Ğ£Ğ”ĞĞ›Ğ•ĞĞ« â€” ÑƒĞ¿Ñ€Ğ°Ğ²Ğ»ĞµĞ½Ğ¸Ğµ Ñ‡ĞµÑ€ĞµĞ· constants.yaml
13.3 Ğ”Ğ¾Ğ±Ğ°Ğ²Ğ»ĞµĞ½Ğ¸Ğµ human_handoff state

# src/yaml_config/flows/_base/states.yaml (additions)

human_handoff:
  goal: "ĞŸĞµÑ€ĞµĞ´Ğ°Ñ‚ÑŒ Ñ€Ğ°Ğ·Ğ³Ğ¾Ğ²Ğ¾Ñ€ Ñ‡ĞµĞ»Ğ¾Ğ²ĞµĞºÑƒ"
  description: "Ğ¡Ğ¾ÑÑ‚Ğ¾ÑĞ½Ğ¸Ğµ ÑÑĞºĞ°Ğ»Ğ°Ñ†Ğ¸Ğ¸ Ğº Ğ¶Ğ¸Ğ²Ğ¾Ğ¼Ñƒ Ğ¾Ğ¿ĞµÑ€Ğ°Ñ‚Ğ¾Ñ€Ñƒ"
  is_final: false
  is_escalation: true
  
  on_enter:
    action: "initiate_handoff"
    set_flags:
      escalated: true
      escalation_time: "{{timestamp}}"
      
  transitions:
    human_available: handoff_complete
    human_unavailable: handoff_delayed
    user_cancel: "{{previous_state}}"
    
  rules:
    any: "wait_for_handoff"
    
  metadata:
    sla_minutes: 5
    notification_channels:
      - slack
      - email

handoff_complete:
  goal: "ĞŸĞµÑ€ĞµĞ´Ğ°Ñ‡Ğ° Ğ·Ğ°Ğ²ĞµÑ€ÑˆĞµĞ½Ğ°"
  is_final: true
  
  on_enter:
    action: "confirm_handoff"
    
handoff_delayed:
  goal: "ĞĞ¿ĞµÑ€Ğ°Ñ‚Ğ¾Ñ€ Ğ½ĞµĞ´Ğ¾ÑÑ‚ÑƒĞ¿ĞµĞ½, Ğ¾Ğ¶Ğ¸Ğ´Ğ°Ğ½Ğ¸Ğµ"
  
  on_enter:
    action: "notify_delay"
    set_flags:
      handoff_delayed: true
      
  transitions:
    human_available: handoff_complete
    user_leave_contact: collect_callback
    timeout: soft_close
14. Integration with SalesBot (ĞŸĞĞ›ĞĞĞ¯ Ğ—ĞĞœĞ•ĞĞ)

================================================================================
                    âš ï¸  ĞšĞ Ğ˜Ğ¢Ğ˜Ğ§ĞĞ: Ğ¡ĞĞ’ĞœĞ•Ğ¡Ğ¢Ğ˜ĞœĞĞ¡Ğ¢Ğ¬ Ğ¡ bot.py  âš ï¸

    Ğ¡ÑƒÑ‰ĞµÑÑ‚Ğ²ÑƒÑÑ‰Ğ¸Ğ¹ bot.py Ğ¸ÑĞ¿Ğ¾Ğ»ÑŒĞ·ÑƒĞµÑ‚ sm_result ĞºĞ°Ğº Dict Ñ ĞºĞ¾Ğ½ĞºÑ€ĞµÑ‚Ğ½Ñ‹Ğ¼Ğ¸ Ğ¿Ğ¾Ğ»ÑĞ¼Ğ¸.
    DialoguePolicy Ğ¼Ğ¾Ğ´Ğ¸Ñ„Ğ¸Ñ†Ğ¸Ñ€ÑƒĞµÑ‚ ÑÑ‚Ğ¾Ñ‚ dict IN-PLACE.
    Generator Ğ¾Ğ¶Ğ¸Ğ´Ğ°ĞµÑ‚ goal, collected_data, missing_data, spin_phase.

    Ğ Ğ•Ğ¨Ğ•ĞĞ˜Ğ•: Ğ˜ÑĞ¿Ğ¾Ğ»ÑŒĞ·ÑƒĞµĞ¼ decision.to_sm_result() Ğ´Ğ»Ñ Ğ¿Ğ¾Ğ»Ğ½Ğ¾Ğ¹ ÑĞ¾Ğ²Ğ¼ĞµÑÑ‚Ğ¸Ğ¼Ğ¾ÑÑ‚Ğ¸.
================================================================================

14.1 Ğ˜Ğ·Ğ¼ĞµĞ½ĞµĞ½Ğ¸Ñ Ğ² Ñ‚Ğ¾Ñ‡ĞºĞµ Ğ¸Ğ½Ñ‚ĞµĞ³Ñ€Ğ°Ñ†Ğ¸Ğ¸ (src/bot.py)

# ============================================================================
# Ğ‘Ğ«Ğ›Ğ (state_machine.process):
# ============================================================================
#
#   sm_result = self.state_machine.process(
#       intent, extracted, context_envelope=context_envelope
#   )
#   # sm_result â€” ÑÑ‚Ğ¾ Dict Ñ Ğ¿Ğ¾Ğ»ÑĞ¼Ğ¸:
#   # action, prev_state, next_state, goal, collected_data,
#   # missing_data, optional_data, is_final, spin_phase,
#   # circular_flow, objection_flow, trace
#
#   # DialoguePolicy Ğ¼Ğ¾Ğ´Ğ¸Ñ„Ğ¸Ñ†Ğ¸Ñ€ÑƒĞµÑ‚ sm_result in-place:
#   policy_override = self.dialogue_policy.maybe_override(sm_result, context_envelope)
#   if policy_override:
#       sm_result["action"] = policy_override.action
#       sm_result["next_state"] = policy_override.next_state
#
#   # Generator Ğ¸ÑĞ¿Ğ¾Ğ»ÑŒĞ·ÑƒĞµÑ‚ sm_result Ğ½Ğ°Ğ¿Ñ€ÑĞ¼ÑƒÑ:
#   context = {
#       "goal": sm_result["goal"],
#       "collected_data": sm_result["collected_data"],
#       "missing_data": sm_result["missing_data"],
#       ...
#   }

# ============================================================================
# Ğ¡Ğ¢ĞĞ›Ğ (DialogueOrchestrator.process_turn):
# ============================================================================
#
#   # 1. ĞŸĞ¾Ğ»ÑƒÑ‡Ğ°ĞµĞ¼ ResolvedDecision Ğ¾Ñ‚ Blackboard
#   decision = self._orchestrator.process_turn(
#       intent=intent,
#       extracted_data=extracted,
#       context_envelope=context_envelope,
#   )
#
#   # 2. ĞšĞ¾Ğ½Ğ²ĞµÑ€Ñ‚Ğ¸Ñ€ÑƒĞµĞ¼ Ğ² sm_result dict Ğ´Ğ»Ñ ÑĞ¾Ğ²Ğ¼ĞµÑÑ‚Ğ¸Ğ¼Ğ¾ÑÑ‚Ğ¸
#   #    ĞšĞ Ğ˜Ğ¢Ğ˜Ğ§ĞĞ: to_sm_result() Ğ²Ğ¾Ğ·Ğ²Ñ€Ğ°Ñ‰Ğ°ĞµÑ‚ Dict ÑĞ¾ Ğ’Ğ¡Ğ•ĞœĞ˜ Ğ¿Ğ¾Ğ»ÑĞ¼Ğ¸,
#   #    ĞºĞ¾Ñ‚Ğ¾Ñ€Ñ‹Ğµ Ğ¾Ğ¶Ğ¸Ğ´Ğ°ÑÑ‚ DialoguePolicy Ğ¸ Generator
#   sm_result = decision.to_sm_result()
#
#   # 3. DialoguePolicy Ñ€Ğ°Ğ±Ğ¾Ñ‚Ğ°ĞµÑ‚ Ğ‘Ğ•Ğ— Ğ˜Ğ—ĞœĞ•ĞĞ•ĞĞ˜Ğ™ (Ğ¼Ğ¾Ğ´Ğ¸Ñ„Ğ¸Ñ†Ğ¸Ñ€ÑƒĞµÑ‚ dict in-place)
#   policy_override = self.dialogue_policy.maybe_override(sm_result, context_envelope)
#   if policy_override and policy_override.has_override:
#       sm_result["action"] = policy_override.action
#       if policy_override.next_state:
#           sm_result["next_state"] = policy_override.next_state
#           self.state_machine.state = policy_override.next_state
#
#   # 4. Generator Ñ€Ğ°Ğ±Ğ¾Ñ‚Ğ°ĞµÑ‚ Ğ‘Ğ•Ğ— Ğ˜Ğ—ĞœĞ•ĞĞ•ĞĞ˜Ğ™
#   context = {
#       "goal": sm_result["goal"],
#       "collected_data": sm_result["collected_data"],
#       "missing_data": sm_result["missing_data"],
#       "spin_phase": sm_result.get("spin_phase"),
#       "optional_data": sm_result.get("optional_data", []),
#       ...
#   }

14.2 ĞŸĞ¾Ğ»Ğ½Ñ‹Ğ¹ Ğ¿Ñ€Ğ¸Ğ¼ĞµÑ€ Ğ¸Ğ½Ñ‚ĞµĞ³Ñ€Ğ°Ñ†Ğ¸Ğ¸

# src/bot.py â€” ĞœĞ˜ĞĞ˜ĞœĞĞ›Ğ¬ĞĞ«Ğ• Ğ˜Ğ—ĞœĞ•ĞĞ•ĞĞ˜Ğ¯ Ğ² Ğ¼ĞµÑ‚Ğ¾Ğ´Ğµ process()

def process(self, user_message: str) -> Dict[str, Any]:
    """
    Process a user message and generate a response.

    Ğ˜Ğ—ĞœĞ•ĞĞ•ĞĞ˜Ğ¯ Ğ´Ğ»Ñ Blackboard:
    1. Ğ—Ğ°Ğ¼ĞµĞ½Ñ‘Ğ½ Ğ²Ñ‹Ğ·Ğ¾Ğ² state_machine.process() â†’ orchestrator.process_turn()
    2. Ğ”Ğ¾Ğ±Ğ°Ğ²Ğ»ĞµĞ½ Ğ²Ñ‹Ğ·Ğ¾Ğ² decision.to_sm_result() Ğ´Ğ»Ñ ÑĞ¾Ğ²Ğ¼ĞµÑÑ‚Ğ¸Ğ¼Ğ¾ÑÑ‚Ğ¸
    3. Ğ’Ğ¡Ğ ĞĞ¡Ğ¢ĞĞ›Ğ¬ĞĞĞ• Ğ‘Ğ•Ğ— Ğ˜Ğ—ĞœĞ•ĞĞ•ĞĞ˜Ğ™ (DialoguePolicy, Generator, metrics)
    """
    # ... existing preprocessing (tone analysis, guard, fallback check) ...

    # Classify intent (Ğ‘Ğ•Ğ— Ğ˜Ğ—ĞœĞ•ĞĞ•ĞĞ˜Ğ™)
    classification = self._classify_intent(user_message)
    intent = classification["intent"]
    extracted = classification.get("extracted_data", {})

    # Build context envelope (Ğ‘Ğ•Ğ— Ğ˜Ğ—ĞœĞ•ĞĞ•ĞĞ˜Ğ™)
    context_envelope = self._build_context_envelope()

    # =========================================================================
    # Ğ˜Ğ—ĞœĞ•ĞĞ•ĞĞ˜Ğ• #1: Blackboard Ğ²Ğ¼ĞµÑÑ‚Ğ¾ state_machine.process()
    # =========================================================================
    # Ğ‘Ğ«Ğ›Ğ:
    #   sm_result = self.state_machine.process(
    #       intent, extracted, context_envelope=context_envelope
    #   )
    #
    # Ğ¡Ğ¢ĞĞ›Ğ:
    decision = self._orchestrator.process_turn(
        intent=intent,
        extracted_data=extracted,
        context_envelope=context_envelope,
    )

    # =========================================================================
    # Ğ˜Ğ—ĞœĞ•ĞĞ•ĞĞ˜Ğ• #2: ĞšĞ¾Ğ½Ğ²ĞµÑ€Ñ‚Ğ°Ñ†Ğ¸Ñ Ğ² sm_result Ğ´Ğ»Ñ ÑĞ¾Ğ²Ğ¼ĞµÑÑ‚Ğ¸Ğ¼Ğ¾ÑÑ‚Ğ¸
    # =========================================================================
    # ĞšĞ Ğ˜Ğ¢Ğ˜Ğ§ĞĞ: to_sm_result() Ğ²ĞºĞ»ÑÑ‡Ğ°ĞµÑ‚ Ğ’Ğ¡Ğ• Ğ¿Ğ¾Ğ»Ñ, ĞºĞ¾Ñ‚Ğ¾Ñ€Ñ‹Ğµ Ğ¾Ğ¶Ğ¸Ğ´Ğ°ĞµÑ‚ bot.py:
    # - prev_state (Ğ´Ğ»Ñ Ğ¼ĞµÑ‚Ñ€Ğ¸Ğº)
    # - goal (Ğ´Ğ»Ñ generator context)
    # - collected_data (Ğ¿Ğ¾Ğ»Ğ½Ñ‹Ğ¹ dict)
    # - missing_data, optional_data (Ğ´Ğ»Ñ generator)
    # - is_final, spin_phase (Ğ´Ğ»Ñ Ğ¾Ğ¿Ñ€ĞµĞ´ĞµĞ»ĞµĞ½Ğ¸Ñ Ğ·Ğ°Ğ²ĞµÑ€ÑˆĞµĞ½Ğ¸Ñ)
    # - circular_flow, objection_flow (Ğ´Ğ»Ñ ÑÑ‚Ğ°Ñ‚Ğ¸ÑÑ‚Ğ¸ĞºĞ¸)
    # - reason_codes (NEW: Ğ´Ğ»Ñ Ñ‚Ñ€Ğ°ÑÑĞ¸Ñ€Ğ¾Ğ²ĞºĞ¸ Blackboard Ñ€ĞµÑˆĞµĞ½Ğ¸Ğ¹)
    sm_result = decision.to_sm_result()

    # =========================================================================
    # Ğ’Ğ¡Ğ ĞĞ˜Ğ–Ğ• â€” Ğ‘Ğ•Ğ— Ğ˜Ğ—ĞœĞ•ĞĞ•ĞĞ˜Ğ™ (Ğ¿Ğ¾Ğ»Ğ½Ğ°Ñ ÑĞ¾Ğ²Ğ¼ĞµÑÑ‚Ğ¸Ğ¼Ğ¾ÑÑ‚ÑŒ)
    # =========================================================================

    # DialoguePolicy overlay (Ğ‘Ğ•Ğ— Ğ˜Ğ—ĞœĞ•ĞĞ•ĞĞ˜Ğ™)
    policy_override = None
    if flags.context_policy_overlays:
        policy_override = self.dialogue_policy.maybe_override(sm_result, context_envelope)
    if policy_override and policy_override.has_override:
        logger.info(
            "DialoguePolicy override applied",
            original_action=sm_result["action"],
            override_action=policy_override.action,
            reason_codes=policy_override.reason_codes,
        )
        if policy_override.action:
            sm_result["action"] = policy_override.action
        if policy_override.next_state:
            sm_result["next_state"] = policy_override.next_state
            self.state_machine.state = policy_override.next_state

    # Build context for generator (Ğ‘Ğ•Ğ— Ğ˜Ğ—ĞœĞ•ĞĞ•ĞĞ˜Ğ™)
    context = {
        "user_message": user_message,
        "intent": intent,
        "state": sm_result["next_state"],
        "history": self.history,
        "goal": sm_result["goal"],
        "collected_data": sm_result["collected_data"],
        "missing_data": sm_result["missing_data"],
        "spin_phase": sm_result.get("spin_phase"),
        "optional_data": sm_result.get("optional_data", []),
        # ... other existing fields ...
    }

    # Generate response (Ğ‘Ğ•Ğ— Ğ˜Ğ—ĞœĞ•ĞĞ•ĞĞ˜Ğ™)
    action = sm_result["action"]
    response = self.generator.generate(action, context)

    # ... existing postprocessing (CTA, metrics, etc.) ...

    # Return result (Ğ‘Ğ•Ğ— Ğ˜Ğ—ĞœĞ•ĞĞ•ĞĞ˜Ğ™ + reason_codes)
    return {
        "response": response,
        "intent": intent,
        "action": action,
        "state": sm_result["next_state"],
        "is_final": sm_result["is_final"],
        "spin_phase": sm_result.get("spin_phase"),
        # NEW: Blackboard reason codes Ğ´Ğ»Ñ debugging
        "reason_codes": sm_result.get("reason_codes", []),
    }

14.3 ĞšĞ¾Ğ½Ñ‚Ñ€Ğ¾Ğ»ÑŒĞ½Ñ‹Ğ¹ ÑĞ¿Ğ¸ÑĞ¾Ğº ÑĞ¾Ğ²Ğ¼ĞµÑÑ‚Ğ¸Ğ¼Ğ¾ÑÑ‚Ğ¸

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    CHECKLIST: bot.py Compatibility                            â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                               â”‚
â”‚  âœ… sm_result["action"]        â€” Ğ·Ğ°Ğ¿Ğ¾Ğ»Ğ½ÑĞµÑ‚ÑÑ ResolvedDecision.action          â”‚
â”‚  âœ… sm_result["next_state"]    â€” Ğ·Ğ°Ğ¿Ğ¾Ğ»Ğ½ÑĞµÑ‚ÑÑ ResolvedDecision.next_state      â”‚
â”‚  âœ… sm_result["prev_state"]    â€” Ğ·Ğ°Ğ¿Ğ¾Ğ»Ğ½ÑĞµÑ‚ÑÑ _fill_compatibility_fields()     â”‚
â”‚  âœ… sm_result["goal"]          â€” Ğ¸Ğ· state_config[next_state].goal             â”‚
â”‚  âœ… sm_result["collected_data"]â€” Ğ¿Ğ¾Ğ»Ğ½Ñ‹Ğ¹ dict ĞŸĞĞ¡Ğ›Ğ• Ğ¿Ñ€Ğ¸Ğ¼ĞµĞ½ĞµĞ½Ğ¸Ñ data_updates    â”‚
â”‚  âœ… sm_result["missing_data"]  â€” Ğ²Ñ‹Ñ‡Ğ¸ÑĞ»ÑĞµÑ‚ÑÑ Ğ¸Ğ· required_data                 â”‚
â”‚  âœ… sm_result["optional_data"] â€” Ğ²Ñ‹Ñ‡Ğ¸ÑĞ»ÑĞµÑ‚ÑÑ Ğ¸Ğ· optional_data                 â”‚
â”‚  âœ… sm_result["is_final"]      â€” Ğ¸Ğ· state_config + objection_limit override   â”‚
â”‚  âœ… sm_result["spin_phase"]    â€” Ğ¸Ğ· state_config.phase                        â”‚
â”‚  âœ… sm_result["circular_flow"] â€” Ğ¸Ğ· state_machine.circular_flow.get_stats()   â”‚
â”‚  âœ… sm_result["objection_flow"]â€” Ğ¸Ğ· _get_objection_stats()                    â”‚
â”‚                                                                               â”‚
â”‚  DialoguePolicy:                                                              â”‚
â”‚  âœ… maybe_override(sm_result, envelope) â€” Ğ¿Ğ¾Ğ»ÑƒÑ‡Ğ°ĞµÑ‚ Dict, Ğ½Ğµ ResolvedDecision  â”‚
â”‚  âœ… ĞœĞ¾Ğ´Ğ¸Ñ„Ğ¸ĞºĞ°Ñ†Ğ¸Ñ in-place Ñ€Ğ°Ğ±Ğ¾Ñ‚Ğ°ĞµÑ‚ (sm_result â€” Ğ¾Ğ±Ñ‹Ñ‡Ğ½Ñ‹Ğ¹ dict)                  â”‚
â”‚                                                                               â”‚
â”‚  Generator:                                                                   â”‚
â”‚  âœ… context["goal"] = sm_result["goal"]                                       â”‚
â”‚  âœ… context["collected_data"] = sm_result["collected_data"]                   â”‚
â”‚  âœ… context["missing_data"] = sm_result["missing_data"]                       â”‚
â”‚  âœ… context["spin_phase"] = sm_result.get("spin_phase")                       â”‚
â”‚                                                                               â”‚
â”‚  Side Effects (Ğ²Ñ‹Ğ¿Ğ¾Ğ»Ğ½ÑÑÑ‚ÑÑ Ğ² _apply_side_effects):                            â”‚
â”‚  âœ… IntentTracker.record() â€” Ğ² begin_turn() (Ñ objection skip Ğ»Ğ¾Ğ³Ğ¸ĞºĞ¾Ğ¹)        â”‚
â”‚  âœ… state_machine.state = next_state                                          â”‚
â”‚  âœ… state_machine.last_action = action                                        â”‚
â”‚  âœ… state_machine.current_phase = phase                                       â”‚
â”‚  âœ… on_enter flags â€” Ğ¿Ñ€Ğ¸ ÑĞ¼ĞµĞ½Ğµ ÑĞ¾ÑÑ‚Ğ¾ÑĞ½Ğ¸Ñ                                      â”‚
â”‚  âœ… data_updates â†’ collected_data                                             â”‚
â”‚                                                                               â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

14.4 Ğ˜Ğ½Ğ¸Ñ†Ğ¸Ğ°Ğ»Ğ¸Ğ·Ğ°Ñ†Ğ¸Ñ Orchestrator Ğ² SalesBot.__init__

class SalesBot:
    def __init__(self, ...):
        # ... existing initialization ...

        # StateMachine Ğ¾ÑÑ‚Ğ°Ñ‘Ñ‚ÑÑ Ğ´Ğ»Ñ Ñ…Ñ€Ğ°Ğ½ĞµĞ½Ğ¸Ñ state/collected_data
        # apply_rules() Ğ£Ğ”ĞĞ›ĞĞ, Ğ½Ğ¾ ĞºĞ»Ğ°ÑÑ ÑĞ¾Ñ…Ñ€Ğ°Ğ½ÑĞµÑ‚ÑÑ
        self.state_machine = StateMachine(...)

        # Blackboard Orchestrator â€” ĞµĞ´Ğ¸Ğ½ÑÑ‚Ğ²ĞµĞ½Ğ½Ğ°Ñ ÑĞ¸ÑÑ‚ĞµĞ¼Ğ° dialogue management
        self._orchestrator = create_orchestrator(
            state_machine=self.state_machine,
            flow_config=self._flow,
            persona_limits=self._load_persona_limits(),
            enable_metrics=True,
            enable_debug_logging=settings.debug,
        )

    def _load_persona_limits(self) -> Dict[str, Dict[str, int]]:
        """Load persona limits from constants.yaml."""
        return {
            "default": {"consecutive": 3, "total": 5},
            "aggressive": {"consecutive": 5, "total": 8},
            "busy": {"consecutive": 2, "total": 4},
            # ... from yaml ...
        }

14.5 Out of Scope â€” Ğ§Ñ‚Ğ¾ ĞĞ• Ñ‚Ñ€Ğ¾Ğ³Ğ°ĞµÑ‚ Blackboard

================================================================================
     ĞšĞ Ğ˜Ğ¢Ğ˜Ğ§ĞĞ: Blackboard Ğ·Ğ°Ğ¼ĞµĞ½ÑĞµÑ‚ Ğ¢ĞĞ›Ğ¬ĞšĞ state_machine.process()
     Ğ’ÑĞµ Ğ¾ÑÑ‚Ğ°Ğ»ÑŒĞ½Ñ‹Ğµ Ğ¼ĞµÑ‚Ğ¾Ğ´Ñ‹ StateMachine Ğ¾ÑÑ‚Ğ°ÑÑ‚ÑÑ Ğ‘Ğ•Ğ— Ğ˜Ğ—ĞœĞ•ĞĞ•ĞĞ˜Ğ™
================================================================================

Ğ¡Ğ»ĞµĞ´ÑƒÑÑ‰Ğ¸Ğµ Ğ¼ĞµÑ‚Ğ¾Ğ´Ñ‹/ÑĞ²Ğ¾Ğ¹ÑÑ‚Ğ²Ğ° StateMachine Ğ²Ñ‹Ğ·Ñ‹Ğ²Ğ°ÑÑ‚ÑÑ Ğ½Ğ°Ğ¿Ñ€ÑĞ¼ÑƒÑ Ğ¸Ğ· bot.py
Ğ¸ ĞĞ• Ğ²Ñ…Ğ¾Ğ´ÑÑ‚ Ğ² scope Blackboard ÑĞ¸ÑÑ‚ĞµĞ¼Ñ‹:

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  OUT OF SCOPE â€” StateMachine Ğ¼ĞµÑ‚Ğ¾Ğ´Ñ‹ Ğ²Ñ‹Ğ·Ñ‹Ğ²Ğ°ĞµĞ¼Ñ‹Ğµ Ğ½Ğ°Ğ¿Ñ€ÑĞ¼ÑƒÑ Ğ¸Ğ· bot.py            â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                               â”‚
â”‚  DISAMBIGUATION Ğ¡Ğ˜Ğ¡Ğ¢Ğ•ĞœĞ (Ğ¿Ğ¾Ğ»Ğ½Ğ¾ÑÑ‚ÑŒÑ Ğ²Ğ½Ğµ scope):                               â”‚
â”‚  â”œâ”€â”€ in_disambiguation          # bool property, ÑÑ‚Ñ€Ğ¾ĞºĞ° 652                  â”‚
â”‚  â”œâ”€â”€ enter_disambiguation()     # method, ÑÑ‚Ñ€Ğ¾ĞºĞ° 1224                        â”‚
â”‚  â”œâ”€â”€ exit_disambiguation()      # method, ÑÑ‚Ñ€Ğ¾ĞºĞ¸ 1282, 1307, 1336, 1641      â”‚
â”‚  â”œâ”€â”€ resolve_disambiguation()   # method, ÑÑ‚Ñ€Ğ¾ĞºĞ° 1361                        â”‚
â”‚  â”œâ”€â”€ disambiguation_context     # dict property, ÑÑ‚Ñ€Ğ¾ĞºĞ¸ 1279, 1626           â”‚
â”‚  â”œâ”€â”€ turns_since_last_disambiguation  # int property, ÑÑ‚Ñ€Ğ¾ĞºĞ° 296             â”‚
â”‚  â””â”€â”€ pre_disambiguation_state   # optional str property                      â”‚
â”‚                                                                               â”‚
â”‚  TURN TRACKING:                                                               â”‚
â”‚  â””â”€â”€ increment_turn()           # method, ÑÑ‚Ñ€Ğ¾ĞºĞ° 637 (Ğ´Ğ»Ñ disambiguation     â”‚
â”‚                                 # cooldown)                                   â”‚
â”‚                                                                               â”‚
â”‚  RESET:                                                                       â”‚
â”‚  â””â”€â”€ reset()                    # method, ÑÑ‚Ñ€Ğ¾ĞºĞ° 225 (Ğ½Ğ¾Ğ²Ñ‹Ğ¹ Ñ€Ğ°Ğ·Ğ³Ğ¾Ğ²Ğ¾Ñ€)        â”‚
â”‚                                                                               â”‚
â”‚  ĞŸĞ Ğ¯ĞœĞĞ¯ Ğ—ĞĞŸĞ˜Ğ¡Ğ¬ (Ğ”Ğ process):                                                 â”‚
â”‚  â”œâ”€â”€ state = skip_next_state    # ÑÑ‚Ñ€Ğ¾ĞºĞ° 743 (fallback "skip" action)       â”‚
â”‚  â””â”€â”€ collected_data["key"] = v  # ÑÑ‚Ñ€Ğ¾ĞºĞ¸ 773-776 (competitor extraction)    â”‚
â”‚                                                                               â”‚
â”‚  ĞŸĞ Ğ¯ĞœĞĞ¯ Ğ—ĞĞŸĞ˜Ğ¡Ğ¬ (ĞŸĞĞ¡Ğ›Ğ• process):                                              â”‚
â”‚  â””â”€â”€ state = policy_next_state  # ÑÑ‚Ñ€Ğ¾ĞºĞ° 944 (DialoguePolicy override)      â”‚
â”‚                                                                               â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

ĞŸĞĞ§Ğ•ĞœĞ£ Ğ­Ğ¢Ğ Ğ’ĞĞ–ĞĞ:

1. Blackboard Ñ‡Ğ¸Ñ‚Ğ°ĞµÑ‚ state_machine.state Ğ² begin_turn() â€” Ğ¾Ğ½ Ğ”ĞĞ›Ğ–Ğ•Ğ Ğ²Ğ¸Ğ´ĞµÑ‚ÑŒ
   Ğ¸Ğ·Ğ¼ĞµĞ½ĞµĞ½Ğ¸Ñ ÑĞ´ĞµĞ»Ğ°Ğ½Ğ½Ñ‹Ğµ fallback "skip" action (ÑÑ‚Ñ€Ğ¾ĞºĞ° 743)

2. Blackboard Ñ‡Ğ¸Ñ‚Ğ°ĞµÑ‚ state_machine.collected_data â€” Ğ¾Ğ½ Ğ”ĞĞ›Ğ–Ğ•Ğ Ğ²Ğ¸Ğ´ĞµÑ‚ÑŒ
   Ğ¸Ğ·Ğ¼ĞµĞ½ĞµĞ½Ğ¸Ñ ÑĞ´ĞµĞ»Ğ°Ğ½Ğ½Ñ‹Ğµ competitor extraction (ÑÑ‚Ñ€Ğ¾ĞºĞ¸ 773-776)

3. DialoguePolicy Ğ¼Ğ¾Ğ¶ĞµÑ‚ ĞŸĞ•Ğ Ğ•Ğ—ĞĞŸĞ˜Ğ¡ĞĞ¢Ğ¬ state Ğ¿Ğ¾ÑĞ»Ğµ process_turn() â€” ÑÑ‚Ğ¾
   Ğ½Ğ¾Ñ€Ğ¼Ğ°Ğ»ÑŒĞ½Ğ¾Ğµ Ğ¿Ğ¾Ğ²ĞµĞ´ĞµĞ½Ğ¸Ğµ (ÑÑ‚Ñ€Ğ¾ĞºĞ° 944)

4. Disambiguation â€” Ğ¾Ñ‚Ğ´ĞµĞ»ÑŒĞ½Ğ°Ñ Ğ¿Ğ¾Ğ´ÑĞ¸ÑÑ‚ĞµĞ¼Ğ°, Blackboard ĞµÑ‘ Ğ½Ğµ ĞºĞ°ÑĞ°ĞµÑ‚ÑÑ

14.6 ĞŸÑ€ÑĞ¼Ñ‹Ğµ Ğ¾Ğ±Ñ€Ğ°Ñ‰ĞµĞ½Ğ¸Ñ bot.py Ğº state_machine

# ===========================================================================
# bot.py line 637 â€” increment_turn (Ğ”Ğ Ğ²ÑĞµĞ¹ Ğ¾Ğ±Ñ€Ğ°Ğ±Ğ¾Ñ‚ĞºĞ¸)
# ===========================================================================
# Ğ’Ñ‹Ğ·Ñ‹Ğ²Ğ°ĞµÑ‚ÑÑ Ğ´Ğ»Ñ Ğ¾Ñ‚ÑĞ»ĞµĞ¶Ğ¸Ğ²Ğ°Ğ½Ğ¸Ñ cooldown Ğ¼ĞµĞ¶Ğ´Ñƒ disambiguation Ğ¿Ğ¾Ğ¿Ñ‹Ñ‚ĞºĞ°Ğ¼Ğ¸.
# Blackboard ĞĞ• Ğ¢Ğ ĞĞ“ĞĞ•Ğ¢ ÑÑ‚Ğ¾Ñ‚ Ğ²Ñ‹Ğ·Ğ¾Ğ².

self.state_machine.increment_turn()

# ===========================================================================
# bot.py line 652 â€” ĞŸÑ€Ğ¾Ğ²ĞµÑ€ĞºĞ° disambiguation mode (Ğ”Ğ process)
# ===========================================================================
# Ğ•ÑĞ»Ğ¸ Ğ² disambiguation mode â€” Ğ¾Ğ±Ñ€Ğ°Ğ±Ğ°Ñ‚Ñ‹Ğ²Ğ°ĞµĞ¼ Ğ¾Ñ‚Ğ´ĞµĞ»ÑŒĞ½Ğ¾, ĞĞ• Ñ‡ĞµÑ€ĞµĞ· Blackboard.

if self.state_machine.in_disambiguation:
    return self._handle_disambiguation_response(user_message)

# ===========================================================================
# bot.py lines 743 â€” Fallback "skip" action (Ğ”Ğ process)
# ===========================================================================
# ConversationGuard Ğ¼Ğ¾Ğ¶ĞµÑ‚ Ğ²ĞµÑ€Ğ½ÑƒÑ‚ÑŒ "skip" action Ñ next_state.
# Blackboard Ğ”ĞĞ›Ğ–Ğ•Ğ Ğ²Ğ¸Ğ´ĞµÑ‚ÑŒ ÑÑ‚Ğ¾ Ğ¸Ğ·Ğ¼ĞµĞ½ĞµĞ½Ğ¸Ğµ Ğ¿Ñ€Ğ¸ Ñ‡Ñ‚ĞµĞ½Ğ¸Ğ¸ state Ğ² begin_turn().

elif fb_result.get("action") == "skip" and fb_result.get("next_state"):
    skip_next_state = fb_result["next_state"]
    self.state_machine.state = skip_next_state  # ĞŸÑ€ÑĞ¼Ğ°Ñ Ğ·Ğ°Ğ¿Ğ¸ÑÑŒ Ğ”Ğ process

# ===========================================================================
# bot.py lines 773-776 â€” Competitor extraction (Ğ”Ğ process)
# ===========================================================================
# Blackboard Ğ”ĞĞ›Ğ–Ğ•Ğ Ğ²Ğ¸Ğ´ĞµÑ‚ÑŒ ÑÑ‚Ğ¸ Ğ´Ğ°Ğ½Ğ½Ñ‹Ğµ Ğ¿Ñ€Ğ¸ Ñ‡Ñ‚ĞµĞ½Ğ¸Ğ¸ collected_data.

self.state_machine.collected_data["competitor_mentioned"] = True
self.state_machine.collected_data["competitor_name"] = competitor_name

# ===========================================================================
# bot.py line 944 â€” DialoguePolicy override (ĞŸĞĞ¡Ğ›Ğ• process)
# ===========================================================================
# DialoguePolicy Ğ¼Ğ¾Ğ¶ĞµÑ‚ Ğ¸Ğ·Ğ¼ĞµĞ½Ğ¸Ñ‚ÑŒ next_state ĞŸĞĞ¡Ğ›Ğ• process_turn().
# Ğ­Ñ‚Ğ¾ ĞŸĞ•Ğ Ğ•Ğ—ĞĞŸĞ˜Ğ¡Ğ«Ğ’ĞĞ•Ğ¢ state ÑƒÑÑ‚Ğ°Ğ½Ğ¾Ğ²Ğ»ĞµĞ½Ğ½Ñ‹Ğ¹ Ğ² _apply_side_effects().
# Ğ­Ñ‚Ğ¾ ĞĞĞ ĞœĞĞ›Ğ¬ĞĞĞ• Ğ¸ ĞĞ–Ğ˜Ğ”ĞĞ•ĞœĞĞ• Ğ¿Ğ¾Ğ²ĞµĞ´ĞµĞ½Ğ¸Ğµ.

if policy_override.next_state:
    sm_result["next_state"] = policy_override.next_state
    self.state_machine.state = policy_override.next_state  # ĞŸĞ•Ğ Ğ•Ğ—ĞĞŸĞ˜Ğ¡Ğ¬!

14.7 Ğ“Ğ°Ñ€Ğ°Ğ½Ñ‚Ğ¸Ğ¸ ÑĞ¾Ğ²Ğ¼ĞµÑÑ‚Ğ¸Ğ¼Ğ¾ÑÑ‚Ğ¸

DialogueOrchestrator._apply_side_effects() Ğ”ĞĞ›Ğ–Ğ•Ğ Ğ¿Ñ€Ğ¸Ğ¼ĞµĞ½ÑÑ‚ÑŒ side effects
Ğš Ğ¢ĞĞœĞ£ Ğ–Ğ• state_machine Ğ¾Ğ±ÑŠĞµĞºÑ‚Ñƒ, ĞºĞ¾Ñ‚Ğ¾Ñ€Ñ‹Ğ¹ bot.py Ğ¼Ğ¾Ğ´Ğ¸Ñ„Ğ¸Ñ†Ğ¸Ñ€ÑƒĞµÑ‚ Ğ½Ğ°Ğ¿Ñ€ÑĞ¼ÑƒÑ.

# Ğ’ _apply_side_effects():
def _apply_side_effects(
    self,
    decision: ResolvedDecision,
    prev_state: str,
    state_changed: bool,
) -> None:
    """
    Apply side effects to state_machine.

    ĞšĞ Ğ˜Ğ¢Ğ˜Ğ§ĞĞ: Ğ­Ñ‚Ğ¸ side effects Ğ¿Ñ€Ğ¸Ğ¼ĞµĞ½ÑÑÑ‚ÑÑ Ğº state_machine ĞºĞ¾Ñ‚Ğ¾Ñ€Ñ‹Ğ¹:
    1. ĞœĞ¾Ğ¶ĞµÑ‚ Ğ±Ñ‹Ñ‚ÑŒ Ğ˜Ğ—ĞœĞ•ĞĞĞ fallback "skip" Ğ”Ğ process_turn()
    2. ĞœĞ¾Ğ¶ĞµÑ‚ Ğ±Ñ‹Ñ‚ÑŒ ĞŸĞ•Ğ Ğ•Ğ—ĞĞŸĞ˜Ğ¡ĞĞ DialoguePolicy ĞŸĞĞ¡Ğ›Ğ• process_turn()

    ĞŸĞ¾Ñ€ÑĞ´Ğ¾Ğº Ğ²Ñ‹Ğ·Ğ¾Ğ²Ğ¾Ğ²:
    1. bot.py: state_machine.state = skip_next_state (fallback skip)
    2. bot.py: collected_data["competitor"] = ... (extraction)
    3. orchestrator: process_turn() â†’ _apply_side_effects()
    4. bot.py: state_machine.state = policy_next_state (DialoguePolicy)
    """
    # 1. Update state
    if decision.next_state != self._state_machine.state:
        self._state_machine.state = decision.next_state

    # 2. Update last_action
    self._state_machine.last_action = decision.action

    # 3. Update current_phase
    state_config = self._flow_config.states.get(decision.next_state, {})
    phase = state_config.get("phase") or state_config.get("spin_phase")
    self._state_machine.current_phase = phase

    # 4. Apply data_updates
    if decision.data_updates:
        self._state_machine.update_data(decision.data_updates)

    # 5. Apply on_enter flags when state changes
    if state_changed:
        on_enter_flags = self._flow_config.get_state_on_enter_flags(decision.next_state)
        for flag_name, flag_value in on_enter_flags.items():
            self._state_machine.collected_data[flag_name] = flag_value

15. Migration Plan (Updated: 6-8 weeks) â€” ĞŸĞĞ›ĞĞĞ¯ Ğ—ĞĞœĞ•ĞĞ
15.1 Timeline Overview

ĞŸĞ Ğ˜ĞĞ¦Ğ˜ĞŸ: ĞĞ¸ĞºĞ°ĞºĞ¾Ğ³Ğ¾ legacy ĞºĞ¾Ğ´Ğ°. StateMachine.apply_rules() ÑƒĞ´Ğ°Ğ»ÑĞµÑ‚ÑÑ Ğ¿Ğ¾Ğ»Ğ½Ğ¾ÑÑ‚ÑŒÑ.
         Blackboard â€” ĞµĞ´Ğ¸Ğ½ÑÑ‚Ğ²ĞµĞ½Ğ½Ğ°Ñ ÑĞ¸ÑÑ‚ĞµĞ¼Ğ° ÑƒĞ¿Ñ€Ğ°Ğ²Ğ»ĞµĞ½Ğ¸Ñ Ğ´Ğ¸Ğ°Ğ»Ğ¾Ğ³Ğ¾Ğ¼.

Week 1-2:   Phase 1 - Foundation (Core implementation + Unit tests)
Week 3-4:   Phase 2 - Integration & Regression Testing
Week 5-6:   Phase 3 - Legacy Removal & Full Deployment
Week 7-8:   Phase 4 - Stabilization & Documentation (buffer)
15.2 Phase 1: Foundation (Week 1-2)
Goals:

Implement all Blackboard components
Unit tests for each component
Prepare integration points with SalesBot
Tasks:


Week 1:
â”œâ”€â”€ Day 1-2: Core data structures
â”‚   â”œâ”€â”€ src/blackboard/__init__.py
â”‚   â”œâ”€â”€ src/blackboard/protocols.py (Hexagonal Architecture ports)
â”‚   â”œâ”€â”€ src/blackboard/enums.py (Priority, ProposalType)
â”‚   â””â”€â”€ src/blackboard/models.py (Proposal, ResolvedDecision, ContextSnapshot)
â”‚
â”œâ”€â”€ Day 3-4: DialogueBlackboard
â”‚   â”œâ”€â”€ src/blackboard/blackboard.py
â”‚   â””â”€â”€ tests/test_blackboard.py
â”‚
â””â”€â”€ Day 5: ProposalValidator & ConflictResolver
    â”œâ”€â”€ src/blackboard/proposal_validator.py
    â”œâ”€â”€ src/blackboard/conflict_resolver.py
    â”œâ”€â”€ tests/test_proposal_validator.py
    â””â”€â”€ tests/test_conflict_resolver.py

Week 2:
â”œâ”€â”€ Day 1-2: Knowledge Sources (Part 1) + Plugin System
â”‚   â”œâ”€â”€ src/blackboard/knowledge_source.py (base class)
â”‚   â”œâ”€â”€ src/blackboard/source_registry.py (Plugin System)
â”‚   â”œâ”€â”€ tests/test_source_registry.py
â”‚   â”œâ”€â”€ src/blackboard/sources/__init__.py (with auto-registration)
â”‚   â”œâ”€â”€ src/blackboard/sources/price_question.py
â”‚   â”œâ”€â”€ src/blackboard/sources/data_collector.py
â”‚   â””â”€â”€ tests/test_sources_part1.py
â”‚
â”œâ”€â”€ Day 3-4: Knowledge Sources (Part 2)
â”‚   â”œâ”€â”€ src/blackboard/sources/objection_guard.py
â”‚   â”œâ”€â”€ src/blackboard/sources/intent_processor.py
â”‚   â”œâ”€â”€ src/blackboard/sources/transition_resolver.py
â”‚   â”œâ”€â”€ src/blackboard/sources/escalation.py
â”‚   â””â”€â”€ tests/test_sources_part2.py
â”‚
â””â”€â”€ Day 5: EventBus & Orchestrator
    â”œâ”€â”€ src/blackboard/event_bus.py
    â”œâ”€â”€ src/blackboard/orchestrator.py
    â””â”€â”€ tests/test_orchestrator.py

Deliverables:

Complete /src/blackboard/ module
100% unit test coverage for new code

Risk Mitigation:

Comprehensive test suite before any integration
All tests must pass before Phase 2
15.3 Phase 2: Integration & Regression Testing (Week 3-4)
Goals:

Integrate Blackboard with SalesBot (replace apply_rules)
Comprehensive regression tests
Ensure behavioral parity for correct scenarios, improvements for buggy ones
Tasks:


Week 3:
â”œâ”€â”€ Day 1-2: SalesBot Integration
â”‚   â”œâ”€â”€ Modify src/bot.py to use DialogueOrchestrator
â”‚   â”œâ”€â”€ Remove ALL calls to StateMachine.apply_rules()
â”‚   â”œâ”€â”€ Update response generation to work with ResolvedDecision
â”‚   â””â”€â”€ tests/test_bot_integration.py
â”‚
â”œâ”€â”€ Day 3-4: Integration tests
â”‚   â”œâ”€â”€ tests/test_blackboard_integration.py
â”‚   â”œâ”€â”€ Test full pipeline: user_message â†’ response
â”‚   â”œâ”€â”€ Test all Knowledge Source combinations
â”‚   â””â”€â”€ Test all SPIN phases
â”‚
â””â”€â”€ Day 5: Edge case tests
    â”œâ”€â”€ tests/test_blackboard_edge_cases.py
    â”œâ”€â”€ Empty proposals
    â”œâ”€â”€ All sources disabled
    â”œâ”€â”€ Validation errors
    â””â”€â”€ Error recovery

Week 4:
â”œâ”€â”€ Day 1-2: Regression testing
â”‚   â”œâ”€â”€ tests/test_blackboard_regression.py
â”‚   â”œâ”€â”€ Port ALL existing state_machine tests
â”‚   â”œâ”€â”€ Document expected behavioral differences (bugs fixed)
â”‚   â””â”€â”€ Ensure improvements work correctly
â”‚
â”œâ”€â”€ Day 3-4: Historical replay & Performance
â”‚   â”œâ”€â”€ scripts/replay_conversations.py
â”‚   â”œâ”€â”€ Replay historical conversations through new system
â”‚   â”œâ”€â”€ Verify improvements (price_question + data_complete)
â”‚   â”œâ”€â”€ scripts/benchmark_blackboard.py
â”‚   â””â”€â”€ Measure latency, memory
â”‚
â””â”€â”€ Day 5: Bug fixes
    â””â”€â”€ Address any issues found during testing

Deliverables:

Working SalesBot with Blackboard (no legacy)
Full test suite (unit + integration + regression)
Performance benchmark results
Historical replay report showing improvements

Success Criteria:

All tests pass
Known bugs (price_question blocking) are fixed
Latency overhead < 10ms per turn
No regressions in correct behavior
15.4 Phase 3: Legacy Removal & Full Deployment (Week 5-6)
Goals:

ĞŸĞĞ›ĞĞĞ¡Ğ¢Ğ¬Ğ® ÑƒĞ´Ğ°Ğ»Ğ¸Ñ‚ÑŒ legacy ĞºĞ¾Ğ´ (apply_rules Ğ¸ ÑĞ²ÑĞ·Ğ°Ğ½Ğ½Ğ¾Ğµ)
Ğ Ğ°Ğ·Ğ²ĞµÑ€Ğ½ÑƒÑ‚ÑŒ Ğ½Ğ¾Ğ²ÑƒÑ ÑĞ¸ÑÑ‚ĞµĞ¼Ñƒ Ğ² production
Ğ£Ğ±Ñ€Ğ°Ñ‚ÑŒ Ğ²ÑĞµ feature flags Ğ¿ĞµÑ€ĞµĞºĞ»ÑÑ‡ĞµĞ½Ğ¸Ñ Ğ¼ĞµĞ¶Ğ´Ñƒ ÑĞ¸ÑÑ‚ĞµĞ¼Ğ°Ğ¼Ğ¸
Tasks:


Week 5:
â”œâ”€â”€ Day 1-2: Legacy Code Removal
â”‚   â”œâ”€â”€ DELETE: StateMachine.apply_rules() method (ÑÑ‚Ñ€Ğ¾ĞºĞ¸ 1265-1588)
â”‚   â”œâ”€â”€ DELETE: StateMachine._apply_rules_priority_driven() (ÑÑ‚Ñ€Ğ¾ĞºĞ¸ 1190-1263)
â”‚   â”œâ”€â”€ DELETE: StateMachine._apply_priority() (ÑÑ‚Ñ€Ğ¾ĞºĞ¸ 940-1045)
â”‚   â”œâ”€â”€ DELETE: StateMachine._priority_matches_intent() (ÑÑ‚Ñ€Ğ¾ĞºĞ¸ 1047-1097)
â”‚   â”œâ”€â”€ DELETE: StateMachine._evaluate_priority_condition() (ÑÑ‚Ñ€Ğ¾ĞºĞ¸ 1100-1128)
â”‚   â”œâ”€â”€ DELETE: StateMachine._call_priority_handler() (ÑÑ‚Ñ€Ğ¾ĞºĞ¸ 1130-1188)
â”‚   â”œâ”€â”€ DELETE: class RuleResult (ÑÑ‚Ñ€Ğ¾ĞºĞ¸ 58-89)
â”‚   â”œâ”€â”€ KEEP: StateMachine.state, collected_data, is_final() (used by Blackboard)
â”‚   â”œâ”€â”€ KEEP: IntentTracker (used by Blackboard)
â”‚   â””â”€â”€ Update imports throughout codebase
â”‚
â”œâ”€â”€ Day 3-4: Configuration Cleanup & Bot Integration
â”‚   â”œâ”€â”€ REMOVE: feature flags for legacy/blackboard switching (ĞµÑĞ»Ğ¸ ÑÑƒÑ‰ĞµÑÑ‚Ğ²ÑƒÑÑ‚)
â”‚   â”œâ”€â”€ REMOVE: shadow_mode configuration (ĞµÑĞ»Ğ¸ ÑÑƒÑ‰ĞµÑÑ‚Ğ²ÑƒĞµÑ‚)
â”‚   â”œâ”€â”€ REMOVE: blackboard_traffic_percentage (ĞµÑĞ»Ğ¸ ÑÑƒÑ‰ĞµÑÑ‚Ğ²ÑƒĞµÑ‚)
â”‚   â”œâ”€â”€ UPDATE: constants.yaml (keep only Blackboard config)
â”‚   â”œâ”€â”€ UPDATE: settings.yaml (remove legacy flags ĞµÑĞ»Ğ¸ ĞµÑÑ‚ÑŒ)
â”‚   â””â”€â”€ MODIFY: bot.py (Ğ·Ğ°Ğ¼ĞµĞ½Ğ¸Ñ‚ÑŒ Ğ²Ñ‹Ğ·Ğ¾Ğ²Ñ‹ apply_rules Ğ½Ğ° Orchestrator)
â”‚
â””â”€â”€ Day 5: Final Integration Testing
    â”œâ”€â”€ Run full test suite
    â”œâ”€â”€ Manual smoke testing of all scenarios
    â””â”€â”€ Verify no references to deleted code

Week 6:
â”œâ”€â”€ Day 1-2: Production Deployment
â”‚   â”œâ”€â”€ Deploy to staging environment
â”‚   â”œâ”€â”€ Full QA testing on staging
â”‚   â”œâ”€â”€ Deploy to production
â”‚   â””â”€â”€ Monitor closely for first 48 hours
â”‚
â”œâ”€â”€ Day 3-4: Production Monitoring
â”‚   â”œâ”€â”€ Monitor error rates
â”‚   â”œâ”€â”€ Monitor conversation metrics
â”‚   â”œâ”€â”€ Monitor performance metrics
â”‚   â””â”€â”€ Address any production issues
â”‚
â””â”€â”€ Day 5: Phase 3 Complete
    â”œâ”€â”€ Confirm stable operation
    â””â”€â”€ Document deployment results

Deliverables:

Clean codebase with NO legacy dialogue management code
Production deployment of Blackboard system
Monitoring dashboards

Success Criteria:

Zero references to apply_rules() in codebase
All tests pass after legacy removal
Production stable for 48+ hours
No increase in error rates

DELETED CODE (comprehensive list):

# src/state_machine.py â€” Ğ£Ğ”ĞĞ›Ğ˜Ğ¢Ğ¬ (~650 ÑÑ‚Ñ€Ğ¾Ğº):
- apply_rules() method (ÑÑ‚Ñ€Ğ¾ĞºĞ¸ 1265-1588, ~324 ÑÑ‚Ñ€Ğ¾ĞºĞ¸) â€” Ğ¾ÑĞ½Ğ¾Ğ²Ğ½Ğ¾Ğ¹ Ğ¼ĞµÑ‚Ğ¾Ğ´ legacy ÑĞ¸ÑÑ‚ĞµĞ¼Ñ‹
- _apply_rules_priority_driven() method (ÑÑ‚Ñ€Ğ¾ĞºĞ¸ 1190-1263, ~74 ÑÑ‚Ñ€Ğ¾ĞºĞ¸)
- _apply_priority() method (ÑÑ‚Ñ€Ğ¾ĞºĞ¸ 940-1045, ~106 ÑÑ‚Ñ€Ğ¾Ğº)
- _priority_matches_intent() method (ÑÑ‚Ñ€Ğ¾ĞºĞ¸ 1047-1097, ~51 ÑÑ‚Ñ€Ğ¾ĞºĞ°)
- _evaluate_priority_condition() method (ÑÑ‚Ñ€Ğ¾ĞºĞ¸ 1100-1128, ~29 ÑÑ‚Ñ€Ğ¾Ğº)
- _call_priority_handler() method (ÑÑ‚Ñ€Ğ¾ĞºĞ¸ 1130-1188, ~59 ÑÑ‚Ñ€Ğ¾Ğº)
- class RuleResult (ÑÑ‚Ñ€Ğ¾ĞºĞ¸ 58-89, ~32 ÑÑ‚Ñ€Ğ¾ĞºĞ¸)

# src/bot.py â€” ĞœĞĞ”Ğ˜Ğ¤Ğ˜ĞšĞĞ¦Ğ˜Ğ¯ (ĞĞ• ÑƒĞ´Ğ°Ğ»ĞµĞ½Ğ¸Ğµ):
# ĞŸĞ Ğ˜ĞœĞ•Ğ§ĞĞĞ˜Ğ•: Shadow mode Ğ¼ĞµÑ‚Ğ¾Ğ´Ñ‹ (_process_shadow_mode, _compare_shadow_results Ğ¸ Ñ‚.Ğ´.)
# ĞĞ• Ğ¡Ğ£Ğ©Ğ•Ğ¡Ğ¢Ğ’Ğ£Ğ®Ğ¢ Ğ² Ñ‚ĞµĞºÑƒÑ‰ĞµĞ¹ ĞºĞ¾Ğ´Ğ¾Ğ²Ğ¾Ğ¹ Ğ±Ğ°Ğ·Ğµ, Ñ‚Ğ°Ğº ĞºĞ°Ğº ÑÑ‚Ñ€Ğ°Ñ‚ĞµĞ³Ğ¸Ñ "ĞŸĞĞ›ĞĞĞ¯ Ğ—ĞĞœĞ•ĞĞ"
# Ğ±Ñ‹Ğ»Ğ° Ğ²Ñ‹Ğ±Ñ€Ğ°Ğ½Ğ° Ğ¸Ğ·Ğ½Ğ°Ñ‡Ğ°Ğ»ÑŒĞ½Ğ¾. ĞœĞ¾Ğ´Ğ¸Ñ„Ğ¸ĞºĞ°Ñ†Ğ¸Ñ bot.py Ğ·Ğ°ĞºĞ»ÑÑ‡Ğ°ĞµÑ‚ÑÑ Ğ²:
- Ğ—Ğ°Ğ¼ĞµĞ½Ğµ Ğ²Ñ‹Ğ·Ğ¾Ğ²Ğ¾Ğ² state_machine.apply_rules() Ğ½Ğ° DialogueOrchestrator.process()
- Ğ˜Ğ½Ñ‚ĞµĞ³Ñ€Ğ°Ñ†Ğ¸Ğ¸ Ñ Ğ½Ğ¾Ğ²Ñ‹Ğ¼ Blackboard API
- ĞĞ±Ğ½Ğ¾Ğ²Ğ»ĞµĞ½Ğ¸Ğ¸ Ğ¾Ğ±Ñ€Ğ°Ğ±Ğ¾Ñ‚ĞºĞ¸ Ñ€ĞµĞ·ÑƒĞ»ÑŒÑ‚Ğ°Ñ‚Ğ¾Ğ² (ResolvedDecision Ğ²Ğ¼ĞµÑÑ‚Ğ¾ Tuple[str, str])

# src/settings.yaml â€” ĞŸĞ ĞĞ’Ğ•Ğ Ğ˜Ğ¢Ğ¬ Ğ˜ Ğ£Ğ”ĞĞ›Ğ˜Ğ¢Ğ¬ (ĞµÑĞ»Ğ¸ ÑÑƒÑ‰ĞµÑÑ‚Ğ²ÑƒÑÑ‚):
- blackboard_enabled flag
- blackboard_shadow_mode flag
- blackboard_traffic_percentage flag
- Ğ›ÑĞ±Ñ‹Ğµ legacy/blackboard switching flags

# src/yaml_config/constants.yaml â€” ĞŸĞ ĞĞ’Ğ•Ğ Ğ˜Ğ¢Ğ¬ Ğ˜ Ğ£Ğ”ĞĞ›Ğ˜Ğ¢Ğ¬ (ĞµÑĞ»Ğ¸ ÑÑƒÑ‰ĞµÑÑ‚Ğ²ÑƒÑÑ‚):
- shadow_mode section
- Ğ›ÑĞ±Ğ°Ñ legacy-specific configuration
15.5 Phase 4: Stabilization & Documentation (Week 7-8) â€” BUFFER
Goals:

Ğ¡Ñ‚Ğ°Ğ±Ğ¸Ğ»Ğ¸Ğ·Ğ°Ñ†Ğ¸Ñ production ÑĞ¸ÑÑ‚ĞµĞ¼Ñ‹
Ğ”Ğ¾ĞºÑƒĞ¼ĞµĞ½Ñ‚Ğ°Ñ†Ğ¸Ñ Ğ½Ğ¾Ğ²Ğ¾Ğ¹ Ğ°Ñ€Ñ…Ğ¸Ñ‚ĞµĞºÑ‚ÑƒÑ€Ñ‹
ĞĞ±ÑƒÑ‡ĞµĞ½Ğ¸Ğµ ĞºĞ¾Ğ¼Ğ°Ğ½Ğ´Ñ‹
ĞĞ¿Ñ‚Ğ¸Ğ¼Ğ¸Ğ·Ğ°Ñ†Ğ¸Ñ Ğ¿Ğ¾ Ñ€ĞµĞ·ÑƒĞ»ÑŒÑ‚Ğ°Ñ‚Ğ°Ğ¼ Ğ¼Ğ¾Ğ½Ğ¸Ñ‚Ğ¾Ñ€Ğ¸Ğ½Ğ³Ğ°
Tasks:


Week 7:
â”œâ”€â”€ Day 1-2: Production Optimization
â”‚   â”œâ”€â”€ Analyze production metrics
â”‚   â”œâ”€â”€ Identify and fix any performance bottlenecks
â”‚   â”œâ”€â”€ Tune Knowledge Source configurations
â”‚   â””â”€â”€ Optimize based on real usage patterns
â”‚
â”œâ”€â”€ Day 3-4: Documentation
â”‚   â”œâ”€â”€ Architecture documentation (ĞºĞ°Ğº Ñ€Ğ°Ğ±Ğ¾Ñ‚Ğ°ĞµÑ‚ Blackboard)
â”‚   â”œâ”€â”€ Knowledge Source development guide
â”‚   â”œâ”€â”€ Troubleshooting guide
â”‚   â”œâ”€â”€ Runbook updates
â”‚   â””â”€â”€ API documentation for DialogueOrchestrator
â”‚
â””â”€â”€ Day 5: Code Quality
    â”œâ”€â”€ Code review Ğ²ÑĞµĞ³Ğ¾ Ğ½Ğ¾Ğ²Ğ¾Ğ³Ğ¾ ĞºĞ¾Ğ´Ğ°
    â”œâ”€â”€ Ensure consistent code style
    â””â”€â”€ Add any missing docstrings/comments

Week 8:
â”œâ”€â”€ Day 1-2: Knowledge Transfer
â”‚   â”œâ”€â”€ Team training session
â”‚   â”œâ”€â”€ Q&A sessions
â”‚   â”œâ”€â”€ Pair programming Ğ½Ğ° Ğ´Ğ¾Ğ±Ğ°Ğ²Ğ»ĞµĞ½Ğ¸Ğµ Ğ½Ğ¾Ğ²Ğ¾Ğ³Ğ¾ Knowledge Source
â”‚   â””â”€â”€ Review best practices
â”‚
â”œâ”€â”€ Day 3-4: Final Polish
â”‚   â”œâ”€â”€ Address any feedback from documentation review
â”‚   â”œâ”€â”€ Final test suite review
â”‚   â”œâ”€â”€ Performance optimization if needed
â”‚   â””â”€â”€ Clean up any TODO comments
â”‚
â””â”€â”€ Day 5: Project Completion
    â”œâ”€â”€ Final documentation review
    â”œâ”€â”€ Project retrospective
    â”œâ”€â”€ Archive old documentation
    â””â”€â”€ Celebrate successful migration! ğŸ‰

Deliverables:

Stable production system (2+ weeks running)
Complete documentation
Team trained on new architecture
Clean, maintainable codebase

Success Criteria:

No production incidents for 2 weeks
All team members can explain Blackboard architecture
At least one team member can add a new Knowledge Source independently
Documentation complete and reviewed
15.6 Rollback Strategy (Emergency Only)

Ğ’ĞĞ–ĞĞ: Ğ’ ÑÑ‚Ğ¾Ğ¼ Ğ¿Ğ»Ğ°Ğ½Ğµ Ğ½ĞµÑ‚ Ğ¿Ğ¾ÑÑ‚ĞµĞ¿ĞµĞ½Ğ½Ğ¾Ğ³Ğ¾ Ğ¾Ñ‚ĞºĞ°Ñ‚Ğ°. Ğ•ÑĞ»Ğ¸ Ğ½ÑƒĞ¶ĞµĞ½ Ğ¾Ñ‚ĞºĞ°Ñ‚ â€” ÑÑ‚Ğ¾ git revert.

Rollback Procedure (EMERGENCY ONLY):

# Ğ•ÑĞ»Ğ¸ Ğ¾Ğ±Ğ½Ğ°Ñ€ÑƒĞ¶ĞµĞ½Ğ° ĞºÑ€Ğ¸Ñ‚Ğ¸Ñ‡ĞµÑĞºĞ°Ñ Ğ¿Ñ€Ğ¾Ğ±Ğ»ĞµĞ¼Ğ° Ğ¿Ğ¾ÑĞ»Ğµ deployment:

# 1. Git revert Ğº Ğ¿Ğ¾ÑĞ»ĞµĞ´Ğ½ĞµĞ¼Ñƒ ÑÑ‚Ğ°Ğ±Ğ¸Ğ»ÑŒĞ½Ğ¾Ğ¼Ñƒ ĞºĞ¾Ğ¼Ğ¼Ğ¸Ñ‚Ñƒ
git revert HEAD~N  # Ğ³Ğ´Ğµ N = ĞºĞ¾Ğ»Ğ¸Ñ‡ĞµÑÑ‚Ğ²Ğ¾ ĞºĞ¾Ğ¼Ğ¼Ğ¸Ñ‚Ğ¾Ğ² Blackboard

# 2. Ğ˜Ğ»Ğ¸ Ğ¿ĞµÑ€ĞµĞºĞ»ÑÑ‡Ğ¸Ñ‚ÑŒÑÑ Ğ½Ğ° pre-blackboard branch
git checkout pre-blackboard-migration
git push -f origin main

# 3. Redeploy
kubectl rollout restart deployment/salesbot

ĞšĞ¾Ğ³Ğ´Ğ° Ğ¸ÑĞ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ÑŒ Ğ¾Ñ‚ĞºĞ°Ñ‚:

- ĞšÑ€Ğ¸Ñ‚Ğ¸Ñ‡ĞµÑĞºĞ¸Ğµ Ğ±Ğ°Ğ³Ğ¸, Ğ²Ğ»Ğ¸ÑÑÑ‰Ğ¸Ğµ Ğ½Ğ° >10% Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»ĞµĞ¹
- ĞŸĞ¾Ğ»Ğ½Ğ°Ñ Ğ½ĞµÑ€Ğ°Ğ±Ğ¾Ñ‚Ğ¾ÑĞ¿Ğ¾ÑĞ¾Ğ±Ğ½Ğ¾ÑÑ‚ÑŒ Ğ±Ğ¾Ñ‚Ğ°
- Data corruption

ĞšĞ¾Ğ³Ğ´Ğ° ĞĞ• Ğ¾Ñ‚ĞºĞ°Ñ‚Ñ‹Ğ²Ğ°Ñ‚ÑŒ:

- ĞœĞµĞ»ĞºĞ¸Ğµ Ğ±Ğ°Ğ³Ğ¸ (Ğ¸ÑĞ¿Ñ€Ğ°Ğ²Ğ¸Ñ‚ÑŒ Ğ² hotfix)
- ĞŸÑ€Ğ¾Ğ¸Ğ·Ğ²Ğ¾Ğ´Ğ¸Ñ‚ĞµĞ»ÑŒĞ½Ğ¾ÑÑ‚ÑŒ Ñ‡ÑƒÑ‚ÑŒ Ñ…ÑƒĞ¶Ğµ (Ğ¾Ğ¿Ñ‚Ğ¸Ğ¼Ğ¸Ğ·Ğ¸Ñ€Ğ¾Ğ²Ğ°Ñ‚ÑŒ)
- ĞĞ´Ğ¸Ğ½-Ğ´Ğ²Ğ° edge cases Ğ½Ğµ Ñ€Ğ°Ğ±Ğ¾Ñ‚Ğ°ÑÑ‚ (Ğ¸ÑĞ¿Ñ€Ğ°Ğ²Ğ¸Ñ‚ÑŒ)

Pre-deployment Checklist (Ñ‡Ñ‚Ğ¾Ğ±Ñ‹ Ğ¸Ğ·Ğ±ĞµĞ¶Ğ°Ñ‚ÑŒ Ğ¾Ñ‚ĞºĞ°Ñ‚Ğ°):

- [ ] Ğ’ÑĞµ unit tests Ğ¿Ñ€Ğ¾Ñ…Ğ¾Ğ´ÑÑ‚
- [ ] Ğ’ÑĞµ integration tests Ğ¿Ñ€Ğ¾Ñ…Ğ¾Ğ´ÑÑ‚
- [ ] Ğ’ÑĞµ regression tests Ğ¿Ñ€Ğ¾Ñ…Ğ¾Ğ´ÑÑ‚
- [ ] Historical replay Ğ¿Ğ¾ĞºĞ°Ğ·Ñ‹Ğ²Ğ°ĞµÑ‚ ÑƒĞ»ÑƒÑ‡ÑˆĞµĞ½Ğ¸Ñ
- [ ] Performance benchmark Ğ² Ğ¿Ñ€ĞµĞ´ĞµĞ»Ğ°Ñ… Ğ½Ğ¾Ñ€Ğ¼Ñ‹
- [ ] Manual testing Ğ²ÑĞµÑ… Ğ¾ÑĞ½Ğ¾Ğ²Ğ½Ñ‹Ñ… ÑÑ†ĞµĞ½Ğ°Ñ€Ğ¸ĞµĞ²
- [ ] Code review Ğ¿Ñ€Ğ¾Ğ¹Ğ´ĞµĞ½
16. File Structure Summary

=== ĞĞĞ’Ğ«Ğ• Ğ¤ĞĞ™Ğ›Ğ« (ÑĞ¾Ğ·Ğ´Ğ°ÑÑ‚ÑÑ) ===

src/blackboard/
â”œâ”€â”€ __init__.py                    # Module exports
â”œâ”€â”€ protocols.py                   # Hexagonal Architecture ports (IStateMachine, IFlowConfig, ITenantConfig)
â”œâ”€â”€ enums.py                       # Priority, ProposalType enums
â”œâ”€â”€ models.py                      # Proposal, ResolvedDecision, ContextSnapshot
â”œâ”€â”€ blackboard.py                  # DialogueBlackboard class
â”œâ”€â”€ knowledge_source.py            # KnowledgeSource ABC
â”œâ”€â”€ source_registry.py             # SourceRegistry (Plugin System)
â”œâ”€â”€ conflict_resolver.py           # ConflictResolver class
â”œâ”€â”€ proposal_validator.py          # ProposalValidator class
â”œâ”€â”€ event_bus.py                   # DialogueEventBus, events, subscribers
â”œâ”€â”€ orchestrator.py                # DialogueOrchestrator, factory function
â””â”€â”€ sources/
    â”œâ”€â”€ __init__.py                # Source exports + auto-registration
    â”œâ”€â”€ price_question.py          # PriceQuestionSource
    â”œâ”€â”€ data_collector.py          # DataCollectorSource
    â”œâ”€â”€ objection_guard.py         # ObjectionGuardSource
    â”œâ”€â”€ intent_processor.py        # IntentProcessorSource
    â”œâ”€â”€ transition_resolver.py     # TransitionResolverSource
    â””â”€â”€ escalation.py              # EscalationSource

tests/
â”œâ”€â”€ test_protocols.py              # Protocol compliance tests
â”œâ”€â”€ test_blackboard.py             # DialogueBlackboard tests
â”œâ”€â”€ test_conflict_resolver.py      # ConflictResolver tests
â”œâ”€â”€ test_proposal_validator.py     # ProposalValidator tests
â”œâ”€â”€ test_event_bus.py              # EventBus tests
â”œâ”€â”€ test_orchestrator.py           # Orchestrator tests
â”œâ”€â”€ test_source_registry.py        # SourceRegistry tests
â”œâ”€â”€ test_sources_price.py          # PriceQuestionSource tests
â”œâ”€â”€ test_sources_data.py           # DataCollectorSource tests
â”œâ”€â”€ test_sources_objection.py      # ObjectionGuardSource tests
â”œâ”€â”€ test_sources_intent.py         # IntentProcessorSource tests
â”œâ”€â”€ test_sources_transition.py     # TransitionResolverSource tests
â”œâ”€â”€ test_sources_escalation.py     # EscalationSource tests
â”œâ”€â”€ test_blackboard_integration.py # Integration tests
â”œâ”€â”€ test_blackboard_regression.py  # Regression tests
â””â”€â”€ test_multi_tenancy.py          # Multi-tenancy isolation tests

=== ĞœĞĞ”Ğ˜Ğ¤Ğ˜Ğ¦Ğ˜Ğ Ğ£Ğ•ĞœĞ«Ğ• Ğ¤ĞĞ™Ğ›Ğ« ===

src/bot.py                         # ĞœĞĞ”Ğ˜Ğ¤Ğ˜Ğ¦Ğ˜Ğ ĞĞ’ĞĞ: Ğ¸ÑĞ¿Ğ¾Ğ»ÑŒĞ·ÑƒĞµÑ‚ DialogueOrchestrator
src/state_machine.py               # ĞĞ§Ğ˜Ğ©Ğ•Ğ: ÑƒĞ´Ğ°Ğ»Ñ‘Ğ½ apply_rules() Ğ¸ ÑĞ²ÑĞ·Ğ°Ğ½Ğ½Ñ‹Ğ¹ ĞºĞ¾Ğ´
src/yaml_config/constants.yaml     # ĞĞ‘ĞĞĞ’Ğ›ĞĞ: Blackboard config (ĞµÑĞ»Ğ¸ Ğ½ÑƒĞ¶Ğ½Ñ‹ Ğ¸Ğ·Ğ¼ĞµĞ½ĞµĞ½Ğ¸Ñ)
src/settings.yaml                  # ĞĞ§Ğ˜Ğ©Ğ•Ğ: ÑƒĞ´Ğ°Ğ»ĞµĞ½Ñ‹ legacy flags (ĞµÑĞ»Ğ¸ ÑÑƒÑ‰ĞµÑÑ‚Ğ²ÑƒÑÑ‚)

=== Ğ£Ğ”ĞĞ›Ğ¯Ğ•ĞœĞ«Ğ™ ĞšĞĞ” (Ğ¸Ğ· ÑÑƒÑ‰ĞµÑÑ‚Ğ²ÑƒÑÑ‰Ğ¸Ñ… Ñ„Ğ°Ğ¹Ğ»Ğ¾Ğ²) ===

# src/state_machine.py â€” Ğ£Ğ”ĞĞ›Ğ˜Ğ¢Ğ¬ (~650 ÑÑ‚Ñ€Ğ¾Ğº):
StateMachine.apply_rules()                # ÑÑ‚Ñ€Ğ¾ĞºĞ¸ 1265-1588 (~324 ÑÑ‚Ñ€Ğ¾ĞºĞ¸)
StateMachine._apply_rules_priority_driven() # ÑÑ‚Ñ€Ğ¾ĞºĞ¸ 1190-1263 (~74 ÑÑ‚Ñ€Ğ¾ĞºĞ¸)
StateMachine._apply_priority()            # ÑÑ‚Ñ€Ğ¾ĞºĞ¸ 940-1045 (~106 ÑÑ‚Ñ€Ğ¾Ğº)
StateMachine._priority_matches_intent()   # ÑÑ‚Ñ€Ğ¾ĞºĞ¸ 1047-1097 (~51 ÑÑ‚Ñ€Ğ¾ĞºĞ°)
StateMachine._evaluate_priority_condition() # ÑÑ‚Ñ€Ğ¾ĞºĞ¸ 1100-1128 (~29 ÑÑ‚Ñ€Ğ¾Ğº)
StateMachine._call_priority_handler()     # ÑÑ‚Ñ€Ğ¾ĞºĞ¸ 1130-1188 (~59 ÑÑ‚Ñ€Ğ¾Ğº)
class RuleResult                          # ÑÑ‚Ñ€Ğ¾ĞºĞ¸ 58-89 (~32 ÑÑ‚Ñ€Ğ¾ĞºĞ¸)

# src/bot.py â€” ĞœĞĞ”Ğ˜Ğ¤Ğ˜Ğ¦Ğ˜Ğ ĞĞ’ĞĞ¢Ğ¬ (Ğ½Ğµ ÑƒĞ´Ğ°Ğ»ÑÑ‚ÑŒ Ğ¼ĞµÑ‚Ğ¾Ğ´Ñ‹):
# Shadow mode Ğ¼ĞµÑ‚Ğ¾Ğ´Ñ‹ (_process_shadow_mode Ğ¸ Ñ‚.Ğ´.) ĞĞ• Ğ¡Ğ£Ğ©Ğ•Ğ¡Ğ¢Ğ’Ğ£Ğ®Ğ¢ Ğ² Ñ‚ĞµĞºÑƒÑ‰ĞµĞ¼ ĞºĞ¾Ğ´Ğµ.
# ĞœĞ¾Ğ´Ğ¸Ñ„Ğ¸ĞºĞ°Ñ†Ğ¸Ñ: Ğ·Ğ°Ğ¼ĞµĞ½Ğ¸Ñ‚ÑŒ Ğ²Ñ‹Ğ·Ğ¾Ğ²Ñ‹ apply_rules() Ğ½Ğ° DialogueOrchestrator.process()

# src/settings.yaml â€” ĞŸĞ ĞĞ’Ğ•Ğ Ğ˜Ğ¢Ğ¬ Ğ˜ Ğ£Ğ”ĞĞ›Ğ˜Ğ¢Ğ¬ (ĞµÑĞ»Ğ¸ ÑÑƒÑ‰ĞµÑÑ‚Ğ²ÑƒÑÑ‚):
blackboard_enabled
blackboard_shadow_mode
blackboard_traffic_percentage

=== Ğ§Ğ¢Ğ ĞĞ¡Ğ¢ĞĞĞ¢Ğ¡Ğ¯ Ğ’ state_machine.py ===

# StateMachine Ğ¸ÑĞ¿Ğ¾Ğ»ÑŒĞ·ÑƒĞµÑ‚ÑÑ Blackboard Ğ´Ğ»Ñ:
StateMachine.state                 # property: Ñ‚ĞµĞºÑƒÑ‰ĞµĞµ ÑĞ¾ÑÑ‚Ğ¾ÑĞ½Ğ¸Ğµ
StateMachine.collected_data        # property: ÑĞ¾Ğ±Ñ€Ğ°Ğ½Ğ½Ñ‹Ğµ Ğ´Ğ°Ğ½Ğ½Ñ‹Ğµ
StateMachine.is_final()            # method: Ğ¿Ñ€Ğ¾Ğ²ĞµÑ€ĞºĞ° Ñ„Ğ¸Ğ½Ğ°Ğ»ÑŒĞ½Ğ¾Ğ³Ğ¾ ÑĞ¾ÑÑ‚Ğ¾ÑĞ½Ğ¸Ñ
StateMachine._intent_tracker       # IntentTracker instance

# IntentTracker Ğ¾ÑÑ‚Ğ°Ñ‘Ñ‚ÑÑ Ğ¿Ğ¾Ğ»Ğ½Ğ¾ÑÑ‚ÑŒÑ:
IntentTracker.turn_number
IntentTracker.prev_intent
IntentTracker.record()
IntentTracker.objection_consecutive()
IntentTracker.objection_total()
IntentTracker.total_count()
IntentTracker.category_total()
ĞŸÑ€Ğ¾Ğ´Ğ¾Ğ»Ğ¶Ğ°Ñ Ñ ÑĞµĞ´ÑŒĞ¼Ğ¾Ğ¹ Ñ‡Ğ°ÑÑ‚ÑŒÑ â€” Testing Suite Ğ¸ Verification.

Ğ¿Ñ€Ğ¾Ğ´Ğ¾Ğ»Ğ¶Ğ°Ğ¹
Ğ§Ğ°ÑÑ‚ÑŒ 7: Testing Suite Ğ¸ Verification
17. Unit Tests
17.0 Test Protocols (Hexagonal Architecture)

# tests/test_protocols.py

"""
Tests for Protocol compliance (Hexagonal Architecture).

These tests verify that concrete implementations properly implement
the required protocols, ensuring Dependency Inversion principle.
"""

import pytest
from typing import Dict, Any, Optional

from src.blackboard.protocols import (
    IStateMachine,
    IIntentTracker,
    IFlowConfig,
    ITenantConfig,
    TenantConfig,
    DEFAULT_TENANT,
)


class TestProtocolCompliance:
    """Test that concrete classes implement protocols correctly."""

    def test_state_machine_implements_protocol(self):
        """Verify StateMachine implements IStateMachine protocol."""
        from src.state_machine import StateMachine

        # Runtime check using isinstance with runtime_checkable protocol
        sm = StateMachine()
        assert isinstance(sm, IStateMachine), (
            "StateMachine must implement IStateMachine protocol"
        )

    def test_intent_tracker_implements_protocol(self):
        """Verify IntentTracker implements IIntentTracker protocol."""
        from src.intent_tracker import IntentTracker

        tracker = IntentTracker()
        assert isinstance(tracker, IIntentTracker), (
            "IntentTracker must implement IIntentTracker protocol"
        )

    def test_flow_config_implements_protocol(self):
        """Verify FlowConfig implements IFlowConfig protocol."""
        from src.config_loader import FlowConfig

        config = FlowConfig(states={}, constants={})
        assert isinstance(config, IFlowConfig), (
            "FlowConfig must implement IFlowConfig protocol"
        )


class TestTenantConfig:
    """Test TenantConfig implementation."""

    def test_default_tenant_exists(self):
        """Verify DEFAULT_TENANT is available."""
        assert DEFAULT_TENANT is not None
        assert DEFAULT_TENANT.tenant_id == "default"

    def test_tenant_config_creation(self):
        """Test creating custom tenant config."""
        tenant = TenantConfig(
            tenant_id="acme_corp",
            bot_name="ACME Assistant",
            tone="friendly",
            features={"escalation": True, "price_questions": False},
            persona_limits_override={
                "aggressive": {"consecutive": 10, "total": 15}
            },
        )

        assert tenant.tenant_id == "acme_corp"
        assert tenant.bot_name == "ACME Assistant"
        assert tenant.tone == "friendly"
        assert tenant.features["escalation"] is True
        assert tenant.features["price_questions"] is False
        assert tenant.persona_limits_override["aggressive"]["consecutive"] == 10

    def test_tenant_config_default_features(self):
        """Test that features defaults to empty dict."""
        tenant = TenantConfig(tenant_id="test")
        assert tenant.features == {}

    def test_tenant_implements_protocol(self):
        """Verify TenantConfig implements ITenantConfig protocol."""
        tenant = TenantConfig(tenant_id="test")
        assert isinstance(tenant, ITenantConfig)


class TestMockImplementations:
    """Test that mock implementations work with protocols."""

    def test_mock_state_machine_for_testing(self):
        """
        Demonstrate how to create a mock that implements IStateMachine.

        This is useful for unit testing without real StateMachine.
        """
        class MockStateMachine:
            def __init__(self):
                self._state = "greeting"
                self._collected_data = {}
                self._intent_tracker = MockIntentTracker()

            @property
            def state(self) -> str:
                return self._state

            @state.setter
            def state(self, value: str) -> None:
                self._state = value

            @property
            def collected_data(self) -> Dict[str, Any]:
                return self._collected_data

            def is_final(self) -> bool:
                return self._state == "closed"

        class MockIntentTracker:
            @property
            def turn_number(self) -> int:
                return 1

            @property
            def prev_intent(self) -> Optional[str]:
                return None

            def record(self, intent: str, state: str) -> None:
                pass

            def objection_consecutive(self) -> int:
                return 0

            def objection_total(self) -> int:
                return 0

            def total_count(self, intent: str) -> int:
                return 0

            def category_total(self, category: str) -> int:
                return 0

        mock_sm = MockStateMachine()
        assert isinstance(mock_sm, IStateMachine)

        # Use mock in DialogueBlackboard
        from src.blackboard.blackboard import DialogueBlackboard
        from src.blackboard.protocols import DEFAULT_TENANT

        class MockFlowConfig:
            @property
            def states(self) -> Dict[str, Dict[str, Any]]:
                return {"greeting": {"goal": "Test"}}

            def to_dict(self) -> Dict[str, Any]:
                return {"states": self.states}

        bb = DialogueBlackboard(
            state_machine=mock_sm,
            flow_config=MockFlowConfig(),
            tenant_config=DEFAULT_TENANT,
        )
        assert bb.tenant_id == "default"

17.1 Test DialogueBlackboard

# tests/test_blackboard.py

import pytest
from unittest.mock import Mock, MagicMock
from datetime import datetime

from src.blackboard.blackboard import DialogueBlackboard
from src.blackboard.models import Proposal, ContextSnapshot
from src.blackboard.enums import Priority, ProposalType
from src.blackboard.protocols import TenantConfig, DEFAULT_TENANT


class TestDialogueBlackboard:
    """Test suite for DialogueBlackboard class."""
    
    @pytest.fixture
    def mock_state_machine(self):
        """Create a mock state machine."""
        sm = Mock()
        sm.state = "spin_situation"
        sm.collected_data = {"company_size": "50"}
        sm._intent_tracker = Mock()
        sm._intent_tracker.turn_number = 5
        sm._intent_tracker.prev_intent = "greeting"
        sm._intent_tracker.objection_consecutive.return_value = 0
        sm._intent_tracker.objection_total.return_value = 0
        return sm
    
    @pytest.fixture
    def mock_flow_config(self):
        """Create a mock flow config."""
        config = Mock()
        config.states = {
            "spin_situation": {
                "goal": "Understand situation",
                "phase": "situation",
                "required_data": ["company_size"],
                "transitions": {
                    "data_complete": "spin_problem",
                    "rejection": "soft_close",
                },
                "rules": {
                    "unclear": "probe_situation",
                },
            },
            "spin_problem": {
                "goal": "Identify problems",
                "phase": "problem",
            },
            "soft_close": {
                "goal": "Graceful exit",
                "is_final": True,
            },
        }
        return config
    
    @pytest.fixture
    def blackboard(self, mock_state_machine, mock_flow_config):
        """Create a blackboard instance."""
        return DialogueBlackboard(
            state_machine=mock_state_machine,
            flow_config=mock_flow_config,
        )
    
    # === begin_turn tests ===
    
    def test_begin_turn_initializes_context(self, blackboard, mock_state_machine):
        """begin_turn should create a ContextSnapshot."""
        blackboard.begin_turn(
            intent="price_question",
            extracted_data={"pain_point": "no analytics"},
            context_envelope=None,
        )
        
        ctx = blackboard.get_context()
        
        assert ctx.state == "spin_situation"
        assert ctx.current_intent == "price_question"
        assert ctx.collected_data["company_size"] == "50"
        assert ctx.collected_data["pain_point"] == "no analytics"
    
    def test_begin_turn_records_intent(self, blackboard, mock_state_machine):
        """begin_turn should record intent in tracker."""
        blackboard.begin_turn(
            intent="price_question",
            extracted_data={},
            context_envelope=None,
        )
        
        mock_state_machine._intent_tracker.record.assert_called_once_with(
            "price_question", "spin_situation"
        )
    
    def test_begin_turn_clears_previous_proposals(self, blackboard):
        """begin_turn should clear previous proposals."""
        # Add some proposals
        blackboard.begin_turn("intent1", {}, None)
        blackboard.propose_action("action1", Priority.HIGH)
        blackboard.propose_transition("state1", Priority.NORMAL)
        
        assert len(blackboard.get_proposals()) == 2
        
        # Begin new turn
        blackboard.begin_turn("intent2", {}, None)
        
        assert len(blackboard.get_proposals()) == 0
    
    def test_begin_turn_merges_extracted_data(self, blackboard, mock_state_machine):
        """begin_turn should merge new data with existing."""
        mock_state_machine.collected_data = {"field1": "value1"}
        
        blackboard.begin_turn(
            intent="test",
            extracted_data={"field2": "value2"},
            context_envelope=None,
        )
        
        ctx = blackboard.get_context()
        assert ctx.collected_data["field1"] == "value1"
        assert ctx.collected_data["field2"] == "value2"
    
    def test_begin_turn_does_not_overwrite_with_empty(self, blackboard, mock_state_machine):
        """begin_turn should not overwrite with empty values."""
        mock_state_machine.collected_data = {"field1": "original"}
        
        blackboard.begin_turn(
            intent="test",
            extracted_data={"field1": "", "field2": None},
            context_envelope=None,
        )
        
        ctx = blackboard.get_context()
        assert ctx.collected_data["field1"] == "original"
        assert "field2" not in ctx.collected_data or ctx.collected_data["field2"] is None
    
    # === get_context tests ===
    
    def test_get_context_before_begin_turn_raises(self, blackboard):
        """get_context should raise if called before begin_turn."""
        with pytest.raises(RuntimeError, match="before begin_turn"):
            blackboard.get_context()
    
    def test_get_context_returns_immutable_snapshot(self, blackboard):
        """get_context should return frozen dataclass."""
        blackboard.begin_turn("test", {}, None)
        ctx = blackboard.get_context()
        
        # ContextSnapshot is frozen, should not allow modification
        with pytest.raises(AttributeError):
            ctx.state = "new_state"
    
    # === propose_action tests ===
    
    def test_propose_action_adds_to_proposals(self, blackboard):
        """propose_action should add action proposal."""
        blackboard.begin_turn("test", {}, None)
        
        blackboard.propose_action(
            action="answer_with_pricing",
            priority=Priority.HIGH,
            combinable=True,
            reason_code="price_question",
            source_name="TestSource",
        )
        
        proposals = blackboard.get_action_proposals()
        assert len(proposals) == 1
        assert proposals[0].type == ProposalType.ACTION
        assert proposals[0].value == "answer_with_pricing"
        assert proposals[0].priority == Priority.HIGH
        assert proposals[0].combinable == True
        assert proposals[0].reason_code == "price_question"
        assert proposals[0].source_name == "TestSource"
    
    def test_propose_action_default_combinable_true(self, blackboard):
        """propose_action should default combinable to True."""
        blackboard.begin_turn("test", {}, None)
        
        blackboard.propose_action("action", Priority.NORMAL)
        
        proposals = blackboard.get_action_proposals()
        assert proposals[0].combinable == True
    
    def test_propose_action_blocking(self, blackboard):
        """propose_action with combinable=False creates blocking action."""
        blackboard.begin_turn("test", {}, None)
        
        blackboard.propose_action(
            action="handle_rejection",
            priority=Priority.CRITICAL,
            combinable=False,
            reason_code="rejection",
            source_name="TestSource",
        )
        
        proposals = blackboard.get_action_proposals()
        assert proposals[0].combinable == False
    
    # === propose_transition tests ===
    
    def test_propose_transition_adds_to_proposals(self, blackboard):
        """propose_transition should add transition proposal."""
        blackboard.begin_turn("test", {}, None)
        
        blackboard.propose_transition(
            next_state="spin_problem",
            priority=Priority.NORMAL,
            reason_code="data_complete",
            source_name="TestSource",
        )
        
        proposals = blackboard.get_transition_proposals()
        assert len(proposals) == 1
        assert proposals[0].type == ProposalType.TRANSITION
        assert proposals[0].value == "spin_problem"
        assert proposals[0].priority == Priority.NORMAL
    
    def test_propose_transition_always_combinable(self, blackboard):
        """Transitions should always be combinable."""
        blackboard.begin_turn("test", {}, None)
        
        blackboard.propose_transition("state", Priority.HIGH)
        
        proposals = blackboard.get_transition_proposals()
        assert proposals[0].combinable == True
    
    # === get_proposals tests ===
    
    def test_get_proposals_returns_all(self, blackboard):
        """get_proposals should return actions and transitions."""
        blackboard.begin_turn("test", {}, None)
        
        blackboard.propose_action("action1", Priority.HIGH)
        blackboard.propose_action("action2", Priority.LOW)
        blackboard.propose_transition("state1", Priority.NORMAL)
        
        all_proposals = blackboard.get_proposals()
        assert len(all_proposals) == 3
    
    def test_get_action_proposals_filters(self, blackboard):
        """get_action_proposals should return only actions."""
        blackboard.begin_turn("test", {}, None)
        
        blackboard.propose_action("action1", Priority.HIGH)
        blackboard.propose_transition("state1", Priority.NORMAL)
        
        action_proposals = blackboard.get_action_proposals()
        assert len(action_proposals) == 1
        assert action_proposals[0].type == ProposalType.ACTION
    
    def test_get_transition_proposals_filters(self, blackboard):
        """get_transition_proposals should return only transitions."""
        blackboard.begin_turn("test", {}, None)
        
        blackboard.propose_action("action1", Priority.HIGH)
        blackboard.propose_transition("state1", Priority.NORMAL)
        
        transition_proposals = blackboard.get_transition_proposals()
        assert len(transition_proposals) == 1
        assert transition_proposals[0].type == ProposalType.TRANSITION
    
    # === commit_decision tests ===
    
    def test_commit_decision_stores_decision(self, blackboard):
        """commit_decision should store the decision."""
        from src.blackboard.models import ResolvedDecision
        
        blackboard.begin_turn("test", {}, None)
        
        decision = ResolvedDecision(
            action="answer_with_pricing",
            next_state="spin_problem",
            reason_codes=["price_question", "data_complete"],
        )
        
        blackboard.commit_decision(decision)
        
        stored = blackboard.get_decision()
        assert stored.action == "answer_with_pricing"
        assert stored.next_state == "spin_problem"
        assert "price_question" in stored.reason_codes
    
    def test_commit_decision_applies_data_updates(self, blackboard, mock_state_machine):
        """commit_decision should apply data updates to state machine."""
        from src.blackboard.models import ResolvedDecision
        
        blackboard.begin_turn("test", {}, None)
        
        decision = ResolvedDecision(
            action="test",
            next_state="test",
            data_updates={"new_field": "new_value"},
        )
        
        blackboard.commit_decision(decision)
        
        assert mock_state_machine.collected_data["new_field"] == "new_value"


class TestContextSnapshot:
    """Test suite for ContextSnapshot helper methods."""
    
    @pytest.fixture
    def context_snapshot(self):
        """Create a ContextSnapshot for testing."""
        mock_tracker = Mock()
        mock_tracker.prev_intent = "previous"
        mock_tracker.objection_consecutive.return_value = 2
        mock_tracker.objection_total.return_value = 5
        
        return ContextSnapshot(
            state="spin_situation",
            collected_data={"company_size": "50", "pain_point": ""},
            current_intent="price_question",
            intent_tracker=mock_tracker,
            context_envelope=None,
            turn_number=10,
            persona="default",
            state_config={
                "required_data": ["company_size", "industry"],
                "optional_data": ["pain_point"],
                "transitions": {
                    "data_complete": "spin_problem",
                    "rejection": "soft_close",
                },
                "phase": "situation",
            },
            flow_config={},
        )
    
    def test_last_intent_property(self, context_snapshot):
        """last_intent should return prev_intent from tracker."""
        assert context_snapshot.last_intent == "previous"
    
    def test_objection_consecutive_property(self, context_snapshot):
        """objection_consecutive should delegate to tracker."""
        assert context_snapshot.objection_consecutive == 2
    
    def test_objection_total_property(self, context_snapshot):
        """objection_total should delegate to tracker."""
        assert context_snapshot.objection_total == 5
    
    def test_required_data_property(self, context_snapshot):
        """required_data should return from state_config."""
        assert context_snapshot.required_data == ["company_size", "industry"]
    
    def test_get_missing_required_data(self, context_snapshot):
        """get_missing_required_data should return uncollected fields."""
        missing = context_snapshot.get_missing_required_data()
        assert "industry" in missing
        assert "company_size" not in missing  # Already collected
    
    def test_has_all_required_data_false(self, context_snapshot):
        """has_all_required_data should return False if missing."""
        assert context_snapshot.has_all_required_data() == False
    
    def test_get_transition(self, context_snapshot):
        """get_transition should return target state."""
        assert context_snapshot.get_transition("data_complete") == "spin_problem"
        assert context_snapshot.get_transition("rejection") == "soft_close"
        assert context_snapshot.get_transition("nonexistent") is None
    
    def test_current_phase_property(self, context_snapshot):
        """current_phase should return phase from state_config."""
        assert context_snapshot.current_phase == "situation"


class TestMultiTenancy:
    """Test multi-tenancy support in DialogueBlackboard."""

    @pytest.fixture
    def mock_state_machine(self):
        """Create a mock state machine."""
        sm = Mock()
        sm.state = "greeting"
        sm.collected_data = {}
        sm._intent_tracker = Mock()
        sm._intent_tracker.turn_number = 1
        sm._intent_tracker.prev_intent = None
        sm._intent_tracker.objection_consecutive.return_value = 0
        sm._intent_tracker.objection_total.return_value = 0
        return sm

    @pytest.fixture
    def mock_flow_config(self):
        """Create a mock flow config."""
        config = Mock()
        config.states = {"greeting": {"goal": "Greet user"}}
        config.to_dict.return_value = {
            "states": config.states,
            "persona_limits": {
                "aggressive": {"consecutive": 5, "total": 8},
                "default": {"consecutive": 3, "total": 5},
            }
        }
        return config

    def test_default_tenant_when_not_provided(self, mock_state_machine, mock_flow_config):
        """Blackboard should use DEFAULT_TENANT when none provided."""
        bb = DialogueBlackboard(
            state_machine=mock_state_machine,
            flow_config=mock_flow_config,
        )
        assert bb.tenant_id == "default"

    def test_custom_tenant_config(self, mock_state_machine, mock_flow_config):
        """Blackboard should use provided tenant config."""
        tenant = TenantConfig(
            tenant_id="acme_corp",
            bot_name="ACME Bot",
            tone="friendly",
        )
        bb = DialogueBlackboard(
            state_machine=mock_state_machine,
            flow_config=mock_flow_config,
            tenant_config=tenant,
        )
        assert bb.tenant_id == "acme_corp"
        assert bb.tenant_config.bot_name == "ACME Bot"

    def test_tenant_in_context_snapshot(self, mock_state_machine, mock_flow_config):
        """ContextSnapshot should include tenant information."""
        tenant = TenantConfig(tenant_id="test_tenant")
        bb = DialogueBlackboard(
            state_machine=mock_state_machine,
            flow_config=mock_flow_config,
            tenant_config=tenant,
        )
        bb.begin_turn("greeting", {})
        ctx = bb.get_context()

        assert ctx.tenant_id == "test_tenant"
        assert ctx.tenant_config is not None

    def test_tenant_persona_limit_override(self, mock_state_machine, mock_flow_config):
        """Tenant can override persona limits."""
        # Tenant with custom limits for aggressive persona
        tenant = TenantConfig(
            tenant_id="enterprise",
            persona_limits_override={
                "aggressive": {"consecutive": 10, "total": 20},
            }
        )
        bb = DialogueBlackboard(
            state_machine=mock_state_machine,
            flow_config=mock_flow_config,
            tenant_config=tenant,
        )
        bb.begin_turn("greeting", {})
        ctx = bb.get_context()

        # Tenant override should take precedence
        assert ctx.get_persona_limit("aggressive", "consecutive") == 10
        assert ctx.get_persona_limit("aggressive", "total") == 20

        # Non-overridden persona falls back to global
        assert ctx.get_persona_limit("default", "consecutive") == 3

    def test_tenant_feature_flags(self, mock_state_machine, mock_flow_config):
        """Tenant can have custom feature flags."""
        tenant = TenantConfig(
            tenant_id="basic_tier",
            features={
                "escalation": False,  # Disabled for this tenant
                "price_questions": True,
            }
        )
        bb = DialogueBlackboard(
            state_machine=mock_state_machine,
            flow_config=mock_flow_config,
            tenant_config=tenant,
        )
        bb.begin_turn("greeting", {})
        ctx = bb.get_context()

        assert ctx.is_tenant_feature_enabled("escalation") is False
        assert ctx.is_tenant_feature_enabled("price_questions") is True
        # Unknown features default to True
        assert ctx.is_tenant_feature_enabled("unknown_feature") is True

17.2 Test ConflictResolver

# tests/test_conflict_resolver.py

import pytest
from src.blackboard.conflict_resolver import ConflictResolver
from src.blackboard.models import Proposal
from src.blackboard.enums import Priority, ProposalType


class TestConflictResolver:
    """Test suite for ConflictResolver class."""
    
    @pytest.fixture
    def resolver(self):
        """Create a ConflictResolver instance."""
        return ConflictResolver(default_action="continue")
    
    # === Basic resolution tests ===
    
    def test_no_proposals_returns_defaults(self, resolver):
        """No proposals should return default action and current state."""
        decision = resolver.resolve([], "spin_situation")
        
        assert decision.action == "continue"
        assert decision.next_state == "spin_situation"
    
    def test_single_action_proposal(self, resolver):
        """Single action proposal should win."""
        proposals = [
            Proposal(
                type=ProposalType.ACTION,
                value="answer_with_pricing",
                priority=Priority.HIGH,
                source_name="TestSource",
                reason_code="test",
            )
        ]
        
        decision = resolver.resolve(proposals, "spin_situation")
        
        assert decision.action == "answer_with_pricing"
        assert decision.next_state == "spin_situation"
    
    def test_single_transition_proposal(self, resolver):
        """Single transition proposal should win."""
        proposals = [
            Proposal(
                type=ProposalType.TRANSITION,
                value="spin_problem",
                priority=Priority.NORMAL,
                source_name="TestSource",
                reason_code="test",
            )
        ]
        
        decision = resolver.resolve(proposals, "spin_situation")
        
        assert decision.action == "continue"
        assert decision.next_state == "spin_problem"
    
    # === Priority tests ===
    
    def test_higher_priority_action_wins(self, resolver):
        """Higher priority action should win over lower."""
        proposals = [
            Proposal(
                type=ProposalType.ACTION,
                value="low_priority_action",
                priority=Priority.LOW,
                source_name="Source1",
                reason_code="low",
            ),
            Proposal(
                type=ProposalType.ACTION,
                value="high_priority_action",
                priority=Priority.HIGH,
                source_name="Source2",
                reason_code="high",
            ),
        ]
        
        decision = resolver.resolve(proposals, "state")
        
        assert decision.action == "high_priority_action"
        assert len(decision.rejected_proposals) == 1
        assert decision.rejected_proposals[0].value == "low_priority_action"
    
    def test_critical_beats_high(self, resolver):
        """CRITICAL priority should beat HIGH."""
        proposals = [
            Proposal(
                type=ProposalType.ACTION,
                value="high_action",
                priority=Priority.HIGH,
                source_name="Source1",
                reason_code="high",
            ),
            Proposal(
                type=ProposalType.ACTION,
                value="critical_action",
                priority=Priority.CRITICAL,
                source_name="Source2",
                reason_code="critical",
            ),
        ]
        
        decision = resolver.resolve(proposals, "state")
        
        assert decision.action == "critical_action"
    
    def test_higher_priority_transition_wins(self, resolver):
        """Higher priority transition should win over lower."""
        proposals = [
            Proposal(
                type=ProposalType.TRANSITION,
                value="low_state",
                priority=Priority.LOW,
                source_name="Source1",
                reason_code="low",
            ),
            Proposal(
                type=ProposalType.TRANSITION,
                value="high_state",
                priority=Priority.HIGH,
                source_name="Source2",
                reason_code="high",
            ),
        ]
        
        decision = resolver.resolve(proposals, "current")
        
        assert decision.next_state == "high_state"
    
    # === Combinable flag tests (CRITICAL) ===
    
    def test_combinable_true_merges_action_and_transition(self, resolver):
        """combinable=True should allow action + transition merge."""
        proposals = [
            Proposal(
                type=ProposalType.ACTION,
                value="answer_with_pricing",
                priority=Priority.HIGH,
                source_name="PriceSource",
                reason_code="price",
                combinable=True,  # KEY!
            ),
            Proposal(
                type=ProposalType.TRANSITION,
                value="spin_problem",
                priority=Priority.NORMAL,
                source_name="DataSource",
                reason_code="data_complete",
            ),
        ]
        
        decision = resolver.resolve(proposals, "spin_situation")
        
        # BOTH should be applied
        assert decision.action == "answer_with_pricing"
        assert decision.next_state == "spin_problem"
        assert "price" in decision.reason_codes
        assert "data_complete" in decision.reason_codes
    
    def test_combinable_false_blocks_transitions(self, resolver):
        """combinable=False should block all transitions."""
        proposals = [
            Proposal(
                type=ProposalType.ACTION,
                value="handle_rejection",
                priority=Priority.HIGH,
                source_name="RejectionSource",
                reason_code="rejection",
                combinable=False,  # BLOCKING!
            ),
            Proposal(
                type=ProposalType.TRANSITION,
                value="spin_problem",
                priority=Priority.NORMAL,
                source_name="DataSource",
                reason_code="data_complete",
            ),
        ]
        
        decision = resolver.resolve(proposals, "spin_situation")
        
        # Action wins, transition is BLOCKED
        assert decision.action == "handle_rejection"
        assert decision.next_state == "spin_situation"  # NO TRANSITION!
        assert len(decision.rejected_proposals) == 1
        assert decision.rejected_proposals[0].value == "spin_problem"
    
    def test_combinable_false_blocks_multiple_transitions(self, resolver):
        """combinable=False should block ALL transitions."""
        proposals = [
            Proposal(
                type=ProposalType.ACTION,
                value="escalate_to_human",
                priority=Priority.CRITICAL,
                source_name="EscalationSource",
                reason_code="escalation",
                combinable=False,
            ),
            Proposal(
                type=ProposalType.TRANSITION,
                value="spin_problem",
                priority=Priority.NORMAL,
                source_name="DataSource",
                reason_code="data_complete",
            ),
            Proposal(
                type=ProposalType.TRANSITION,
                value="soft_close",
                priority=Priority.HIGH,
                source_name="OtherSource",
                reason_code="other",
            ),
        ]
        
        decision = resolver.resolve(proposals, "spin_situation")
        
        assert decision.action == "escalate_to_human"
        assert decision.next_state == "spin_situation"
        assert len(decision.rejected_proposals) == 2  # Both transitions rejected
    
    # === The Core Problem Test ===
    
    def test_price_question_with_data_complete_both_applied(self, resolver):
        """
        THIS IS THE CORE TEST.
        
        Scenario: User asks price question while providing final required data.
        Expected: Answer price question AND transition to next phase.
        
        This was the bug in legacy system where price_question early-returned
        and blocked the data_complete transition.
        """
        proposals = [
            # PriceQuestionSource proposes action with combinable=True
            Proposal(
                type=ProposalType.ACTION,
                value="answer_with_pricing",
                priority=Priority.HIGH,
                source_name="PriceQuestionSource",
                reason_code="price_question_priority",
                combinable=True,
            ),
            # DataCollectorSource proposes transition (data is complete)
            Proposal(
                type=ProposalType.TRANSITION,
                value="spin_problem",
                priority=Priority.NORMAL,
                source_name="DataCollectorSource",
                reason_code="data_complete",
            ),
        ]
        
        decision = resolver.resolve(proposals, "spin_situation")
        
        # CRITICAL ASSERTIONS:
        assert decision.action == "answer_with_pricing", \
            "Bot should answer the price question"
        assert decision.next_state == "spin_problem", \
            "Bot should ALSO transition to next phase (NOT stay in spin_situation)"
        assert "price_question_priority" in decision.reason_codes
        assert "data_complete" in decision.reason_codes
        assert len(decision.rejected_proposals) == 0, \
            "Nothing should be rejected when combinable=True"
    
    # === Reason codes tests ===
    
    def test_reason_codes_include_winners(self, resolver):
        """reason_codes should include winning action and transition codes."""
        proposals = [
            Proposal(
                type=ProposalType.ACTION,
                value="action",
                priority=Priority.HIGH,
                source_name="S1",
                reason_code="reason_action",
                combinable=True,
            ),
            Proposal(
                type=ProposalType.TRANSITION,
                value="state",
                priority=Priority.NORMAL,
                source_name="S2",
                reason_code="reason_transition",
            ),
        ]
        
        decision = resolver.resolve(proposals, "current")
        
        assert "reason_action" in decision.reason_codes
        assert "reason_transition" in decision.reason_codes
    
    # === Resolution trace tests ===
    
    def test_resolution_trace_populated(self, resolver):
        """resolution_trace should contain debug information."""
        proposals = [
            Proposal(
                type=ProposalType.ACTION,
                value="action",
                priority=Priority.HIGH,
                source_name="Source",
                reason_code="reason",
                combinable=True,
            ),
        ]
        
        decision = resolver.resolve(proposals, "state")
        
        assert "action_proposals_count" in decision.resolution_trace
        assert "merge_decision" in decision.resolution_trace
    
    # === Fallback transition tests ===
    
    def test_resolve_with_fallback_applies_fallback(self, resolver):
        """resolve_with_fallback should apply fallback when no transition."""
        proposals = [
            Proposal(
                type=ProposalType.ACTION,
                value="some_action",
                priority=Priority.NORMAL,
                source_name="Source",
                reason_code="reason",
                combinable=True,
            ),
            # No transition proposal
        ]
        
        decision = resolver.resolve_with_fallback(
            proposals=proposals,
            current_state="spin_situation",
            fallback_transition="spin_problem",  # "any" transition
        )
        
        assert decision.next_state == "spin_problem"
        assert "fallback_any_transition" in decision.reason_codes
    
    def test_resolve_with_fallback_no_fallback_if_transition_exists(self, resolver):
        """resolve_with_fallback should not apply fallback if transition exists."""
        proposals = [
            Proposal(
                type=ProposalType.TRANSITION,
                value="explicit_state",
                priority=Priority.NORMAL,
                source_name="Source",
                reason_code="explicit",
            ),
        ]
        
        decision = resolver.resolve_with_fallback(
            proposals=proposals,
            current_state="current",
            fallback_transition="fallback_state",
        )
        
        assert decision.next_state == "explicit_state"
        assert "fallback_any_transition" not in decision.reason_codes
    
    def test_resolve_with_fallback_blocked_by_non_combinable(self, resolver):
        """resolve_with_fallback should not apply fallback if action blocks it."""
        proposals = [
            Proposal(
                type=ProposalType.ACTION,
                value="blocking_action",
                priority=Priority.HIGH,
                source_name="Source",
                reason_code="blocking",
                combinable=False,  # Blocks fallback
            ),
        ]
        
        decision = resolver.resolve_with_fallback(
            proposals=proposals,
            current_state="current",
            fallback_transition="fallback_state",
        )
        
        assert decision.next_state == "current"  # Fallback not applied
17.3 Test Knowledge Sources

# tests/test_sources_price.py

import pytest
from unittest.mock import Mock, MagicMock

from src.blackboard.sources.price_question import PriceQuestionSource
from src.blackboard.blackboard import DialogueBlackboard
from src.blackboard.enums import Priority, ProposalType


class TestPriceQuestionSource:
    """Test suite for PriceQuestionSource."""
    
    @pytest.fixture
    def source(self):
        """Create a PriceQuestionSource instance."""
        return PriceQuestionSource()
    
    @pytest.fixture
    def mock_blackboard(self):
        """Create a mock blackboard."""
        bb = Mock(spec=DialogueBlackboard)
        bb.current_intent = "price_question"
        
        ctx = Mock()
        ctx.current_intent = "price_question"
        ctx.collected_data = {}
        bb.get_context.return_value = ctx
        
        return bb
    
    def test_should_contribute_true_for_price_question(self, source, mock_blackboard):
        """should_contribute returns True for price_question intent."""
        mock_blackboard.current_intent = "price_question"
        
        assert source.should_contribute(mock_blackboard) == True
    
    def test_should_contribute_true_for_pricing_details(self, source, mock_blackboard):
        """should_contribute returns True for pricing_details intent."""
        mock_blackboard.current_intent = "pricing_details"
        
        assert source.should_contribute(mock_blackboard) == True
    
    def test_should_contribute_false_for_other_intents(self, source, mock_blackboard):
        """should_contribute returns False for non-price intents."""
        mock_blackboard.current_intent = "greeting"
        
        assert source.should_contribute(mock_blackboard) == False
    
    def test_should_contribute_false_when_disabled(self, source, mock_blackboard):
        """should_contribute returns False when source is disabled."""
        source.disable()
        mock_blackboard.current_intent = "price_question"
        
        assert source.should_contribute(mock_blackboard) == False
    
    def test_contribute_proposes_answer_with_pricing(self, source, mock_blackboard):
        """contribute should propose answer_with_pricing action."""
        source.contribute(mock_blackboard)
        
        mock_blackboard.propose_action.assert_called_once()
        call_kwargs = mock_blackboard.propose_action.call_args[1]
        
        assert call_kwargs["action"] == "answer_with_pricing"
        assert call_kwargs["priority"] == Priority.HIGH
        assert call_kwargs["combinable"] == True  # CRITICAL!
        assert call_kwargs["reason_code"] == "price_question_priority"
    
    def test_contribute_proposes_discount_handler_for_discount_request(self, source, mock_blackboard):
        """contribute should propose handle_discount_request for discount intent."""
        mock_blackboard.current_intent = "discount_request"
        ctx = mock_blackboard.get_context.return_value
        ctx.current_intent = "discount_request"
        
        source.contribute(mock_blackboard)
        
        call_kwargs = mock_blackboard.propose_action.call_args[1]
        assert call_kwargs["action"] == "handle_discount_request"
    
    def test_combinable_flag_is_true(self, source, mock_blackboard):
        """
        CRITICAL TEST: combinable must be True.
        
        This ensures price questions don't block data_complete transitions.
        """
        source.contribute(mock_blackboard)
        
        call_kwargs = mock_blackboard.propose_action.call_args[1]
        assert call_kwargs["combinable"] == True, \
            "PriceQuestionSource MUST set combinable=True to allow transitions"


# tests/test_sources_data.py

class TestDataCollectorSource:
    """Test suite for DataCollectorSource."""
    
    @pytest.fixture
    def source(self):
        """Create a DataCollectorSource instance."""
        from src.blackboard.sources.data_collector import DataCollectorSource
        return DataCollectorSource()
    
    @pytest.fixture
    def mock_blackboard(self):
        """Create a mock blackboard with context."""
        bb = Mock(spec=DialogueBlackboard)
        
        ctx = Mock()
        ctx.state_config = {
            "required_data": ["company_size", "industry"],
            "is_final": False,
            "transitions": {
                "data_complete": "spin_problem",
            },
        }
        ctx.required_data = ["company_size", "industry"]
        ctx.collected_data = {"company_size": "50"}  # Missing industry
        ctx.get_transition = lambda trigger: ctx.state_config["transitions"].get(trigger)
        
        bb.get_context.return_value = ctx
        
        return bb
    
    def test_should_contribute_true_when_required_data_exists(self, source, mock_blackboard):
        """should_contribute returns True when state has required_data."""
        assert source.should_contribute(mock_blackboard) == True
    
    def test_should_contribute_false_when_no_required_data(self, source, mock_blackboard):
        """should_contribute returns False when no required_data defined."""
        ctx = mock_blackboard.get_context.return_value
        ctx.state_config = {"required_data": [], "is_final": False}
        ctx.required_data = []
        
        assert source.should_contribute(mock_blackboard) == False
    
    def test_should_contribute_false_when_final_state(self, source, mock_blackboard):
        """should_contribute returns False for final states."""
        ctx = mock_blackboard.get_context.return_value
        ctx.state_config["is_final"] = True
        
        assert source.should_contribute(mock_blackboard) == False
    
    def test_contribute_no_proposal_when_data_missing(self, source, mock_blackboard):
        """contribute should not propose if data is missing."""
        # Missing industry
        source.contribute(mock_blackboard)
        
        mock_blackboard.propose_transition.assert_not_called()
    
    def test_contribute_proposes_transition_when_data_complete(self, source, mock_blackboard):
        """contribute should propose transition when all data collected."""
        ctx = mock_blackboard.get_context.return_value
        ctx.collected_data = {"company_size": "50", "industry": "tech"}  # All data!
        
        source.contribute(mock_blackboard)
        
        mock_blackboard.propose_transition.assert_called_once()
        call_kwargs = mock_blackboard.propose_transition.call_args[1]
        
        assert call_kwargs["next_state"] == "spin_problem"
        assert call_kwargs["reason_code"] == "data_complete"
        assert call_kwargs["priority"] == Priority.NORMAL


# tests/test_sources_objection.py

class TestObjectionGuardSource:
    """Test suite for ObjectionGuardSource."""
    
    @pytest.fixture
    def source(self):
        """Create an ObjectionGuardSource with test limits."""
        from src.blackboard.sources.objection_guard import ObjectionGuardSource
        return ObjectionGuardSource(
            persona_limits={
                "aggressive": {"consecutive": 5, "total": 8},
                "busy": {"consecutive": 2, "total": 4},
                "default": {"consecutive": 3, "total": 5},
            }
        )
    
    @pytest.fixture
    def mock_blackboard(self):
        """Create a mock blackboard."""
        bb = Mock(spec=DialogueBlackboard)
        bb.current_intent = "objection_price"
        
        ctx = Mock()
        ctx.current_intent = "objection_price"
        ctx.persona = "default"
        ctx.objection_consecutive = 1
        ctx.objection_total = 2
        
        bb.get_context.return_value = ctx
        
        return bb
    
    def test_should_contribute_true_for_objection(self, source, mock_blackboard):
        """should_contribute returns True for objection intents."""
        assert source.should_contribute(mock_blackboard) == True
    
    def test_should_contribute_false_for_non_objection(self, source, mock_blackboard):
        """should_contribute returns False for non-objection intents."""
        mock_blackboard.current_intent = "greeting"
        
        assert source.should_contribute(mock_blackboard) == False
    
    def test_contribute_no_proposal_when_within_limits(self, source, mock_blackboard):
        """contribute should not propose if within limits."""
        ctx = mock_blackboard.get_context.return_value
        ctx.objection_consecutive = 1
        ctx.objection_total = 2
        # Default limits: consecutive=3, total=5
        
        source.contribute(mock_blackboard)
        
        mock_blackboard.propose_action.assert_not_called()
        mock_blackboard.propose_transition.assert_not_called()
    
    def test_contribute_proposes_when_consecutive_exceeded(self, source, mock_blackboard):
        """contribute should propose soft_close when consecutive limit exceeded."""
        ctx = mock_blackboard.get_context.return_value
        ctx.objection_consecutive = 3  # Equals default limit
        ctx.objection_total = 3
        
        source.contribute(mock_blackboard)
        
        # Should propose BLOCKING action
        mock_blackboard.propose_action.assert_called_once()
        action_kwargs = mock_blackboard.propose_action.call_args[1]
        assert action_kwargs["action"] == "objection_limit_reached"
        assert action_kwargs["combinable"] == False  # BLOCKING!
        
        # Should propose transition
        mock_blackboard.propose_transition.assert_called_once()
        trans_kwargs = mock_blackboard.propose_transition.call_args[1]
        assert trans_kwargs["next_state"] == "soft_close"
    
    def test_contribute_proposes_when_total_exceeded(self, source, mock_blackboard):
        """contribute should propose soft_close when total limit exceeded."""
        ctx = mock_blackboard.get_context.return_value
        ctx.objection_consecutive = 1
        ctx.objection_total = 5  # Equals default limit
        
        source.contribute(mock_blackboard)
        
        mock_blackboard.propose_action.assert_called_once()
        mock_blackboard.propose_transition.assert_called_once()
    
    def test_contribute_uses_persona_limits(self, source, mock_blackboard):
        """contribute should use persona-specific limits."""
        ctx = mock_blackboard.get_context.return_value
        ctx.persona = "busy"  # Stricter limits: consecutive=2, total=4
        ctx.objection_consecutive = 2  # Equals busy limit
        ctx.objection_total = 2
        
        source.contribute(mock_blackboard)
        
        # Should trigger because busy limit is 2
        mock_blackboard.propose_action.assert_called_once()
    
    def test_contribute_uses_default_for_unknown_persona(self, source, mock_blackboard):
        """contribute should use default limits for unknown persona."""
        ctx = mock_blackboard.get_context.return_value
        ctx.persona = "unknown_persona"
        ctx.objection_consecutive = 3  # Default limit
        ctx.objection_total = 3

        source.contribute(mock_blackboard)

        mock_blackboard.propose_action.assert_called_once()

    def test_contribute_sets_objection_limit_final_flag(self, source, mock_blackboard):
        """
        CRITICAL: contribute should propose _objection_limit_final data update.

        This flag is required for is_final override in _fill_compatibility_fields().
        Without it, soft_close triggered by objection limit won't be marked as final.
        """
        ctx = mock_blackboard.get_context.return_value
        ctx.objection_consecutive = 3  # Trigger limit
        ctx.objection_total = 3

        source.contribute(mock_blackboard)

        # Should propose data update for _objection_limit_final
        mock_blackboard.propose_data_update.assert_called_once_with(
            field="_objection_limit_final",
            value=True,
            source_name="ObjectionGuardSource",
            reason_code="objection_limit_exceeded"
        )

    def test_is_final_true_when_objection_limit_reached(self, source, mock_blackboard):
        """
        Integration test: is_final should be True when soft_close is triggered by objection limit.

        Flow:
        1. ObjectionGuardSource proposes soft_close + _objection_limit_final
        2. _fill_compatibility_fields checks for this flag
        3. is_final is set to True even if soft_close config has is_final=False
        """
        # This test verifies the end-to-end behavior documented in the architecture
        # Actual implementation tested in test_orchestrator.py
        pass

17.3.1 Test SourceRegistry (Plugin System)

# tests/test_source_registry.py

import pytest
from unittest.mock import Mock

from src.blackboard.source_registry import (
    SourceRegistry,
    SourceRegistration,
    register_source,
)
from src.blackboard.knowledge_source import KnowledgeSource


class TestSourceRegistry:
    """Test suite for SourceRegistry (Plugin System)."""

    @pytest.fixture(autouse=True)
    def reset_registry(self):
        """Reset registry before each test."""
        SourceRegistry.reset()
        yield
        SourceRegistry.reset()

    def test_register_source_class(self):
        """register should add source to registry."""
        class TestSource(KnowledgeSource):
            def contribute(self, bb):
                pass

        SourceRegistry.register(TestSource, name="TestSource")

        assert "TestSource" in SourceRegistry.list_registered()

    def test_register_with_priority_order(self):
        """Sources should be listed in priority_order."""
        class Source1(KnowledgeSource):
            def contribute(self, bb):
                pass

        class Source2(KnowledgeSource):
            def contribute(self, bb):
                pass

        SourceRegistry.register(Source1, name="Source1", priority_order=20)
        SourceRegistry.register(Source2, name="Source2", priority_order=10)

        registered = SourceRegistry.list_registered()
        assert registered[0] == "Source2"  # Lower priority = earlier
        assert registered[1] == "Source1"

    def test_register_rejects_non_knowledge_source(self):
        """register should reject non-KnowledgeSource classes."""
        class NotASource:
            pass

        with pytest.raises(TypeError):
            SourceRegistry.register(NotASource)

    def test_register_rejects_duplicate_name_when_frozen(self):
        """register should reject duplicate names when frozen."""
        class TestSource(KnowledgeSource):
            def contribute(self, bb):
                pass

        SourceRegistry.register(TestSource, name="TestSource")
        SourceRegistry.freeze()

        with pytest.raises(ValueError):
            SourceRegistry.register(TestSource, name="TestSource")

    def test_unregister_source(self):
        """unregister should remove source from registry."""
        class TestSource(KnowledgeSource):
            def contribute(self, bb):
                pass

        SourceRegistry.register(TestSource, name="TestSource")
        assert "TestSource" in SourceRegistry.list_registered()

        result = SourceRegistry.unregister("TestSource")

        assert result == True
        assert "TestSource" not in SourceRegistry.list_registered()

    def test_create_sources_returns_instances(self):
        """create_sources should return KnowledgeSource instances."""
        class TestSource(KnowledgeSource):
            def contribute(self, bb):
                pass

        SourceRegistry.register(TestSource, name="TestSource")

        sources = SourceRegistry.create_sources()

        assert len(sources) == 1
        assert isinstance(sources[0], TestSource)
        assert sources[0].name == "TestSource"

    def test_create_sources_respects_enabled_config(self):
        """create_sources should respect enabled flag in config."""
        class Source1(KnowledgeSource):
            def contribute(self, bb):
                pass

        class Source2(KnowledgeSource):
            def contribute(self, bb):
                pass

        SourceRegistry.register(Source1, name="Source1")
        SourceRegistry.register(Source2, name="Source2")

        config = {
            "sources": {
                "Source1": {"enabled": True},
                "Source2": {"enabled": False},  # Disabled!
            }
        }

        sources = SourceRegistry.create_sources(config=config)

        assert len(sources) == 1
        assert sources[0].name == "Source1"

    def test_create_sources_uses_default_enabled(self):
        """create_sources should use enabled_by_default if not in config."""
        class EnabledSource(KnowledgeSource):
            def contribute(self, bb):
                pass

        class DisabledSource(KnowledgeSource):
            def contribute(self, bb):
                pass

        SourceRegistry.register(
            EnabledSource, name="EnabledSource", enabled_by_default=True
        )
        SourceRegistry.register(
            DisabledSource, name="DisabledSource", enabled_by_default=False
        )

        sources = SourceRegistry.create_sources()

        assert len(sources) == 1
        assert sources[0].name == "EnabledSource"

    def test_create_sources_passes_config_to_source(self):
        """create_sources should pass source_configs to source __init__."""
        class ConfigurableSource(KnowledgeSource):
            def __init__(self, name: str, custom_param: str = "default"):
                super().__init__(name)
                self.custom_param = custom_param

            def contribute(self, bb):
                pass

        SourceRegistry.register(ConfigurableSource, name="ConfigurableSource")

        source_configs = {
            "ConfigurableSource": {"custom_param": "custom_value"}
        }

        sources = SourceRegistry.create_sources(source_configs=source_configs)

        assert sources[0].custom_param == "custom_value"

    def test_create_sources_maintains_priority_order(self):
        """create_sources should return sources in priority_order."""
        class Source1(KnowledgeSource):
            def contribute(self, bb):
                pass

        class Source2(KnowledgeSource):
            def contribute(self, bb):
                pass

        class Source3(KnowledgeSource):
            def contribute(self, bb):
                pass

        SourceRegistry.register(Source1, name="Source1", priority_order=30)
        SourceRegistry.register(Source2, name="Source2", priority_order=10)
        SourceRegistry.register(Source3, name="Source3", priority_order=20)

        sources = SourceRegistry.create_sources()

        assert sources[0].name == "Source2"  # priority 10
        assert sources[1].name == "Source3"  # priority 20
        assert sources[2].name == "Source1"  # priority 30


class TestRegisterSourceDecorator:
    """Test suite for @register_source decorator."""

    @pytest.fixture(autouse=True)
    def reset_registry(self):
        """Reset registry before each test."""
        SourceRegistry.reset()
        yield
        SourceRegistry.reset()

    def test_decorator_registers_class(self):
        """@register_source should register the decorated class."""
        @register_source(priority_order=15)
        class DecoratedSource(KnowledgeSource):
            def contribute(self, bb):
                pass

        assert "DecoratedSource" in SourceRegistry.list_registered()
        reg = SourceRegistry.get_registration("DecoratedSource")
        assert reg.priority_order == 15

    def test_decorator_with_custom_name(self):
        """@register_source should support custom name."""
        @register_source(name="CustomName", priority_order=25)
        class DecoratedSource(KnowledgeSource):
            def contribute(self, bb):
                pass

        assert "CustomName" in SourceRegistry.list_registered()

    def test_decorator_preserves_class(self):
        """@register_source should return the original class."""
        @register_source()
        class DecoratedSource(KnowledgeSource):
            def contribute(self, bb):
                pass

        # Should still be usable as a class
        instance = DecoratedSource(name="test")
        assert isinstance(instance, KnowledgeSource)

17.4 Test Orchestrator Integration

# tests/test_orchestrator.py

import pytest
from unittest.mock import Mock, MagicMock, patch

from src.blackboard.orchestrator import DialogueOrchestrator, create_orchestrator
from src.blackboard.models import ResolvedDecision
from src.blackboard.enums import Priority


class TestDialogueOrchestrator:
    """Test suite for DialogueOrchestrator."""
    
    @pytest.fixture
    def mock_state_machine(self):
        """Create a mock state machine."""
        sm = Mock()
        sm.state = "spin_situation"
        sm.collected_data = {}
        sm._intent_tracker = Mock()
        sm._intent_tracker.turn_number = 0
        sm._intent_tracker.record = Mock()
        sm._intent_tracker.prev_intent = None
        sm._intent_tracker.objection_consecutive.return_value = 0
        sm._intent_tracker.objection_total.return_value = 0
        sm._intent_tracker.total_count.return_value = 0
        sm._intent_tracker.category_total.return_value = 0
        return sm
    
    @pytest.fixture
    def mock_flow_config(self):
        """Create a mock flow config."""
        config = Mock()
        config.states = {
            "spin_situation": {
                "goal": "Understand situation",
                "phase": "situation",
                "required_data": ["company_size"],
                "is_final": False,
                "transitions": {
                    "data_complete": "spin_problem",
                    "rejection": "soft_close",
                    "any": "spin_problem",
                },
                "rules": {},
            },
            "spin_problem": {
                "goal": "Identify problems",
                "phase": "problem",
                "required_data": [],
                "is_final": False,
                "transitions": {},
                "rules": {},
            },
            "soft_close": {
                "goal": "Graceful exit",
                "is_final": True,
                "transitions": {},
                "rules": {},
            },
        }
        return config
    
    @pytest.fixture
    def orchestrator(self, mock_state_machine, mock_flow_config):
        """Create an orchestrator instance."""
        return DialogueOrchestrator(
            state_machine=mock_state_machine,
            flow_config=mock_flow_config,
            enable_validation=True,
        )
    
    # === Basic processing tests ===
    
    def test_process_turn_returns_decision(self, orchestrator):
        """process_turn should return a ResolvedDecision."""
        decision = orchestrator.process_turn(
            intent="greeting",
            extracted_data={},
            context_envelope=None,
        )
        
        assert isinstance(decision, ResolvedDecision)
        assert decision.action is not None
        assert decision.next_state is not None
    
    def test_process_turn_records_intent(self, orchestrator, mock_state_machine):
        """process_turn should record intent in tracker."""
        orchestrator.process_turn(
            intent="test_intent",
            extracted_data={},
            context_envelope=None,
        )
        
        mock_state_machine._intent_tracker.record.assert_called()
    
    # === The Core Problem Test ===
    
    def test_price_question_with_data_complete_scenario(self, orchestrator, mock_state_machine):
        """
        CORE INTEGRATION TEST.
        
        Scenario:
        - Current state: spin_situation (requires company_size)
        - User message: "Ğ£ Ğ½Ğ°Ñ 15 Ñ‡ĞµĞ»Ğ¾Ğ²ĞµĞº. Ğ¡ĞºĞ¾Ğ»ÑŒĞºĞ¾ ÑÑ‚Ğ¾Ğ¸Ñ‚?"
        - Intent: price_question
        - Extracted data: {company_size: "15"}
        
        Expected:
        - Action: answer_with_pricing (answer the price question)
        - Next state: spin_problem (data is now complete, transition!)
        """
        mock_state_machine.state = "spin_situation"
        mock_state_machine.collected_data = {}  # No data yet
        
        decision = orchestrator.process_turn(
            intent="price_question",
            extracted_data={"company_size": "15"},
            context_envelope=None,
        )
        
        # CRITICAL ASSERTIONS
        assert decision.action == "answer_with_pricing", \
            "Should answer the price question"
        assert decision.next_state == "spin_problem", \
            "Should ALSO transition to next phase (data is complete)"
        assert "price_question_priority" in decision.reason_codes
        assert "data_complete" in decision.reason_codes
    
    def test_price_question_without_complete_data(self, orchestrator, mock_state_machine):
        """Price question without completing data should not transition."""
        mock_state_machine.state = "spin_situation"
        mock_state_machine.collected_data = {}  # No data
        
        decision = orchestrator.process_turn(
            intent="price_question",
            extracted_data={},  # No new data either
            context_envelope=None,
        )
        
        assert decision.action == "answer_with_pricing"
        # No transition because data not complete
        # (will use fallback "any" transition or stay in state)
    
    # === COMPATIBILITY TESTS (Ğ´Ğ»Ñ bot.py Ğ¸Ğ½Ñ‚ĞµĞ³Ñ€Ğ°Ñ†Ğ¸Ğ¸) ===

    def test_to_sm_result_returns_all_required_fields(self, orchestrator, mock_state_machine):
        """
        CRITICAL: to_sm_result() MUST return all fields expected by bot.py.

        bot.py Ğ¸ÑĞ¿Ğ¾Ğ»ÑŒĞ·ÑƒĞµÑ‚ ÑĞ»ĞµĞ´ÑƒÑÑ‰Ğ¸Ğµ Ğ¿Ğ¾Ğ»Ñ:
        - action, next_state (core)
        - prev_state (Ğ´Ğ»Ñ Ğ¼ĞµÑ‚Ñ€Ğ¸Ğº)
        - goal (Ğ´Ğ»Ñ generator context)
        - collected_data (Ğ¿Ğ¾Ğ»Ğ½Ñ‹Ğ¹ dict)
        - missing_data, optional_data (Ğ´Ğ»Ñ generator)
        - is_final, spin_phase (Ğ´Ğ»Ñ Ğ¾Ğ¿Ñ€ĞµĞ´ĞµĞ»ĞµĞ½Ğ¸Ñ Ğ·Ğ°Ğ²ĞµÑ€ÑˆĞµĞ½Ğ¸Ñ)
        - circular_flow, objection_flow (Ğ´Ğ»Ñ ÑÑ‚Ğ°Ñ‚Ğ¸ÑÑ‚Ğ¸ĞºĞ¸)
        """
        mock_state_machine.state = "spin_situation"
        mock_state_machine.collected_data = {"company_size": "15"}
        mock_state_machine.circular_flow = Mock()
        mock_state_machine.circular_flow.get_stats.return_value = {"goback_count": 0}

        decision = orchestrator.process_turn(
            intent="info_provided",
            extracted_data={},
            context_envelope=None,
        )

        sm_result = decision.to_sm_result()

        # Assert ALL required fields are present
        assert "action" in sm_result
        assert "next_state" in sm_result
        assert "prev_state" in sm_result
        assert "goal" in sm_result
        assert "collected_data" in sm_result
        assert "missing_data" in sm_result
        assert "optional_data" in sm_result
        assert "is_final" in sm_result
        assert "spin_phase" in sm_result
        assert "circular_flow" in sm_result
        assert "objection_flow" in sm_result

        # Assert types are correct
        assert isinstance(sm_result["collected_data"], dict)
        assert isinstance(sm_result["missing_data"], list)
        assert isinstance(sm_result["optional_data"], list)
        assert isinstance(sm_result["is_final"], bool)

    def test_to_sm_result_compatible_with_dialogue_policy(self, orchestrator, mock_state_machine):
        """
        CRITICAL: sm_result must be modifiable in-place by DialoguePolicy.

        DialoguePolicy does:
            sm_result["action"] = override.action
            sm_result["next_state"] = override.next_state
        """
        decision = orchestrator.process_turn(
            intent="greeting",
            extracted_data={},
            context_envelope=None,
        )

        sm_result = decision.to_sm_result()

        # Verify it's a regular dict that can be modified in-place
        assert isinstance(sm_result, dict)

        # Simulate DialoguePolicy modification
        original_action = sm_result["action"]
        sm_result["action"] = "policy_override_action"
        sm_result["next_state"] = "policy_override_state"

        # Changes should persist
        assert sm_result["action"] == "policy_override_action"
        assert sm_result["next_state"] == "policy_override_state"

    def test_to_sm_result_provides_goal_for_generator(self, orchestrator, mock_state_machine):
        """
        Generator uses sm_result["goal"] for context.

        context = {
            "goal": sm_result["goal"],
            ...
        }
        """
        mock_state_machine.state = "spin_situation"

        decision = orchestrator.process_turn(
            intent="greeting",
            extracted_data={},
            context_envelope=None,
        )

        sm_result = decision.to_sm_result()

        # Goal should come from state config
        assert sm_result["goal"] == "Understand situation"

    def test_side_effects_applied_correctly(self, orchestrator, mock_state_machine):
        """
        Side effects MUST be applied for bot.py compatibility:
        - state_machine.state updated
        - state_machine.last_action updated
        - IntentTracker.record() called
        """
        mock_state_machine.state = "spin_situation"
        mock_state_machine.collected_data = {"company_size": "15"}

        orchestrator.process_turn(
            intent="info_provided",
            extracted_data={"pain_point": "losing customers"},
            context_envelope=None,
        )

        # State should be updated
        # (mock will have been assigned)

        # IntentTracker should have recorded the intent
        mock_state_machine._intent_tracker.record.assert_called()

    # =========================================================================
    # EXTERNAL STATE CHANGES TESTS (Critical for bot.py integration)
    # =========================================================================
    # These tests verify that Blackboard correctly handles state changes
    # made by bot.py BEFORE or AFTER process_turn()

    def test_blackboard_sees_external_state_change_before_process(
        self, orchestrator, mock_state_machine
    ):
        """
        CRITICAL: Blackboard must see state changes made by bot.py BEFORE process_turn().

        Scenario: Fallback "skip" action (bot.py line 743)
        1. bot.py sets state_machine.state = "spin_problem" (skip action)
        2. process_turn() is called
        3. Blackboard should read "spin_problem" as current state
        """
        # Setup: Initial state is greeting
        mock_state_machine.state = "greeting"

        # Simulate bot.py fallback skip (line 743)
        # BEFORE calling process_turn
        mock_state_machine.state = "spin_problem"

        decision = orchestrator.process_turn(
            intent="info_provided",
            extracted_data={},
            context_envelope=None,
        )

        # Blackboard should have read "spin_problem" as current state
        # NOT "greeting"
        assert decision.prev_state == "spin_problem"

    def test_blackboard_sees_external_collected_data_before_process(
        self, orchestrator, mock_state_machine
    ):
        """
        CRITICAL: Blackboard must see collected_data changes made BEFORE process_turn().

        Scenario: Competitor extraction (bot.py lines 773-776)
        1. bot.py sets collected_data["competitor_mentioned"] = True
        2. process_turn() is called
        3. Blackboard should see competitor_mentioned in collected_data
        """
        mock_state_machine.state = "spin_situation"
        mock_state_machine.collected_data = {}

        # Simulate bot.py competitor extraction (lines 773-776)
        # BEFORE calling process_turn
        mock_state_machine.collected_data["competitor_mentioned"] = True
        mock_state_machine.collected_data["competitor_name"] = "Competitor X"

        decision = orchestrator.process_turn(
            intent="info_provided",
            extracted_data={},
            context_envelope=None,
        )

        # Blackboard should have seen the competitor data
        # It should be in the decision's collected_data
        sm_result = decision.to_sm_result()
        assert sm_result["collected_data"].get("competitor_mentioned") == True
        assert sm_result["collected_data"].get("competitor_name") == "Competitor X"

    def test_dialogue_policy_can_override_state_after_process(
        self, orchestrator, mock_state_machine
    ):
        """
        CRITICAL: DialoguePolicy can OVERWRITE state AFTER process_turn().

        Scenario: DialoguePolicy override (bot.py line 944)
        1. process_turn() is called, sets state to "spin_problem"
        2. DialoguePolicy overrides to "spin_implication"
        3. bot.py writes state_machine.state = "spin_implication"
        4. This is NORMAL and EXPECTED behavior
        """
        mock_state_machine.state = "spin_situation"
        mock_state_machine.collected_data = {"company_size": "15"}

        decision = orchestrator.process_turn(
            intent="info_provided",
            extracted_data={},
            context_envelope=None,
        )

        # process_turn completed, state was set via _apply_side_effects
        original_next_state = decision.next_state

        # Simulate DialoguePolicy override (line 944)
        policy_override_state = "spin_implication"
        mock_state_machine.state = policy_override_state

        # State should be overwritten
        assert mock_state_machine.state == policy_override_state
        # This is expected - DialoguePolicy has final say

    def test_orchestrator_reads_state_at_begin_turn(
        self, orchestrator, mock_state_machine
    ):
        """
        Verify that state is read at the START of process_turn, not cached.

        This ensures external state changes (fallback skip) are visible.
        """
        mock_state_machine.state = "greeting"

        # First call
        decision1 = orchestrator.process_turn(
            intent="greeting",
            extracted_data={},
            context_envelope=None,
        )

        # External state change between calls
        mock_state_machine.state = "spin_situation"

        # Second call should see "spin_situation", not cached "greeting"
        decision2 = orchestrator.process_turn(
            intent="info_provided",
            extracted_data={},
            context_envelope=None,
        )

        assert decision2.prev_state == "spin_situation"

    def test_disambiguation_not_affected_by_blackboard(
        self, orchestrator, mock_state_machine
    ):
        """
        Verify that disambiguation state is NOT managed by Blackboard.

        Disambiguation methods are called directly by bot.py and are
        OUT OF SCOPE for Blackboard system.
        """
        # These properties/methods exist on state_machine but are NOT
        # part of IStateMachine protocol used by Blackboard
        mock_state_machine.in_disambiguation = False
        mock_state_machine.disambiguation_context = None
        mock_state_machine.turns_since_last_disambiguation = 5

        decision = orchestrator.process_turn(
            intent="greeting",
            extracted_data={},
            context_envelope=None,
        )

        # Blackboard should complete without touching disambiguation
        assert decision is not None
        # Disambiguation state should be unchanged
        assert mock_state_machine.in_disambiguation == False

    def test_compatibility_fields_filled_after_state_transition(
        self, orchestrator, mock_state_machine
    ):
        """
        When state transitions, compatibility fields should reflect NEW state.
        """
        mock_state_machine.state = "spin_situation"
        mock_state_machine.collected_data = {"company_size": "15"}

        decision = orchestrator.process_turn(
            intent="info_provided",
            extracted_data={},
            context_envelope=None,
        )

        # If transitioned to spin_problem, fields should reflect spin_problem config
        if decision.next_state == "spin_problem":
            assert decision.prev_state == "spin_situation"
            assert decision.goal == "Identify problems"
            assert decision.spin_phase == "problem"

    # === Objection limit tests ===

    def test_objection_limit_triggers_soft_close(self, orchestrator, mock_state_machine):
        """Exceeding objection limit should trigger soft_close."""
        mock_state_machine._intent_tracker.objection_consecutive.return_value = 3
        mock_state_machine._intent_tracker.objection_total.return_value = 5

        decision = orchestrator.process_turn(
            intent="objection_price",
            extracted_data={},
            context_envelope=None,
        )

        assert decision.action == "objection_limit_reached"
        assert decision.next_state == "soft_close"

    def test_objection_limit_sets_is_final_true(self, orchestrator, mock_state_machine):
        """
        CRITICAL: Objection limit should set is_final=True.

        When objection limit is reached:
        1. ObjectionGuardSource proposes _objection_limit_final data update
        2. _fill_compatibility_fields checks for this flag
        3. is_final is set to True (even if soft_close config has is_final=False)

        This prevents dialogue continuation and objection counter overflow.
        """
        mock_state_machine._intent_tracker.objection_consecutive.return_value = 3
        mock_state_machine._intent_tracker.objection_total.return_value = 5
        mock_state_machine.collected_data = {}

        decision = orchestrator.process_turn(
            intent="objection_price",
            extracted_data={},
            context_envelope=None,
        )

        sm_result = decision.to_sm_result()

        # CRITICAL ASSERTIONS
        assert sm_result["next_state"] == "soft_close"
        assert sm_result["is_final"] == True, \
            "is_final MUST be True when objection limit reached"
        assert sm_result["collected_data"].get("_objection_limit_final") == True, \
            "_objection_limit_final flag MUST be set in collected_data"

    def test_to_sm_result_includes_trace_field(self, orchestrator, mock_state_machine):
        """
        to_sm_result should include trace field for decision_trace.py compatibility.
        """
        decision = orchestrator.process_turn(
            intent="greeting",
            extracted_data={},
            context_envelope=None,
        )

        sm_result = decision.to_sm_result()

        # trace field should be present if resolution_trace exists
        if decision.resolution_trace:
            assert "trace" in sm_result
            assert sm_result["trace"] == decision.resolution_trace

    def test_to_sm_result_includes_prev_phase(self, orchestrator, mock_state_machine):
        """
        to_sm_result should include prev_phase for decision_trace phase tracking.
        """
        mock_state_machine.state = "spin_situation"

        decision = orchestrator.process_turn(
            intent="info_provided",
            extracted_data={"company_size": "15"},
            context_envelope=None,
        )

        sm_result = decision.to_sm_result()

        # prev_phase should be present
        assert "prev_phase" in sm_result

    # === Source management tests ===
    
    def test_add_source(self, orchestrator):
        """add_source should add a new Knowledge Source."""
        from src.blackboard.knowledge_source import KnowledgeSource
        
        class CustomSource(KnowledgeSource):
            def contribute(self, bb):
                pass
        
        custom = CustomSource("CustomSource")
        initial_count = len(orchestrator.sources)
        
        orchestrator.add_source(custom)
        
        assert len(orchestrator.sources) == initial_count + 1
    
    def test_remove_source(self, orchestrator):
        """remove_source should remove a Knowledge Source."""
        initial_count = len(orchestrator.sources)
        
        result = orchestrator.remove_source("PriceQuestionSource")
        
        assert result == True
        assert len(orchestrator.sources) == initial_count - 1
    
    # === Error handling tests ===
    
    def test_process_turn_handles_source_error(self, orchestrator):
        """process_turn should handle errors in Knowledge Sources."""
        # Add a failing source
        from src.blackboard.knowledge_source import KnowledgeSource
        
        class FailingSource(KnowledgeSource):
            def should_contribute(self, bb):
                return True
            def contribute(self, bb):
                raise ValueError("Test error")
        
        orchestrator.add_source(FailingSource("FailingSource"))
        
        # Should not raise, should return fallback
        decision = orchestrator.process_turn(
            intent="test",
            extracted_data={},
            context_envelope=None,
        )
        
        assert decision is not None
    
    # === Factory function tests ===
    
    def test_create_orchestrator_factory(self, mock_state_machine, mock_flow_config):
        """create_orchestrator should create configured orchestrator."""
        orchestrator = create_orchestrator(
            state_machine=mock_state_machine,
            flow_config=mock_flow_config,
            enable_metrics=True,
            enable_debug_logging=True,
        )

        assert orchestrator is not None
        # Sources are loaded via SourceRegistry (6 built-in sources)
        assert len(orchestrator.sources) == 6

    def test_create_orchestrator_with_custom_source(self, mock_state_machine, mock_flow_config):
        """create_orchestrator should support custom sources via Plugin System."""
        from src.blackboard.knowledge_source import KnowledgeSource
        from src.blackboard.source_registry import SourceRegistry

        # Reset registry to ensure clean state
        SourceRegistry.reset()

        class MyCustomSource(KnowledgeSource):
            """Custom source for testing."""
            def contribute(self, blackboard):
                pass

        orchestrator = create_orchestrator(
            state_machine=mock_state_machine,
            flow_config=mock_flow_config,
            custom_sources=[MyCustomSource],
        )

        # Should have built-in sources + custom source
        source_names = [s.name for s in orchestrator.sources]
        assert "MyCustomSource" in source_names

    def test_orchestrator_loads_sources_from_registry(self, mock_state_machine, mock_flow_config):
        """DialogueOrchestrator should load sources from SourceRegistry."""
        orchestrator = create_orchestrator(
            state_machine=mock_state_machine,
            flow_config=mock_flow_config,
        )

        # Verify sources are in priority_order
        source_names = [s.name for s in orchestrator.sources]
        assert source_names[0] == "PriceQuestionSource"  # priority 10
        assert "DataCollectorSource" in source_names
        assert "EscalationSource" in source_names
18. Integration Tests

# tests/test_blackboard_integration.py

import pytest
from unittest.mock import Mock

from src.blackboard.orchestrator import DialogueOrchestrator
from src.blackboard.blackboard import DialogueBlackboard
from src.blackboard.conflict_resolver import ConflictResolver
from src.blackboard.sources.price_question import PriceQuestionSource
from src.blackboard.sources.data_collector import DataCollectorSource
from src.blackboard.sources.objection_guard import ObjectionGuardSource


class TestBlackboardIntegration:
    """
    Integration tests for the complete Blackboard system.
    
    These tests verify end-to-end behavior with real components
    (not mocks) to ensure the system works as designed.
    """
    
    @pytest.fixture
    def real_state_machine(self):
        """Create a real (or near-real) state machine."""
        from src.state_machine import StateMachine
        from src.config_loader import ConfigLoader
        
        # Use real config loader
        config_loader = ConfigLoader()
        sm = StateMachine(config_loader=config_loader)
        sm.state = "spin_situation"
        
        return sm
    
    @pytest.fixture
    def real_flow_config(self):
        """Load real flow config."""
        from src.config_loader import ConfigLoader
        
        config_loader = ConfigLoader()
        return config_loader.get_flow_config()
    
    # === Scenario Tests ===
    
    def test_scenario_price_question_with_data(self, real_state_machine, real_flow_config):
        """
        Scenario: User provides company size while asking about price.
        
        Input: "Ğ£ Ğ½Ğ°Ñ 15 Ñ‡ĞµĞ»Ğ¾Ğ²ĞµĞº. Ğ¡ĞºĞ¾Ğ»ÑŒĞºĞ¾ ÑÑ‚Ğ¾Ğ¸Ñ‚?"
        Expected: Answer price AND advance to next phase.
        """
        orchestrator = DialogueOrchestrator(
            state_machine=real_state_machine,
            flow_config=real_flow_config,
        )
        
        real_state_machine.state = "spin_situation"
        real_state_machine.collected_data = {}
        
        decision = orchestrator.process_turn(
            intent="price_question",
            extracted_data={"company_size": "15"},
            context_envelope=None,
        )
        
        assert decision.action == "answer_with_pricing"
        # Next state depends on actual config, but should NOT be spin_situation
        # if data_complete transition is defined
    
    def test_scenario_multiple_objections(self, real_state_machine, real_flow_config):
        """
        Scenario: User raises multiple objections.
        
        After reaching limit, should soft close.
        """
        orchestrator = DialogueOrchestrator(
            state_machine=real_state_machine,
            flow_config=real_flow_config,
        )
        
        real_state_machine.state = "spin_problem"
        
        # Simulate previous objections
        for _ in range(3):
            real_state_machine._intent_tracker.record("objection_price", "spin_problem")
        
        decision = orchestrator.process_turn(
            intent="objection_price",
            extracted_data={},
            context_envelope=None,
        )
        
        # Should trigger limit
        assert "objection_limit" in decision.action or decision.next_state == "soft_close"
    
    def test_scenario_normal_flow(self, real_state_machine, real_flow_config):
        """
        Scenario: Normal conversation flow.
        
        User provides situation info -> advance to problem phase.
        """
        orchestrator = DialogueOrchestrator(
            state_machine=real_state_machine,
            flow_config=real_flow_config,
        )
        
        real_state_machine.state = "spin_situation"
        real_state_machine.collected_data = {}
        
        # Provide required data
        decision = orchestrator.process_turn(
            intent="situation_provided",
            extracted_data={"company_size": "50", "industry": "tech"},
            context_envelope=None,
        )
        
        # Should have some action and potentially transition
        assert decision.action is not None
    
    def test_scenario_rejection(self, real_state_machine, real_flow_config):
        """
        Scenario: User rejects completely.
        
        Should transition to soft_close with BLOCKING action.
        """
        orchestrator = DialogueOrchestrator(
            state_machine=real_state_machine,
            flow_config=real_flow_config,
        )
        
        real_state_machine.state = "spin_situation"
        
        decision = orchestrator.process_turn(
            intent="rejection",
            extracted_data={},
            context_envelope=None,
        )
        
        # Rejection should block other transitions
        assert decision.next_state in ["soft_close", "spin_situation"]


class TestBugFixes:
    """
    Tests that verify Blackboard fixes known bugs from the old system.

    NOTE: Legacy ÑĞ¸ÑÑ‚ĞµĞ¼Ğ° Ğ¿Ğ¾Ğ»Ğ½Ğ¾ÑÑ‚ÑŒÑ ÑƒĞ´Ğ°Ğ»ĞµĞ½Ğ°, ÑÑ‚Ğ¸ Ñ‚ĞµÑÑ‚Ñ‹ Ğ´Ğ¾ĞºÑƒĞ¼ĞµĞ½Ñ‚Ğ¸Ñ€ÑƒÑÑ‚
    Ğ¸ÑĞ¿Ñ€Ğ°Ğ²Ğ»ĞµĞ½Ğ½Ğ¾Ğµ Ğ¿Ğ¾Ğ²ĞµĞ´ĞµĞ½Ğ¸Ğµ (Ğ½Ğµ ÑÑ€Ğ°Ğ²Ğ½Ğ¸Ğ²Ğ°ÑÑ‚ Ñ legacy).
    """

    def test_price_question_no_longer_blocks_transition(self):
        """
        Verify the core bug is fixed.

        OLD BEHAVIOR (BUG):
        - price_question -> return("answer_with_pricing", SAME_STATE)
        - data_complete check NEVER reached
        - Bot stuck in spin_situation asking same questions

        NEW BEHAVIOR (FIXED):
        - price_question -> propose_action("answer_with_pricing", combinable=True)
        - data_complete -> propose_transition("spin_problem")
        - BOTH applied â€” bot answers price AND advances to next phase
        """
        # Implementation in test_orchestrator.py::test_price_question_with_data_complete_scenario
        pass

    def test_persona_limits_respected(self):
        """
        Verify persona-specific objection limits work correctly.

        - aggressive persona: 5 consecutive, 8 total
        - busy persona: 2 consecutive, 4 total
        - default: 3 consecutive, 5 total
        """
        # Implementation in test_sources_objection.py
        pass

    def test_blocking_actions_work(self):
        """
        Verify combinable=False blocks transitions correctly.

        - rejection -> blocks data_complete transition
        - escalation -> blocks all other transitions
        - objection_limit_reached -> blocks continuation
        """
        # Implementation in test_conflict_resolver.py
        pass


class TestPerformance:
    """Performance benchmarks for Blackboard system."""
    
    def test_process_turn_latency(self, benchmark):
        """Benchmark process_turn latency."""
        # This would use pytest-benchmark
        pass
    
    def test_source_contribution_latency(self, benchmark):
        """Benchmark individual source contribution time."""
        pass
19. Regression Tests

# tests/test_blackboard_regression.py

import pytest
import json
from pathlib import Path


class TestBlackboardRegression:
    """
    Regression tests ensuring Blackboard produces EXPECTED behavior.

    NOTE: Ğ­Ñ‚Ğ¸ Ñ‚ĞµÑÑ‚Ñ‹ ĞĞ• ÑÑ€Ğ°Ğ²Ğ½Ğ¸Ğ²Ğ°ÑÑ‚ Ñ legacy ÑĞ¸ÑÑ‚ĞµĞ¼Ğ¾Ğ¹ (Ğ¾Ğ½Ğ° ÑƒĞ´Ğ°Ğ»ĞµĞ½Ğ°).
    ĞĞ½Ğ¸ Ğ¿Ñ€Ğ¾Ğ²ĞµÑ€ÑÑÑ‚ Ñ‡Ñ‚Ğ¾ Blackboard Ñ€Ğ°Ğ±Ğ¾Ñ‚Ğ°ĞµÑ‚ ĞºĞ°Ğº Ğ—ĞĞ”Ğ£ĞœĞĞĞ.
    """
    
    @pytest.fixture
    def regression_scenarios(self):
        """Load regression test scenarios."""
        scenarios_file = Path(__file__).parent / "fixtures" / "regression_scenarios.json"
        
        if scenarios_file.exists():
            with open(scenarios_file) as f:
                return json.load(f)
        
        # Default scenarios if file doesn't exist
        return [
            {
                "name": "price_question_with_data_complete",
                "initial_state": "spin_situation",
                "collected_data": {},
                "intent": "price_question",
                "extracted_data": {"company_size": "15"},
                "expected_action": "answer_with_pricing",
                "expected_state": "spin_problem",
                "expected_reason_codes": ["price_question_priority", "data_complete"],
            },
            {
                "name": "objection_within_limits",
                "initial_state": "spin_problem",
                "collected_data": {"company_size": "50"},
                "intent": "objection_price",
                "extracted_data": {},
                "objection_consecutive": 1,
                "objection_total": 2,
                "expected_action_not": "objection_limit_reached",
                "expected_state_not": "soft_close",
            },
            {
                "name": "objection_exceeds_limits",
                "initial_state": "spin_problem",
                "collected_data": {"company_size": "50"},
                "intent": "objection_price",
                "extracted_data": {},
                "objection_consecutive": 3,
                "objection_total": 5,
                "expected_action": "objection_limit_reached",
                "expected_state": "soft_close",
            },
            {
                "name": "rejection_blocks_transition",
                "initial_state": "spin_situation",
                "collected_data": {"company_size": "50"},  # Data complete
                "intent": "rejection",
                "extracted_data": {},
                "expected_state": "soft_close",
                # Even though data is complete, rejection should win
            },
        ]
    
    def test_regression_scenarios(self, regression_scenarios):
        """Run all regression scenarios."""
        from src.blackboard.orchestrator import DialogueOrchestrator
        from unittest.mock import Mock
        
        for scenario in regression_scenarios:
            # Setup
            sm = Mock()
            sm.state = scenario["initial_state"]
            sm.collected_data = scenario["collected_data"]
            sm._intent_tracker = Mock()
            sm._intent_tracker.turn_number = 0
            sm._intent_tracker.record = Mock()
            sm._intent_tracker.prev_intent = None
            sm._intent_tracker.objection_consecutive.return_value = scenario.get("objection_consecutive", 0)
            sm._intent_tracker.objection_total.return_value = scenario.get("objection_total", 0)
            sm._intent_tracker.total_count.return_value = 0
            sm._intent_tracker.category_total.return_value = 0
            
            flow_config = Mock()
            flow_config.states = {
                "spin_situation": {
                    "required_data": ["company_size"],
                    "is_final": False,
                    "transitions": {"data_complete": "spin_problem", "rejection": "soft_close"},
                    "rules": {},
                },
                "spin_problem": {
                    "required_data": [],
                    "is_final": False,
                    "transitions": {},
                    "rules": {},
                },
                "soft_close": {
                    "is_final": True,
                    "transitions": {},
                    "rules": {},
                },
            }
            
            orchestrator = DialogueOrchestrator(
                state_machine=sm,
                flow_config=flow_config,
            )
            
            # Execute
            decision = orchestrator.process_turn(
                intent=scenario["intent"],
                extracted_data=scenario["extracted_data"],
                context_envelope=None,
            )
            
            # Verify
            if "expected_action" in scenario:
                assert decision.action == scenario["expected_action"], \
                    f"Scenario '{scenario['name']}': expected action {scenario['expected_action']}, got {decision.action}"
            
            if "expected_state" in scenario:
                assert decision.next_state == scenario["expected_state"], \
                    f"Scenario '{scenario['name']}': expected state {scenario['expected_state']}, got {decision.next_state}"
            
            if "expected_action_not" in scenario:
                assert decision.action != scenario["expected_action_not"], \
                    f"Scenario '{scenario['name']}': action should NOT be {scenario['expected_action_not']}"
            
            if "expected_state_not" in scenario:
                assert decision.next_state != scenario["expected_state_not"], \
                    f"Scenario '{scenario['name']}': state should NOT be {scenario['expected_state_not']}"
            
            if "expected_reason_codes" in scenario:
                for code in scenario["expected_reason_codes"]:
                    assert code in decision.reason_codes, \
                        f"Scenario '{scenario['name']}': expected reason code {code} not found"
20. Verification Checklist

20.1 Pre-Development Checklist (Phase 1)

## Before Writing Any Code

### Understanding
- [ ] ĞŸĞ¾Ğ»Ğ½Ğ¾ÑÑ‚ÑŒÑ Ğ¿Ğ¾Ğ½ÑĞ» Ğ°Ñ€Ñ…Ğ¸Ñ‚ĞµĞºÑ‚ÑƒÑ€Ñƒ Blackboard
- [ ] ĞŸĞ¾Ğ½ÑĞ» ĞºĞ°Ğº Ñ€Ğ°Ğ±Ğ¾Ñ‚Ğ°ĞµÑ‚ combinable Ñ„Ğ»Ğ°Ğ³
- [ ] ĞŸĞ¾Ğ½ÑĞ» Ñ€Ğ°Ğ·Ğ½Ğ¸Ñ†Ñƒ Ğ¼ĞµĞ¶Ğ´Ñƒ 6 Knowledge Sources
- [ ] Ğ—Ğ½Ğ°Ñ Ñ‡Ñ‚Ğ¾ Ğ¸Ğ¼ĞµĞ½Ğ½Ğ¾ ÑƒĞ´Ğ°Ğ»ÑĞµÑ‚ÑÑ Ğ¸Ğ· legacy ĞºĞ¾Ğ´Ğ°


20.2 Pre-Integration Checklist (Phase 2)

## Before Integrating with SalesBot

### Unit Tests (MUST PASS)
- [ ] All unit tests pass: `pytest tests/test_blackboard*.py -v`
- [ ] Test coverage > 90%: `pytest --cov=src/blackboard tests/`
- [ ] No flaky tests (run 3x): `pytest tests/ --count=3`

### Core Functionality
- [ ] PriceQuestionSource proposes combinable=True actions
- [ ] DataCollectorSource proposes transitions correctly
- [ ] ObjectionGuardSource respects persona limits
- [ ] ConflictResolver merges combinable actions with transitions
- [ ] ConflictResolver blocks transitions for combinable=False actions

### Code Quality
- [ ] No linting errors: `ruff check src/blackboard/`
- [ ] Type hints complete: `mypy src/blackboard/`
- [ ] Docstrings for all public methods


20.3 Pre-Deployment Checklist (Phase 3)

## Before Deploying to Production

### All Tests MUST Pass
- [ ] Unit tests: `pytest tests/test_blackboard*.py -v`
- [ ] Integration tests: `pytest tests/test_blackboard_integration.py -v`
- [ ] Regression tests: `pytest tests/test_blackboard_regression.py -v`
- [ ] Full suite: `pytest tests/ -v`

### Legacy Code Removal Verification
- [ ] `grep -r "def apply_rules" src/` returns NOTHING
- [ ] `grep -r "_apply_rules_priority_driven" src/` returns NOTHING
- [ ] `grep -r "_apply_priority" src/` returns NOTHING
- [ ] `grep -r "class RuleResult" src/` returns NOTHING
- [ ] `grep -r "blackboard_enabled" src/yaml_config/` returns NOTHING
- [ ] `grep -r "traffic_percentage" src/yaml_config/` returns NOTHING

### Performance
- [ ] process_turn latency < 10ms (p99)
- [ ] Memory overhead < 10MB per conversation
- [ ] No memory leaks (run 1000 turns)

### Configuration
- [ ] constants.yaml has persona_limits
- [ ] settings.yaml has NO legacy flags
- [ ] All reason_codes documented

### Manual Testing
- [ ] Scenario: price_question + data_complete â†’ BOTH applied
- [ ] Scenario: objection limit exceeded â†’ soft_close
- [ ] Scenario: rejection â†’ blocks transitions
- [ ] Scenario: normal SPIN flow â†’ works correctly
- [ ] Scenario: escalation request â†’ human_handoff


20.4 Post-Deployment Checklist (After Production Deploy)

## First 48 Hours After Deployment

### Error Monitoring
- [ ] Error rate < 0.1%
- [ ] No new error types
- [ ] No increase in exceptions

### Business Metrics
- [ ] Conversation completion rate stable or improved
- [ ] Lead conversion rate stable or improved
- [ ] Average conversation length stable

### Technical Metrics
- [ ] Response latency stable
- [ ] Memory usage stable
- [ ] CPU usage stable

### Improvements (Expected!)
- [ ] State loop count DECREASED (price_question bug fixed)
- [ ] More successful phase transitions
- [ ] Better handling of price questions with data

### Emergency Rollback Triggers
- [ ] Error rate > 1% for 15+ minutes â†’ git revert
- [ ] Bot completely non-functional â†’ git revert
- [ ] Data corruption detected â†’ git revert
21. Summary: Code Changes

=== ĞĞĞ’Ğ«Ğ™ ĞšĞĞ” ===

File                                    Lines    Purpose
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
src/blackboard/__init__.py              30       Module exports
src/blackboard/protocols.py             100      Hexagonal Architecture ports
src/blackboard/enums.py                 40       Priority, ProposalType
src/blackboard/models.py                200      Proposal, ResolvedDecision, ContextSnapshot
src/blackboard/blackboard.py            350      DialogueBlackboard
src/blackboard/knowledge_source.py      80       KnowledgeSource ABC
src/blackboard/source_registry.py       250      SourceRegistry (Plugin System)
src/blackboard/proposal_validator.py    150      ProposalValidator
src/blackboard/conflict_resolver.py     250      ConflictResolver
src/blackboard/event_bus.py             350      EventBus, Events, Subscribers
src/blackboard/orchestrator.py          420      DialogueOrchestrator
src/blackboard/sources/price_question.py    100  PriceQuestionSource
src/blackboard/sources/data_collector.py    100  DataCollectorSource
src/blackboard/sources/objection_guard.py   150  ObjectionGuardSource
src/blackboard/sources/intent_processor.py  150  IntentProcessorSource
src/blackboard/sources/transition_resolver.py 120 TransitionResolverSource
src/blackboard/sources/escalation.py        150  EscalationSource
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Total New Code                          ~2,990

tests/test_blackboard*.py               ~1,700   Test suite
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Total with Tests                        ~4,690


=== Ğ£Ğ”ĞĞ›Ğ¯Ğ•ĞœĞ«Ğ™ ĞšĞĞ” ===

File                     Lines Removed    What's Removed
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
src/state_machine.py     ~650            apply_rules() Ğ¸ Ğ²ÑĞµ ÑĞ²ÑĞ·Ğ°Ğ½Ğ½Ñ‹Ğµ Ğ¼ĞµÑ‚Ğ¾Ğ´Ñ‹:
                                         - apply_rules() (~324)
                                         - _apply_rules_priority_driven() (~74)
                                         - _apply_priority() (~106)
                                         - _priority_matches_intent() (~51)
                                         - _evaluate_priority_condition() (~29)
                                         - _call_priority_handler() (~59)
                                         - class RuleResult (~32)
src/bot.py               ~0              Ğ¢Ğ¾Ğ»ÑŒĞºĞ¾ ĞœĞĞ”Ğ˜Ğ¤Ğ˜ĞšĞĞ¦Ğ˜Ğ¯ (Ğ·Ğ°Ğ¼ĞµĞ½Ğ° Ğ²Ñ‹Ğ·Ğ¾Ğ²Ğ¾Ğ²)
                                         Shadow mode Ğ¼ĞµÑ‚Ğ¾Ğ´Ğ¾Ğ² Ğ½Ğµ ÑÑƒÑ‰ĞµÑÑ‚Ğ²Ğ¾Ğ²Ğ°Ğ»Ğ¾
src/settings.yaml        ~20            Legacy feature flags (ĞµÑĞ»Ğ¸ ÑÑƒÑ‰ĞµÑÑ‚Ğ²ÑƒÑÑ‚)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Total Removed            ~670


=== NET CHANGE ===

New Code:      +2,990 lines (production)
New Tests:     +1,700 lines (tests)
Removed Code:  -670 lines (Ğ¸Ğ· state_machine.py)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Net Addition:  +4,020 lines

ĞĞ¾ Ğ²Ğ°Ğ¶Ğ½ĞµĞµ ĞºĞ¾Ğ»Ğ¸Ñ‡ĞµÑÑ‚Ğ²Ğ° â€” ĞšĞĞ§Ğ•Ğ¡Ğ¢Ğ’Ğ:
- Ğ£Ğ´Ğ°Ğ»Ñ‘Ğ½ Ğ·Ğ°Ğ¿ÑƒÑ‚Ğ°Ğ½Ğ½Ñ‹Ğ¹ legacy ĞºĞ¾Ğ´ Ñ early returns
- Ğ”Ğ¾Ğ±Ğ°Ğ²Ğ»ĞµĞ½Ğ° Ñ‡Ğ¸ÑÑ‚Ğ°Ñ, Ñ€Ğ°ÑÑˆĞ¸Ñ€ÑĞµĞ¼Ğ°Ñ Ğ°Ñ€Ñ…Ğ¸Ñ‚ĞµĞºÑ‚ÑƒÑ€Ğ°
- ĞŸĞ¾Ğ»Ğ½Ğ¾Ğµ Ñ‚ĞµÑÑ‚Ğ¾Ğ²Ğ¾Ğµ Ğ¿Ğ¾ĞºÑ€Ñ‹Ñ‚Ğ¸Ğµ
22. Ğ—Ğ°ĞºĞ»ÑÑ‡ĞµĞ½Ğ¸Ğµ
Ğ”Ğ°Ğ½Ğ½Ñ‹Ğ¹ Ğ¿Ğ»Ğ°Ğ½ Ğ¿Ñ€ĞµĞ´ÑÑ‚Ğ°Ğ²Ğ»ÑĞµÑ‚ ÑĞ¾Ğ±Ğ¾Ğ¹ Ğ¿Ğ¾Ğ»Ğ½ÑƒÑ ÑĞ¿ĞµÑ†Ğ¸Ñ„Ğ¸ĞºĞ°Ñ†Ğ¸Ñ Dialogue Blackboard System Ñ ĞŸĞĞ›ĞĞĞ™ Ğ—ĞĞœĞ•ĞĞĞ™ legacy ÑĞ¸ÑÑ‚ĞµĞ¼Ñ‹.

=== ĞŸĞ Ğ˜ĞĞ¦Ğ˜ĞŸ ĞœĞ˜Ğ“Ğ ĞĞ¦Ğ˜Ğ˜ ===

âŒ ĞĞ•Ğ¢ shadow mode
âŒ ĞĞ•Ğ¢ gradual rollout
âŒ ĞĞ•Ğ¢ legacy ĞºĞ¾Ğ´Ğ° Ğ¿Ğ¾ÑĞ»Ğµ Ğ¼Ğ¸Ğ³Ñ€Ğ°Ñ†Ğ¸Ğ¸
âŒ ĞĞ•Ğ¢ feature flags Ğ´Ğ»Ñ Ğ¿ĞµÑ€ĞµĞºĞ»ÑÑ‡ĞµĞ½Ğ¸Ñ Ğ¼ĞµĞ¶Ğ´Ñƒ ÑĞ¸ÑÑ‚ĞµĞ¼Ğ°Ğ¼Ğ¸

âœ… ĞŸĞĞ›ĞĞĞ¯ Ğ·Ğ°Ğ¼ĞµĞ½Ğ° apply_rules() Ğ½Ğ° Blackboard
âœ… Ğ£Ğ”ĞĞ›Ğ•ĞĞ˜Ğ• Ğ²ÑĞµĞ³Ğ¾ legacy ĞºĞ¾Ğ´Ğ°
âœ… Ğ§Ğ˜Ğ¡Ğ¢Ğ«Ğ™ codebase Ğ±ĞµĞ· "Ğ¼Ñ‘Ñ€Ñ‚Ğ²Ğ¾Ğ³Ğ¾" ĞºĞ¾Ğ´Ğ°
âœ… Rollback Ñ‚Ğ¾Ğ»ÑŒĞºĞ¾ Ñ‡ĞµÑ€ĞµĞ· git revert (emergency only)


=== ĞšĞ›Ğ®Ğ§Ğ•Ğ’Ğ«Ğ• ĞĞ¡ĞĞ‘Ğ•ĞĞĞĞ¡Ğ¢Ğ˜ ĞŸĞ›ĞĞĞ ===

ĞÑ€Ñ…Ğ¸Ñ‚ĞµĞºÑ‚ÑƒÑ€Ğ°:
âœ… SourceRegistry (Plugin System) â€” Ğ´Ğ¸Ğ½Ğ°Ğ¼Ğ¸Ñ‡ĞµÑĞºĞ°Ñ Ñ€ĞµĞ³Ğ¸ÑÑ‚Ñ€Ğ°Ñ†Ğ¸Ñ Knowledge Sources
âœ… Configuration-driven sources â€” Ğ²ĞºĞ»ÑÑ‡ĞµĞ½Ğ¸Ğµ/Ğ¾Ñ‚ĞºĞ»ÑÑ‡ĞµĞ½Ğ¸Ğµ sources Ñ‡ĞµÑ€ĞµĞ· YAML
âœ… @register_source Ğ´ĞµĞºĞ¾Ñ€Ğ°Ñ‚Ğ¾Ñ€ Ğ´Ğ»Ñ Ğ¿Ñ€Ğ¾ÑÑ‚Ğ¾Ğ¹ Ñ€ĞµĞ³Ğ¸ÑÑ‚Ñ€Ğ°Ñ†Ğ¸Ğ¸ custom sources
âœ… combinable Ñ„Ğ»Ğ°Ğ³ Ğ¿Ğ¾Ğ»Ğ½Ğ¾ÑÑ‚ÑŒÑ Ñ€ĞµĞ°Ğ»Ğ¸Ğ·Ğ¾Ğ²Ğ°Ğ½ Ğ² ConflictResolver
âœ… rejected_proposals Ğ´Ğ¾Ğ±Ğ°Ğ²Ğ»ĞµĞ½ Ğ² Decision Layer Ğ´Ğ»Ñ debugging
âœ… 6 Knowledge Sources Ñ Ñ‡Ñ‘Ñ‚ĞºĞ¸Ğ¼ Ñ€Ğ°Ğ·Ğ´ĞµĞ»ĞµĞ½Ğ¸ĞµĞ¼ Ğ¾Ñ‚Ğ²ĞµÑ‚ÑÑ‚Ğ²ĞµĞ½Ğ½Ğ¾ÑÑ‚Ğ¸
âœ… DialogueEventBus Ğ´Ğ»Ñ observability
âœ… ProposalValidator Ğ´Ğ»Ñ Ğ²Ğ°Ğ»Ğ¸Ğ´Ğ°Ñ†Ğ¸Ğ¸
âœ… Hexagonal Architecture Ñ Protocols Ğ´Ğ»Ñ Ñ‚ĞµÑÑ‚Ğ¸Ñ€ÑƒĞµĞ¼Ğ¾ÑÑ‚Ğ¸

ĞœĞ¸Ğ³Ñ€Ğ°Ñ†Ğ¸Ñ:
âœ… 6-8 Ğ½ĞµĞ´ĞµĞ»ÑŒ (Ğ²Ğ¼ĞµÑÑ‚Ğ¾ 10-12)
âœ… Phase 1-2: Implementation & Testing
âœ… Phase 3: Legacy Removal & Deployment
âœ… Phase 4: Stabilization (buffer)
âœ… Ğ”ĞµÑ‚Ğ°Ğ»ÑŒĞ½Ñ‹Ğ¹ ÑĞ¿Ğ¸ÑĞ¾Ğº ÑƒĞ´Ğ°Ğ»ÑĞµĞ¼Ğ¾Ğ³Ğ¾ ĞºĞ¾Ğ´Ğ°

Ğ ĞµÑˆĞµĞ½Ğ¸Ğµ ĞºĞ¾Ñ€Ğ½ĞµĞ²Ğ¾Ğ¹ Ğ¿Ñ€Ğ¾Ğ±Ğ»ĞµĞ¼Ñ‹:
âœ… price_question + data_complete Ğ¿Ñ€Ğ¸Ğ¼ĞµĞ½ÑÑÑ‚ÑÑ ĞĞ”ĞĞĞ’Ğ Ğ•ĞœĞ•ĞĞĞ
âœ… Blocking actions (rejection, escalation) ĞºĞ¾Ñ€Ñ€ĞµĞºÑ‚Ğ½Ğ¾ Ğ±Ğ»Ğ¾ĞºĞ¸Ñ€ÑƒÑÑ‚ transitions
âœ… Persona-specific objection limits


=== ĞŸĞĞ¡Ğ›Ğ• ĞœĞ˜Ğ“Ğ ĞĞ¦Ğ˜Ğ˜ ===

StateMachine Ğ¾ÑÑ‚Ğ°Ñ‘Ñ‚ÑÑ, Ğ½Ğ¾ Ğ¢ĞĞ›Ğ¬ĞšĞ Ğ´Ğ»Ñ:
- Ğ¥Ñ€Ğ°Ğ½ĞµĞ½Ğ¸Ñ Ñ‚ĞµĞºÑƒÑ‰ĞµĞ³Ğ¾ state
- Ğ¥Ñ€Ğ°Ğ½ĞµĞ½Ğ¸Ñ collected_data
- IntentTracker

StateMachine ĞĞ• ÑĞ¾Ğ´ĞµÑ€Ğ¶Ğ¸Ñ‚:
- apply_rules() â€” Ğ£Ğ”ĞĞ›ĞĞ
- _apply_rules_priority_driven() â€” Ğ£Ğ”ĞĞ›ĞĞ
- _apply_priority() â€” Ğ£Ğ”ĞĞ›ĞĞ
- _priority_matches_intent() â€” Ğ£Ğ”ĞĞ›ĞĞ
- _evaluate_priority_condition() â€” Ğ£Ğ”ĞĞ›ĞĞ
- _call_priority_handler() â€” Ğ£Ğ”ĞĞ›ĞĞ
- class RuleResult â€” Ğ£Ğ”ĞĞ›ĞĞ
- Ğ›ÑĞ±ÑƒÑ Ğ»Ğ¾Ğ³Ğ¸ĞºÑƒ Ğ²Ñ‹Ğ±Ğ¾Ñ€Ğ° action/transition â€” Ğ£Ğ”ĞĞ›Ğ•ĞĞ

Dialogue management = Blackboard. Ğ¢Ğ¾Ñ‡ĞºĞ°.
