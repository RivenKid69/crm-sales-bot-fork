Dialogue Blackboard System — Финальный План v2.1
════════════════════════════════════════════════════════════════════════════════

                    ⚠️  СТРАТЕГИЯ МИГРАЦИИ: ПОЛНАЯ ЗАМЕНА  ⚠️

    ❌ НЕТ shadow mode          — не запускаем обе системы параллельно
    ❌ НЕТ gradual rollout      — не 10% → 25% → 50% → 100%
    ❌ НЕТ legacy кода          — apply_rules() УДАЛЯЕТСЯ полностью
    ❌ НЕТ feature flags        — для переключения между системами

    ✅ ПОЛНАЯ замена            — Blackboard = единственная система
    ✅ ЧИСТЫЙ codebase          — никакого мёртвого кода
    ✅ 6-8 недель               — быстрее чем gradual approach

    Rollback: git revert (только emergency)

════════════════════════════════════════════════════════════════════════════════

Часть 1: Введение и Научная База
1. Резюме
Ключевая инновация: Action Selection и State Transition — НЕЗАВИСИМЫЕ процессы, которые объединяются ConflictResolver с поддержкой combinable флага.

Решает корневую проблему: price_question + data_complete теперь НЕ конкурируют — оба применяются одновременно когда combinable=True.

Компоненты:

DialogueBlackboard — централизованное состояние с 3 слоями (Context/Proposal/Decision)
6 Knowledge Sources — независимые модули с чётким разделением ответственности
ConflictResolver — объединяет proposals с полной поддержкой combinable логики
DialogueOrchestrator — координатор всего процесса
DialogueEventBus — observability и аналитика
ProposalValidator — валидация proposals перед resolution
Migration: 6-8 недель с полной заменой старой системы. Никакого legacy кода — StateMachine.apply_rules() удаляется полностью.

Persona Limits: Включены динамические лимиты из YAML (aggressive: 5/8, busy: 2/4).

2. Научная база
2.1 Blackboard Architecture
Источники:

Exploring Advanced LLM Multi-Agent Systems Based on Blackboard Architecture (arxiv 2507.01701)
Blackboard System - Wikipedia
Memory in LLM-based Multi-agent Systems (TechRxiv)
Принципы:

Shared workspace (blackboard) итеративно обновляется специализированными Knowledge Sources
Knowledge Sources независимы и не знают друг о друге
Control Component координирует порядок выполнения и разрешает конфликты
2.2 State Machine Based Conversation Model
Источник: State Machine based Human-Bot Conversation Model (PMC7266438)

Ключевые findings:

Hierarchical State Machines показывают 56.61% улучшение для multi-turn диалогов
Поддержка multi-intent через nested state machines
Явное разделение intent fulfillment и state transitions
2.3 Behavior Trees vs FSM
Источник: Comparison between Behavior Trees and Finite State Machines (arxiv 2405.16137)

Ключевые findings:

O(1) масштабируемость BT vs O(n) FSM
BT обеспечивают модульность через композицию
FSM страдают от "state explosion" при росте сложности
2.4 Task-Oriented Dialogue Pipeline
Источники:

Unified Approach for Scalable Task-Oriented Dialogue System (IJACSA)
Enhancing Task-oriented Dialogue Systems (ACL 2023)
Pipeline: NLU → DST → Policy → NLG

Маппинг на Blackboard:

NLU = Existing Classifier (без изменений)
DST = Context Layer в DialogueBlackboard
Policy = Knowledge Sources + ConflictResolver
NLG = Existing Generator (без изменений)
2.5 Conflict Resolution in Multi-Agent Systems
Источники:

Conflict Resolution in Multi-Agent Systems (IEEE Xplore)
Conflict Resolution Techniques (Loro Journals)
Применяемые техники:

Priority-based resolution (highest priority wins)
Hierarchical decision structures
Combinable vs blocking actions
2.6 Enterprise Chatbot Best Practices
Источники:

Chatbot Best Practices 2025 (Classic Informatics)
Sales Chatbot Deployment (Avrion)
Ключевые практики:

Human escalation triggers
Persona-based customization
Comprehensive testing before deployment
3. Корневая проблема
3.1 Текущее поведение (СЛОМАНО)

User: "У нас 15 человек. Сколько стоит?"

ТЕКУЩИЙ FLOW:
├─ Classifier: intent = price_question
├─ DataExtractor: company_size = 15 ✓ (сохраняется в collected_data)
├─ StateMachine.apply_rules():
│   ├─ IntentTracker.record("price_question", "spin_situation")
│   ├─ PRIORITY 1.9: price_question detected
│   │   └─ return ("answer_with_pricing", "spin_situation") ← EARLY RETURN!
│   │
│   └─ PRIORITY 4: data_complete check
│       └─ НИКОГДА НЕ ДОСТИГАЕТСЯ (early return выше)
│
└─ Результат: 
   ├─ Бот отвечает на вопрос о цене ✓
   ├─ Бот ОСТАЁТСЯ в spin_situation ✗
   └─ Бот продолжает спрашивать situation questions ✗
   
STATE LOOP: spin_situation → spin_situation → spin_situation → ...
3.2 Новое поведение (ИСПРАВЛЕНО)

User: "У нас 15 человек. Сколько стоит?"

НОВЫЙ FLOW (Blackboard):
├─ Classifier: intent = price_question
├─ DataExtractor: company_size = 15 ✓
├─ DialogueOrchestrator.process_turn():
│   ├─ blackboard.begin_turn(intent, extracted_data)
│   │
│   ├─ Knowledge Sources (НЕЗАВИСИМО, ПАРАЛЛЕЛЬНО):
│   │   ├─ PriceQuestionSource.contribute(bb)
│   │   │   └─ bb.propose_action("answer_with_pricing", combinable=True)
│   │   │
│   │   ├─ DataCollectorSource.contribute(bb)
│   │   │   └─ bb.propose_transition("spin_problem") ← data_complete!
│   │   │
│   │   ├─ ObjectionGuardSource.contribute(bb)
│   │   │   └─ (no proposals - not an objection)
│   │   │
│   │   ├─ IntentProcessorSource.contribute(bb)
│   │   │   └─ (no proposals - price handled by dedicated source)
│   │   │
│   │   ├─ TransitionResolverSource.contribute(bb)
│   │   │   └─ (no proposals - no explicit transition for price_question)
│   │   │
│   │   └─ EscalationSource.contribute(bb)
│   │       └─ (no proposals - no escalation triggers)
│   │
│   ├─ ProposalValidator.validate(bb.proposals)
│   │   └─ All proposals valid ✓
│   │
│   ├─ ConflictResolver.resolve(bb.proposals)
│   │   ├─ Action winner: "answer_with_pricing" (combinable=True)
│   │   ├─ Transition winner: "spin_problem"
│   │   └─ MERGE: action + transition (because combinable=True)
│   │
│   └─ blackboard.commit_decision()
│       ├─ final_action = "answer_with_pricing"
│       ├─ next_state = "spin_problem"
│       └─ reason_codes = ["price_question_priority", "data_complete"]
│
└─ Результат:
   ├─ Бот отвечает на вопрос о цене ✓
   ├─ Бот ПЕРЕХОДИТ в spin_problem ✓
   └─ Бот начинает problem phase ✓
Продолжаю со второй частью — Архитектура.

продожай
Часть 2: Архитектура
4. Общая архитектура
4.1 High-Level Architecture Diagram

┌─────────────────────────────────────────────────────────────────────────────────────┐
│                              DialogueOrchestrator                                    │
│                                                                                      │
│  ┌─────────────────────────────────────────────────────────────────────────────┐   │
│  │ process_turn(intent, extracted_data, context_envelope):                      │   │
│  │   1. blackboard.begin_turn(intent, extracted_data, context_envelope)         │   │
│  │   2. for source in knowledge_sources:                                        │   │
│  │        if source.should_contribute(blackboard):                              │   │
│  │            source.contribute(blackboard)                                     │   │
│  │            event_bus.emit(SourceContributed(source, blackboard.proposals))   │   │
│  │   3. validation_errors = validator.validate(blackboard.proposals)            │   │
│  │   4. if validation_errors: handle_validation_errors(validation_errors)       │   │
│  │   5. decision = conflict_resolver.resolve(blackboard.proposals)              │   │
│  │   6. blackboard.commit_decision(decision)                                    │   │
│  │   7. event_bus.emit(DecisionCommitted(decision))                             │   │
│  │   8. return decision                                                         │   │
│  └─────────────────────────────────────────────────────────────────────────────┘   │
└─────────────────────────────────────────────────────────────────────────────────────┘
                                          │
                                          │ coordinates
                                          ▼
        ┌─────────────────────────────────┼─────────────────────────────────┐
        │                                 │                                 │
        ▼                                 ▼                                 ▼
┌───────────────────┐           ┌───────────────────┐           ┌───────────────────┐
│ PriceQuestion     │           │ DataCollector     │           │ ObjectionGuard    │
│ Source            │           │ Source            │           │ Source            │
│                   │           │                   │           │                   │
│ Responsibility:   │           │ Responsibility:   │           │ Responsibility:   │
│ Price-related     │           │ Data completeness │           │ Objection limits  │
│ questions only    │           │ checks ONLY       │           │ per persona       │
│                   │           │                   │           │                   │
│ Proposes:         │           │ Proposes:         │           │ Proposes:         │
│ - action (comb.)  │           │ - transition      │           │ - transition      │
│                   │           │   (data_complete) │           │ - action          │
└─────────┬─────────┘           └─────────┬─────────┘           └─────────┬─────────┘
          │                               │                               │
          │                               │                               │
        ┌─┴─────────────────────────────────────────────────────────────┬─┘
        │                                 │                             │
        ▼                                 ▼                             ▼
┌───────────────────┐           ┌───────────────────┐           ┌───────────────────┐
│ IntentProcessor   │           │ TransitionResolver│           │ Escalation        │
│ Source            │           │ Source            │           │ Source            │
│                   │           │                   │           │                   │
│ Responsibility:   │           │ Responsibility:   │           │ Responsibility:   │
│ General intent→   │           │ Intent-based      │           │ Human handoff     │
│ action mapping    │           │ transitions ONLY  │           │ triggers          │
│ (from rules)      │           │ (explicit config) │           │                   │
│                   │           │                   │           │ Proposes:         │
│ Proposes:         │           │ Proposes:         │           │ - action          │
│ - action          │           │ - transition      │           │   (blocking)      │
└─────────┬─────────┘           └─────────┬─────────┘           └─────────┬─────────┘
          │                               │                               │
          └───────────────────────────────┼───────────────────────────────┘
                                          │
                                          ▼
┌─────────────────────────────────────────────────────────────────────────────────────┐
│                              DialogueBlackboard                                      │
│                                                                                      │
│  ┌──────────────────────┐  ┌──────────────────────┐  ┌────────────────────────┐    │
│  │   Context Layer      │  │   Proposal Layer     │  │   Decision Layer       │    │
│  │   (READ-ONLY)        │  │   (WRITE by Sources) │  │   (WRITE by Resolver)  │    │
│  │                      │  │                      │  │                        │    │
│  │ • state              │  │ • action_proposals   │  │ • final_action         │    │
│  │ • collected_data     │  │ • transition_props   │  │ • next_state           │    │
│  │ • current_intent     │  │ • data_updates       │  │ • reason_codes         │    │
│  │ • intent_tracker     │  │ • metadata           │  │ • rejected_proposals   │    │
│  │ • context_envelope   │  │                      │  │ • resolution_trace     │    │
│  │ • turn_number        │  │                      │  │                        │    │
│  │ • persona            │  │                      │  │                        │    │
│  └──────────────────────┘  └──────────────────────┘  └────────────────────────┘    │
│                                                                                      │
└─────────────────────────────────────────────────────────────────────────────────────┘
                                          │
                                          │ proposals
                                          ▼
┌─────────────────────────────────────────────────────────────────────────────────────┐
│                              ProposalValidator                                       │
│                                                                                      │
│  validate(proposals) → List[ValidationError]:                                        │
│    • Check priority is valid enum value                                              │
│    • Check action/transition values exist in config                                  │
│    • Check combinable flag is boolean                                                │
│    • Check reason_code is documented                                                 │
│    • Return list of errors (empty if all valid)                                      │
│                                                                                      │
└─────────────────────────────────────────────────────────────────────────────────────┘
                                          │
                                          │ validated proposals
                                          ▼
┌─────────────────────────────────────────────────────────────────────────────────────┐
│                              ConflictResolver                                        │
│                                                                                      │
│  resolve(proposals, current_state) → ResolvedDecision:                               │
│                                                                                      │
│  ┌─────────────────────────────────────────────────────────────────────────────┐   │
│  │ ALGORITHM:                                                                   │   │
│  │                                                                              │   │
│  │ 1. Separate proposals by type:                                               │   │
│  │    action_proposals = [p for p in proposals if p.type == ACTION]             │   │
│  │    transition_proposals = [p for p in proposals if p.type == TRANSITION]     │   │
│  │                                                                              │   │
│  │ 2. Sort each list by priority (CRITICAL > HIGH > NORMAL > LOW):              │   │
│  │    action_proposals.sort(key=lambda p: p.priority.value)                     │   │
│  │    transition_proposals.sort(key=lambda p: p.priority.value)                 │   │
│  │                                                                              │   │
│  │ 3. Select winning action:                                                    │   │
│  │    winning_action = action_proposals[0] if action_proposals else None        │   │
│  │                                                                              │   │
│  │ 4. CRITICAL: Check combinable flag:                                          │   │
│  │    if winning_action and not winning_action.combinable:                      │   │
│  │        # BLOCKING action - ignore all transitions                            │   │
│  │        return ResolvedDecision(                                              │   │
│  │            action=winning_action.value,                                      │   │
│  │            next_state=current_state,  # NO STATE CHANGE                      │   │
│  │            reason_codes=[winning_action.reason_code],                        │   │
│  │            rejected_proposals=transition_proposals + action_proposals[1:]    │   │
│  │        )                                                                     │   │
│  │                                                                              │   │
│  │ 5. If combinable=True or no action, merge action + transition:               │   │
│  │    winning_transition = transition_proposals[0] if transition_proposals      │   │
│  │                         else None                                            │   │
│  │    return ResolvedDecision(                                                  │   │
│  │        action=winning_action.value if winning_action else "continue",        │   │
│  │        next_state=winning_transition.value if winning_transition             │   │
│  │                   else current_state,                                        │   │
│  │        reason_codes=[...],                                                   │   │
│  │        rejected_proposals=[...]                                              │   │
│  │    )                                                                         │   │
│  └─────────────────────────────────────────────────────────────────────────────┘   │
│                                                                                      │
└─────────────────────────────────────────────────────────────────────────────────────┘
                                          │
                                          │ events
                                          ▼
┌─────────────────────────────────────────────────────────────────────────────────────┐
│                              DialogueEventBus                                        │
│                                                                                      │
│  Events emitted:                                                                     │
│  • TurnStarted(turn_number, intent, state)                                           │
│  • SourceContributed(source_name, proposals_count, proposals_summary)                │
│  • ProposalValidated(valid_count, error_count, errors)                               │
│  • ConflictResolved(winning_action, winning_transition, rejected_count)              │
│  • DecisionCommitted(action, next_state, reason_codes)                               │
│  • StateTransitioned(from_state, to_state, trigger_reason)                           │
│                                                                                      │
│  Subscribers:                                                                        │
│  • MetricsCollector - записывает в metrics store                                     │
│  • DebugLogger - подробные логи для отладки                                          │
│  • AnalyticsTracker - бизнес-аналитика                                               │
│  • AlertManager - алерты при аномалиях                                               │
│                                                                                      │
└─────────────────────────────────────────────────────────────────────────────────────┘
4.2 Data Flow Sequence Diagram

User Message: "У нас 15 человек. Сколько стоит?"
    │
    ▼
┌─────────────────────────────────────────────────────────────────┐
│                        SalesBot.process()                        │
│  (existing code - unchanged)                                     │
└─────────────────────────────────────────────────────────────────┘
    │
    │ 1. Classify intent
    ▼
┌─────────────────────────────────────────────────────────────────┐
│                     UnifiedClassifier                            │
│  Returns: {intent: "price_question", extracted_data: {...}}      │
└─────────────────────────────────────────────────────────────────┘
    │
    │ 2. Extract data
    ▼
┌─────────────────────────────────────────────────────────────────┐
│                     DataExtractor                                │
│  Returns: {company_size: "15"}                                   │
└─────────────────────────────────────────────────────────────────┘
    │
    │ 3. Build context envelope (existing Phase 5)
    ▼
┌─────────────────────────────────────────────────────────────────┐
│                     ContextEnvelope                              │
│  Contains: state_machine, context_window, tone_info, etc.        │
└─────────────────────────────────────────────────────────────────┘
    │
    │ 4. Process through Blackboard (NEW - replaces apply_rules)
    ▼
┌─────────────────────────────────────────────────────────────────┐
│                   DialogueOrchestrator                           │
│                                                                  │
│  ┌────────────────────────────────────────────────────────────┐ │
│  │ STEP 1: Begin Turn                                         │ │
│  │ blackboard.begin_turn(                                     │ │
│  │     intent="price_question",                               │ │
│  │     extracted_data={company_size: "15"},                   │ │
│  │     context_envelope=envelope                              │ │
│  │ )                                                          │ │
│  │                                                            │ │
│  │ Blackboard Context Layer now contains:                     │ │
│  │ • state: "spin_situation"                                  │ │
│  │ • collected_data: {company_size: "15"}  ← UPDATED!         │ │
│  │ • current_intent: "price_question"                         │ │
│  │ • persona: "default"                                       │ │
│  └────────────────────────────────────────────────────────────┘ │
│                              │                                   │
│                              ▼                                   │
│  ┌────────────────────────────────────────────────────────────┐ │
│  │ STEP 2: Knowledge Sources Contribute                       │ │
│  │                                                            │ │
│  │ PriceQuestionSource.should_contribute(bb) → True           │ │
│  │ PriceQuestionSource.contribute(bb):                        │ │
│  │   bb.propose_action(                                       │ │
│  │       action="answer_with_pricing",                        │ │
│  │       priority=Priority.HIGH,                              │ │
│  │       combinable=True,              ← KEY!                 │ │
│  │       reason_code="price_question_priority"                │ │
│  │   )                                                        │ │
│  │                                                            │ │
│  │ DataCollectorSource.should_contribute(bb) → True           │ │
│  │ DataCollectorSource.contribute(bb):                        │ │
│  │   required = ["company_size"]                              │ │
│  │   collected = {company_size: "15"}                         │ │
│  │   missing = []  ← ALL DATA COLLECTED!                      │ │
│  │   bb.propose_transition(                                   │ │
│  │       next_state="spin_problem",                           │ │
│  │       priority=Priority.NORMAL,                            │ │
│  │       reason_code="data_complete"                          │ │
│  │   )                                                        │ │
│  │                                                            │ │
│  │ ObjectionGuardSource.should_contribute(bb) → False         │ │
│  │   (intent not in objection category)                       │ │
│  │                                                            │ │
│  │ IntentProcessorSource.should_contribute(bb) → False        │ │
│  │   (price_question handled by dedicated source)             │ │
│  │                                                            │ │
│  │ TransitionResolverSource.should_contribute(bb) → False     │ │
│  │   (no explicit transition mapping for price_question)      │ │
│  │                                                            │ │
│  │ EscalationSource.should_contribute(bb) → False             │ │
│  │   (no escalation triggers active)                          │ │
│  └────────────────────────────────────────────────────────────┘ │
│                              │                                   │
│                              ▼                                   │
│  ┌────────────────────────────────────────────────────────────┐ │
│  │ STEP 3: Validate Proposals                                 │ │
│  │                                                            │ │
│  │ Proposals in blackboard:                                   │ │
│  │ [                                                          │ │
│  │   Proposal(ACTION, "answer_with_pricing", HIGH, comb=True),│ │
│  │   Proposal(TRANSITION, "spin_problem", NORMAL)             │ │
│  │ ]                                                          │ │
│  │                                                            │ │
│  │ validator.validate(proposals) → []  (no errors)            │ │
│  └────────────────────────────────────────────────────────────┘ │
│                              │                                   │
│                              ▼                                   │
│  ┌────────────────────────────────────────────────────────────┐ │
│  │ STEP 4: Resolve Conflicts                                  │ │
│  │                                                            │ │
│  │ conflict_resolver.resolve(proposals, "spin_situation"):    │ │
│  │                                                            │ │
│  │ 1. Separate by type:                                       │ │
│  │    actions = [Proposal(ACTION, "answer_with_pricing",...)] │ │
│  │    transitions = [Proposal(TRANSITION, "spin_problem",...)]│ │
│  │                                                            │ │
│  │ 2. Sort by priority:                                       │ │
│  │    actions[0] = "answer_with_pricing" (HIGH)               │ │
│  │    transitions[0] = "spin_problem" (NORMAL)                │ │
│  │                                                            │ │
│  │ 3. Check combinable:                                       │ │
│  │    actions[0].combinable = True ← ALLOWS MERGE!            │ │
│  │                                                            │ │
│  │ 4. Return merged decision:                                 │ │
│  │    ResolvedDecision(                                       │ │
│  │        action="answer_with_pricing",                       │ │
│  │        next_state="spin_problem",    ← TRANSITION APPLIED! │ │
│  │        reason_codes=["price_question_priority",            │ │
│  │                      "data_complete"],                     │ │
│  │        rejected_proposals=[]                               │ │
│  │    )                                                       │ │
│  └────────────────────────────────────────────────────────────┘ │
│                              │                                   │
│                              ▼                                   │
│  ┌────────────────────────────────────────────────────────────┐ │
│  │ STEP 5: Commit Decision                                    │ │
│  │                                                            │ │
│  │ blackboard.commit_decision(decision)                       │ │
│  │                                                            │ │
│  │ Decision Layer now contains:                               │ │
│  │ • final_action: "answer_with_pricing"                      │ │
│  │ • next_state: "spin_problem"                               │ │
│  │ • reason_codes: ["price_question_priority", "data_complete"]│
│  │ • rejected_proposals: []                                   │ │
│  │ • resolution_trace: {...}                                  │ │
│  └────────────────────────────────────────────────────────────┘ │
│                              │                                   │
│                              ▼                                   │
│  ┌────────────────────────────────────────────────────────────┐ │
│  │ STEP 6: Emit Events                                        │ │
│  │                                                            │ │
│  │ event_bus.emit(DecisionCommitted(                          │ │
│  │     action="answer_with_pricing",                          │ │
│  │     next_state="spin_problem",                             │ │
│  │     reason_codes=[...]                                     │ │
│  │ ))                                                         │ │
│  │                                                            │ │
│  │ event_bus.emit(StateTransitioned(                          │ │
│  │     from_state="spin_situation",                           │ │
│  │     to_state="spin_problem",                               │ │
│  │     trigger_reason="data_complete"                         │ │
│  │ ))                                                         │ │
│  └────────────────────────────────────────────────────────────┘ │
└─────────────────────────────────────────────────────────────────┘
    │
    │ 5. Return to SalesBot
    ▼
┌─────────────────────────────────────────────────────────────────┐
│                      SalesBot.process()                          │
│                                                                  │
│  action = "answer_with_pricing"                                  │
│  next_state = "spin_problem"                                     │
│                                                                  │
│  # Update state machine                                          │
│  state_machine.state = "spin_problem"                            │
│                                                                  │
│  # Generate response                                             │
│  response = generator.generate(action, context)                  │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘
    │
    ▼
Bot Response: "Стоимость зависит от размера команды. Для 15 человек..."
Next State: spin_problem (CORRECTLY TRANSITIONED!)
Продолжаю с третьей частью — Детальная спецификация компонентов.

продолжай
Часть 3: Детальная спецификация компонентов
5. Core Data Structures
5.1 Priority Enum

# src/blackboard/enums.py

from enum import IntEnum

class Priority(IntEnum):
    """
    Priority levels for proposals.
    Lower numeric value = higher priority.
    
    Usage:
        CRITICAL - блокирующие действия (rejection, escalation)
        HIGH - важные действия (price questions, objection handling)
        NORMAL - стандартные действия (intent processing, data collection)
        LOW - fallback действия (continue, default transitions)
    """
    CRITICAL = 0  # Highest priority - blocks everything
    HIGH = 1      # High priority - important actions
    NORMAL = 2    # Normal priority - standard processing
    LOW = 3       # Low priority - fallbacks
    
    def __lt__(self, other):
        if isinstance(other, Priority):
            return self.value < other.value
        return NotImplemented
5.1.1 Protocols (Hexagonal Architecture Ports)

# src/blackboard/protocols.py

"""
Protocols defining the contracts (ports) for Blackboard architecture.
Following Hexagonal Architecture pattern from DESIGN_PRINCIPLES.md.

These protocols enable:
- Static type checking with mypy
- Dependency Inversion (depend on abstractions, not concretions)
- Easy mocking in tests
- Clear boundaries between components
"""

from typing import Protocol, Dict, Any, Optional, List, runtime_checkable
from dataclasses import dataclass


@runtime_checkable
class IStateMachine(Protocol):
    """
    Input Port: Contract for state machine implementations.

    Allows DialogueBlackboard to work with any state machine
    that implements this protocol.
    """

    @property
    def state(self) -> str:
        """Get current dialogue state."""
        ...

    @state.setter
    def state(self, value: str) -> None:
        """Set current dialogue state."""
        ...

    @property
    def collected_data(self) -> Dict[str, Any]:
        """Get collected data dictionary."""
        ...

    def is_final(self) -> bool:
        """Check if current state is final."""
        ...


@runtime_checkable
class IIntentTracker(Protocol):
    """
    Input Port: Contract for intent tracking.
    """

    @property
    def turn_number(self) -> int:
        """Get current turn number."""
        ...

    @property
    def prev_intent(self) -> Optional[str]:
        """Get previous intent."""
        ...

    def record(self, intent: str, state: str) -> None:
        """Record an intent."""
        ...

    def objection_consecutive(self) -> int:
        """Get consecutive objection count."""
        ...

    def objection_total(self) -> int:
        """Get total objection count."""
        ...

    def total_count(self, intent: str) -> int:
        """Get total count for specific intent."""
        ...

    def category_total(self, category: str) -> int:
        """Get total count for intent category."""
        ...


@runtime_checkable
class IFlowConfig(Protocol):
    """
    Input Port: Contract for flow configuration.
    """

    @property
    def states(self) -> Dict[str, Dict[str, Any]]:
        """Get states configuration."""
        ...

    def to_dict(self) -> Dict[str, Any]:
        """Convert to dictionary."""
        ...


@runtime_checkable
class IContextEnvelope(Protocol):
    """
    Input Port: Contract for context envelope (Phase 5).
    """

    def to_dict(self) -> Dict[str, Any]:
        """Convert to dictionary."""
        ...


@runtime_checkable
class ITenantConfig(Protocol):
    """
    Input Port: Contract for tenant configuration.

    Supports multi-tenancy as described in DESIGN_PRINCIPLES.md Section 6.
    """

    @property
    def tenant_id(self) -> str:
        """Unique tenant identifier."""
        ...

    @property
    def bot_name(self) -> str:
        """Tenant's bot name."""
        ...

    @property
    def tone(self) -> str:
        """Tenant's preferred tone (professional, friendly, formal)."""
        ...

    @property
    def features(self) -> Dict[str, bool]:
        """Tenant-specific feature flags."""
        ...

    @property
    def persona_limits_override(self) -> Optional[Dict[str, Dict[str, int]]]:
        """Tenant-specific persona limits override."""
        ...


@dataclass
class TenantConfig:
    """
    Default implementation of ITenantConfig.

    Can be loaded from YAML or database per tenant.
    """
    tenant_id: str
    bot_name: str = "Assistant"
    tone: str = "professional"
    features: Dict[str, bool] = None
    persona_limits_override: Optional[Dict[str, Dict[str, int]]] = None

    def __post_init__(self):
        if self.features is None:
            self.features = {}


# Default tenant for single-tenant deployments
DEFAULT_TENANT = TenantConfig(tenant_id="default")

5.2 ProposalType Enum

# src/blackboard/enums.py

from enum import Enum, auto

class ProposalType(Enum):
    """
    Types of proposals that Knowledge Sources can make.
    
    ACTION - предлагает выполнить действие (generate response, handle objection)
    TRANSITION - предлагает перейти в другое состояние
    DATA_UPDATE - предлагает обновить collected_data
    FLAG_SET - предлагает установить флаг (for on_enter actions)
    """
    ACTION = auto()
    TRANSITION = auto()
    DATA_UPDATE = auto()
    FLAG_SET = auto()
5.3 Proposal Dataclass

# src/blackboard/models.py

from dataclasses import dataclass, field
from typing import Any, Optional, List
from datetime import datetime
from .enums import Priority, ProposalType

@dataclass
class Proposal:
    """
    A proposal made by a Knowledge Source.
    
    Attributes:
        type: Type of proposal (ACTION, TRANSITION, DATA_UPDATE, FLAG_SET)
        value: The proposed value (action name, state name, data dict, flag dict)
        priority: Priority level for conflict resolution
        source_name: Name of the Knowledge Source that made this proposal
        reason_code: Documented reason code for auditability
        combinable: Whether this action can coexist with transitions
                    Only applicable for ACTION type.
                    True = action can be merged with transitions
                    False = action blocks all transitions (e.g., rejection)
        metadata: Additional context about the proposal
        created_at: Timestamp when proposal was created
    """
    type: ProposalType
    value: Any
    priority: Priority
    source_name: str
    reason_code: str
    combinable: bool = True  # Default: actions can coexist with transitions
    metadata: dict = field(default_factory=dict)
    created_at: datetime = field(default_factory=datetime.now)
    
    def validate(self) -> List[str]:
        """
        Validate the proposal.
        
        Returns:
            List of validation error messages (empty if valid)
        """
        errors = []
        
        # Check priority is valid
        if not isinstance(self.priority, Priority):
            errors.append(f"Invalid priority: {self.priority}. Must be Priority enum.")
        
        # Check type is valid
        if not isinstance(self.type, ProposalType):
            errors.append(f"Invalid type: {self.type}. Must be ProposalType enum.")
        
        # Check value is not None
        if self.value is None:
            errors.append("Proposal value cannot be None.")
        
        # Check reason_code is not empty
        if not self.reason_code or not self.reason_code.strip():
            errors.append("Proposal must have a non-empty reason_code.")
        
        # Check source_name is not empty
        if not self.source_name or not self.source_name.strip():
            errors.append("Proposal must have a non-empty source_name.")
        
        # Type-specific validation
        if self.type == ProposalType.ACTION:
            if not isinstance(self.value, str):
                errors.append(f"ACTION value must be string, got {type(self.value)}")
        
        elif self.type == ProposalType.TRANSITION:
            if not isinstance(self.value, str):
                errors.append(f"TRANSITION value must be string, got {type(self.value)}")
            # combinable is not applicable for transitions
            if not self.combinable:
                errors.append("TRANSITION proposals cannot have combinable=False")
        
        elif self.type == ProposalType.DATA_UPDATE:
            if not isinstance(self.value, dict):
                errors.append(f"DATA_UPDATE value must be dict, got {type(self.value)}")
        
        elif self.type == ProposalType.FLAG_SET:
            if not isinstance(self.value, dict):
                errors.append(f"FLAG_SET value must be dict, got {type(self.value)}")
        
        return errors
    
    def __repr__(self):
        comb_str = f", combinable={self.combinable}" if self.type == ProposalType.ACTION else ""
        return (f"Proposal({self.type.name}, '{self.value}', {self.priority.name}, "
                f"source='{self.source_name}', reason='{self.reason_code}'{comb_str})")
5.4 ResolvedDecision Dataclass

# src/blackboard/models.py

from dataclasses import dataclass, field
from typing import List, Optional, Dict, Any

@dataclass
class ResolvedDecision:
    """
    The final decision after conflict resolution.
    
    Attributes:
        action: The action to execute (e.g., "answer_with_pricing")
        next_state: The state to transition to (or current state if no transition)
        reason_codes: List of reason codes that contributed to this decision
        rejected_proposals: Proposals that were not selected (for debugging)
        resolution_trace: Detailed trace of the resolution process
        data_updates: Data fields to update in collected_data
        flags_to_set: Flags to set after transition
    """
    action: str
    next_state: str
    reason_codes: List[str] = field(default_factory=list)
    rejected_proposals: List[Proposal] = field(default_factory=list)
    resolution_trace: Dict[str, Any] = field(default_factory=dict)
    data_updates: Dict[str, Any] = field(default_factory=dict)
    flags_to_set: Dict[str, Any] = field(default_factory=dict)
    
    def to_dict(self) -> Dict[str, Any]:
        """Convert to dictionary for serialization/logging."""
        return {
            "action": self.action,
            "next_state": self.next_state,
            "reason_codes": self.reason_codes,
            "rejected_proposals_count": len(self.rejected_proposals),
            "rejected_proposals": [str(p) for p in self.rejected_proposals],
            "resolution_trace": self.resolution_trace,
            "data_updates": self.data_updates,
            "flags_to_set": self.flags_to_set,
        }
    
    def __repr__(self):
        return (f"ResolvedDecision(action='{self.action}', next_state='{self.next_state}', "
                f"reasons={self.reason_codes}, rejected={len(self.rejected_proposals)})")
5.5 ContextSnapshot Dataclass

# src/blackboard/models.py

from dataclasses import dataclass, field
from typing import Dict, Any, Optional, List, TYPE_CHECKING
from src.intent_tracker import IntentTracker
from src.context_envelope import ContextEnvelope

# Import TenantConfig for multi-tenancy support
if TYPE_CHECKING:
    from .protocols import TenantConfig

@dataclass(frozen=True)  # Immutable!
class ContextSnapshot:
    """
    Immutable snapshot of dialogue context for Knowledge Sources.

    This is the read-only view that Knowledge Sources use to make decisions.
    Sources cannot modify this directly - they can only propose changes.

    Attributes:
        state: Current dialogue state (e.g., "spin_situation")
        collected_data: All collected data fields (immutable copy)
        current_intent: The intent of the current user message
        intent_tracker: Reference to IntentTracker (for history queries)
        context_envelope: Full context envelope from Phase 5
        turn_number: Current turn number in the conversation
        persona: Detected user persona (for dynamic limits)
        state_config: Configuration for current state
        flow_config: Configuration for current flow
        tenant_id: Tenant identifier for multi-tenancy support
        tenant_config: Tenant-specific configuration (feature flags, limits)
    """
    state: str
    collected_data: Dict[str, Any]
    current_intent: str
    intent_tracker: IntentTracker
    context_envelope: Optional[ContextEnvelope]
    turn_number: int
    persona: str
    state_config: Dict[str, Any]
    flow_config: Dict[str, Any]
    # Multi-tenancy support (DESIGN_PRINCIPLES.md Section 6)
    tenant_id: str = "default"
    tenant_config: Optional['TenantConfig'] = None
    
    # Computed properties for convenience
    @property
    def last_intent(self) -> Optional[str]:
        """Get the previous intent (before current)."""
        return self.intent_tracker.prev_intent
    
    @property
    def objection_consecutive(self) -> int:
        """Get consecutive objection count."""
        return self.intent_tracker.objection_consecutive()
    
    @property
    def objection_total(self) -> int:
        """Get total objection count."""
        return self.intent_tracker.objection_total()
    
    @property
    def required_data(self) -> List[str]:
        """Get required data fields for current state."""
        return self.state_config.get("required_data", [])
    
    @property
    def optional_data(self) -> List[str]:
        """Get optional data fields for current state."""
        return self.state_config.get("optional_data", [])
    
    @property
    def current_phase(self) -> Optional[str]:
        """Get current SPIN phase."""
        return self.state_config.get("phase")
    
    def get_missing_required_data(self) -> List[str]:
        """Get list of required fields that are not yet collected."""
        return [
            field for field in self.required_data 
            if not self.collected_data.get(field)
        ]
    
    def has_all_required_data(self) -> bool:
        """Check if all required data has been collected."""
        return len(self.get_missing_required_data()) == 0
    
    def get_transition(self, trigger: str) -> Optional[str]:
        """Get transition target for a trigger."""
        transitions = self.state_config.get("transitions", {})
        return transitions.get(trigger)
    
    def get_rule(self, intent: str) -> Optional[Any]:
        """Get rule for an intent in current state."""
        rules = self.state_config.get("rules", {})
        return rules.get(intent)

    def get_persona_limit(self, persona: str, limit_type: str) -> Optional[int]:
        """
        Get persona-specific limit with tenant override support.

        Multi-tenancy: Tenant config can override global persona limits.

        Args:
            persona: Persona name (e.g., "aggressive", "busy")
            limit_type: Limit type ("consecutive" or "total")

        Returns:
            Limit value or None if not configured
        """
        # Check tenant override first
        if self.tenant_config and self.tenant_config.persona_limits_override:
            tenant_limits = self.tenant_config.persona_limits_override.get(persona, {})
            if limit_type in tenant_limits:
                return tenant_limits[limit_type]

        # Fall back to global config (passed via flow_config.constants)
        global_limits = self.flow_config.get("persona_limits", {}).get(persona, {})
        return global_limits.get(limit_type)

    def is_tenant_feature_enabled(self, feature_name: str) -> bool:
        """
        Check if a feature is enabled for current tenant.

        Args:
            feature_name: Feature flag name

        Returns:
            True if feature is enabled, False otherwise
        """
        if self.tenant_config and self.tenant_config.features:
            return self.tenant_config.features.get(feature_name, True)
        return True  # Default: all features enabled

6. DialogueBlackboard

# src/blackboard/blackboard.py

from dataclasses import dataclass, field
from typing import Dict, Any, Optional, List, TYPE_CHECKING
from datetime import datetime
import logging

from .models import Proposal, ResolvedDecision, ContextSnapshot
from .enums import Priority, ProposalType
from .protocols import (
    IStateMachine,
    IIntentTracker,
    IFlowConfig,
    TenantConfig,
    DEFAULT_TENANT,
)
from src.intent_tracker import IntentTracker
from src.context_envelope import ContextEnvelope
from src.config_loader import FlowConfig

logger = logging.getLogger(__name__)


class DialogueBlackboard:
    """
    Central shared workspace for dialogue management.

    Implements the Blackboard architectural pattern with three layers:
    1. Context Layer (read-only) - current dialogue state
    2. Proposal Layer (write by sources) - proposed actions/transitions
    3. Decision Layer (write by resolver) - final resolved decision

    Hexagonal Architecture:
        DialogueBlackboard depends on protocols (IStateMachine, IIntentTracker, IFlowConfig)
        rather than concrete implementations. This allows easy testing and swapping
        implementations without changing Blackboard code.

    Multi-Tenancy:
        Supports tenant-specific configuration via TenantConfig. Each tenant can have
        custom persona limits, feature flags, and other settings.

    Usage:
        bb = DialogueBlackboard(state_machine, flow_config)
        bb.begin_turn(intent, extracted_data, context_envelope)

        # Knowledge Sources contribute
        source.contribute(bb)

        # Get context snapshot (read-only)
        ctx = bb.get_context()

        # Propose changes
        bb.propose_action("answer_with_pricing", Priority.HIGH, combinable=True)
        bb.propose_transition("spin_problem", Priority.NORMAL)

        # Resolve and commit
        decision = resolver.resolve(bb.get_proposals())
        bb.commit_decision(decision)
    """

    def __init__(
        self,
        state_machine: 'IStateMachine',  # Protocol type for Hexagonal Architecture
        flow_config: 'IFlowConfig',
        intent_tracker: Optional['IIntentTracker'] = None,
        tenant_config: Optional['TenantConfig'] = None  # Multi-tenancy support
    ):
        """
        Initialize the blackboard.

        Args:
            state_machine: State machine implementing IStateMachine protocol
            flow_config: Flow configuration implementing IFlowConfig protocol
            intent_tracker: Intent tracker implementing IIntentTracker protocol
                           (uses state_machine's if not provided)
            tenant_config: Tenant-specific configuration (optional, uses DEFAULT_TENANT if not provided)
        """
        self._state_machine = state_machine
        self._flow_config = flow_config
        self._intent_tracker = intent_tracker or state_machine._intent_tracker
        self._tenant_config = tenant_config or DEFAULT_TENANT

        # === Context Layer (populated on begin_turn) ===
        self._context: Optional[ContextSnapshot] = None

        # === Proposal Layer ===
        self._action_proposals: List[Proposal] = []
        self._transition_proposals: List[Proposal] = []
        self._data_updates: Dict[str, Any] = {}
        self._flags_to_set: Dict[str, Any] = {}

        # === Decision Layer ===
        self._decision: Optional[ResolvedDecision] = None

        # === Metadata ===
        self._turn_start_time: Optional[datetime] = None
        self._current_intent: Optional[str] = None

    @property
    def tenant_id(self) -> str:
        """Get current tenant ID."""
        return self._tenant_config.tenant_id

    @property
    def tenant_config(self) -> 'TenantConfig':
        """Get current tenant configuration."""
        return self._tenant_config
        
    # =========================================================================
    # CONTEXT LAYER (Read-Only)
    # =========================================================================
    
    def begin_turn(
        self,
        intent: str,
        extracted_data: Dict[str, Any],
        context_envelope: Optional[ContextEnvelope] = None
    ) -> None:
        """
        Begin a new dialogue turn.
        
        This method:
        1. Records the intent in IntentTracker
        2. Updates collected_data with extracted_data
        3. Creates an immutable ContextSnapshot
        4. Clears previous proposals and decision
        
        Args:
            intent: Classified intent for this turn
            extracted_data: Data extracted from user message
            context_envelope: Full context envelope (Phase 5)
        """
        self._turn_start_time = datetime.now()
        self._current_intent = intent
        
        # Record intent in tracker (MUST happen first, before condition evaluation)
        self._intent_tracker.record(intent, self._state_machine.state)
        
        # Update collected_data with newly extracted data
        current_collected = dict(self._state_machine.collected_data)
        for key, value in extracted_data.items():
            if value is not None and value != "":
                current_collected[key] = value
        
        # Get current state configuration
        state_config = self._flow_config.states.get(
            self._state_machine.state, {}
        )
        
        # Detect persona from collected data
        persona = current_collected.get("persona", "default")
        
        # Create immutable context snapshot
        self._context = ContextSnapshot(
            state=self._state_machine.state,
            collected_data=current_collected,
            current_intent=intent,
            intent_tracker=self._intent_tracker,
            context_envelope=context_envelope,
            turn_number=self._intent_tracker.turn_number,
            persona=persona,
            state_config=state_config,
            flow_config=self._flow_config.to_dict() if hasattr(self._flow_config, 'to_dict') else {},
            # Multi-tenancy support
            tenant_id=self._tenant_config.tenant_id,
            tenant_config=self._tenant_config,
        )
        
        # Clear proposal layer
        self._action_proposals.clear()
        self._transition_proposals.clear()
        self._data_updates.clear()
        self._flags_to_set.clear()
        
        # Clear decision layer
        self._decision = None
        
        logger.debug(
            f"Blackboard turn started: intent={intent}, state={self._state_machine.state}, "
            f"turn={self._intent_tracker.turn_number}"
        )
    
    def get_context(self) -> ContextSnapshot:
        """
        Get the immutable context snapshot.
        
        This is the primary way Knowledge Sources access dialogue state.
        The snapshot is read-only - sources cannot modify it directly.
        
        Returns:
            ContextSnapshot with current dialogue state
            
        Raises:
            RuntimeError: If called before begin_turn()
        """
        if self._context is None:
            raise RuntimeError("Blackboard.get_context() called before begin_turn()")
        return self._context
    
    @property
    def current_intent(self) -> str:
        """Get the current turn's intent."""
        if self._current_intent is None:
            raise RuntimeError("Blackboard accessed before begin_turn()")
        return self._current_intent
    
    @property
    def current_state(self) -> str:
        """Get the current dialogue state."""
        return self._state_machine.state
    
    @property
    def collected_data(self) -> Dict[str, Any]:
        """Get collected data (from context snapshot)."""
        return self._context.collected_data if self._context else {}
    
    # =========================================================================
    # PROPOSAL LAYER (Write by Sources)
    # =========================================================================
    
    def propose_action(
        self,
        action: str,
        priority: Priority = Priority.NORMAL,
        combinable: bool = True,
        reason_code: str = "",
        source_name: str = "unknown",
        metadata: Optional[Dict[str, Any]] = None
    ) -> None:
        """
        Propose an action to be executed.
        
        Args:
            action: Name of the action (e.g., "answer_with_pricing")
            priority: Priority level (CRITICAL, HIGH, NORMAL, LOW)
            combinable: If True, this action can coexist with transitions.
                        If False, this action blocks all transitions.
            reason_code: Documented reason for this proposal
            source_name: Name of the Knowledge Source making this proposal
            metadata: Additional context about the proposal
        """
        proposal = Proposal(
            type=ProposalType.ACTION,
            value=action,
            priority=priority,
            source_name=source_name,
            reason_code=reason_code or f"action_{action}",
            combinable=combinable,
            metadata=metadata or {},
        )
        
        self._action_proposals.append(proposal)
        
        logger.debug(
            f"Action proposed: {action} (priority={priority.name}, "
            f"combinable={combinable}, source={source_name})"
        )
    
    def propose_transition(
        self,
        next_state: str,
        priority: Priority = Priority.NORMAL,
        reason_code: str = "",
        source_name: str = "unknown",
        metadata: Optional[Dict[str, Any]] = None
    ) -> None:
        """
        Propose a state transition.
        
        Args:
            next_state: Target state name (e.g., "spin_problem")
            priority: Priority level (CRITICAL, HIGH, NORMAL, LOW)
            reason_code: Documented reason for this proposal
            source_name: Name of the Knowledge Source making this proposal
            metadata: Additional context about the proposal
        """
        proposal = Proposal(
            type=ProposalType.TRANSITION,
            value=next_state,
            priority=priority,
            source_name=source_name,
            reason_code=reason_code or f"transition_to_{next_state}",
            combinable=True,  # Transitions are always combinable
            metadata=metadata or {},
        )
        
        self._transition_proposals.append(proposal)
        
        logger.debug(
            f"Transition proposed: {next_state} (priority={priority.name}, "
            f"source={source_name})"
        )
    
    def propose_data_update(
        self,
        field: str,
        value: Any,
        source_name: str = "unknown",
        reason_code: str = ""
    ) -> None:
        """
        Propose a data field update.
        
        Args:
            field: Field name to update
            value: New value for the field
            source_name: Name of the Knowledge Source making this proposal
            reason_code: Documented reason for this proposal
        """
        self._data_updates[field] = value
        
        logger.debug(
            f"Data update proposed: {field}={value} (source={source_name})"
        )
    
    def propose_flag_set(
        self,
        flag: str,
        value: Any,
        source_name: str = "unknown",
        reason_code: str = ""
    ) -> None:
        """
        Propose setting a flag.
        
        Args:
            flag: Flag name to set
            value: Value to set
            source_name: Name of the Knowledge Source making this proposal
            reason_code: Documented reason for this proposal
        """
        self._flags_to_set[flag] = value
        
        logger.debug(
            f"Flag set proposed: {flag}={value} (source={source_name})"
        )
    
    def get_proposals(self) -> List[Proposal]:
        """
        Get all proposals (actions + transitions).
        
        Returns:
            Combined list of all proposals
        """
        return self._action_proposals + self._transition_proposals
    
    def get_action_proposals(self) -> List[Proposal]:
        """Get only action proposals."""
        return list(self._action_proposals)
    
    def get_transition_proposals(self) -> List[Proposal]:
        """Get only transition proposals."""
        return list(self._transition_proposals)
    
    def get_data_updates(self) -> Dict[str, Any]:
        """Get proposed data updates."""
        return dict(self._data_updates)
    
    def get_flags_to_set(self) -> Dict[str, Any]:
        """Get proposed flags to set."""
        return dict(self._flags_to_set)
    
    # =========================================================================
    # DECISION LAYER (Write by Resolver)
    # =========================================================================
    
    def commit_decision(self, decision: ResolvedDecision) -> None:
        """
        Commit the resolved decision.
        
        This method:
        1. Stores the decision in the decision layer
        2. Applies data updates to state machine
        3. Applies flags to state machine
        
        Note: State transition is NOT applied here - it's done by the caller
        (SalesBot) to maintain compatibility with existing code.
        
        Args:
            decision: The resolved decision from ConflictResolver
        """
        self._decision = decision
        
        # Apply data updates
        for field, value in decision.data_updates.items():
            self._state_machine.collected_data[field] = value
        
        # Apply any additional data updates from proposals
        for field, value in self._data_updates.items():
            self._state_machine.collected_data[field] = value
        
        # Store flags (applied on state entry)
        for flag, value in decision.flags_to_set.items():
            self._flags_to_set[flag] = value
        
        logger.info(
            f"Decision committed: action={decision.action}, "
            f"next_state={decision.next_state}, "
            f"reasons={decision.reason_codes}"
        )
    
    def get_decision(self) -> Optional[ResolvedDecision]:
        """
        Get the committed decision.
        
        Returns:
            ResolvedDecision if committed, None otherwise
        """
        return self._decision
    
    # =========================================================================
    # UTILITY METHODS
    # =========================================================================
    
    def get_turn_summary(self) -> Dict[str, Any]:
        """
        Get a summary of the current turn for logging/debugging.
        
        Returns:
            Dictionary with turn summary
        """
        return {
            "turn_number": self._intent_tracker.turn_number,
            "intent": self._current_intent,
            "state": self._state_machine.state,
            "action_proposals_count": len(self._action_proposals),
            "transition_proposals_count": len(self._transition_proposals),
            "action_proposals": [str(p) for p in self._action_proposals],
            "transition_proposals": [str(p) for p in self._transition_proposals],
            "data_updates": self._data_updates,
            "decision": self._decision.to_dict() if self._decision else None,
            "turn_duration_ms": (
                (datetime.now() - self._turn_start_time).total_seconds() * 1000
                if self._turn_start_time else None
            ),
        }
7. Knowledge Source Base Class

# src/blackboard/knowledge_source.py

from abc import ABC, abstractmethod
from typing import Optional, List, Dict, Any
import logging

from .blackboard import DialogueBlackboard
from .models import ContextSnapshot

logger = logging.getLogger(__name__)


class KnowledgeSource(ABC):
    """
    Abstract base class for Knowledge Sources.
    
    Knowledge Sources are independent modules that contribute proposals
    to the Blackboard. Each source has a specific responsibility and
    should not know about other sources.
    
    Lifecycle:
        1. should_contribute(bb) - Quick check if source should run
        2. contribute(bb) - Make proposals to the blackboard
    
    Guidelines for implementing Knowledge Sources:
        - Single Responsibility: Each source should have ONE clear purpose
        - No Side Effects: Sources should only propose, never modify state directly
        - Idempotent: Multiple calls with same context should produce same proposals
        - Fast: should_contribute() must be O(1), contribute() should be efficient
    """
    
    def __init__(self, name: Optional[str] = None):
        """
        Initialize the knowledge source.
        
        Args:
            name: Optional name for the source (defaults to class name)
        """
        self._name = name or self.__class__.__name__
        self._enabled = True
    
    @property
    def name(self) -> str:
        """Get the source name."""
        return self._name
    
    @property
    def enabled(self) -> bool:
        """Check if source is enabled."""
        return self._enabled
    
    def enable(self) -> None:
        """Enable the source."""
        self._enabled = True
    
    def disable(self) -> None:
        """Disable the source."""
        self._enabled = False
    
    def should_contribute(self, blackboard: DialogueBlackboard) -> bool:
        """
        Quick check whether this source should contribute.
        
        This method is called before contribute() and should be FAST (O(1)).
        Use it to avoid expensive computation when the source is not relevant.
        
        Default implementation returns True (always contribute).
        Override this method for performance optimization.
        
        Args:
            blackboard: The dialogue blackboard
            
        Returns:
            True if contribute() should be called, False to skip
        """
        return self._enabled
    
    @abstractmethod
    def contribute(self, blackboard: DialogueBlackboard) -> None:
        """
        Contribute proposals to the blackboard.
        
        This method should:
        1. Read context from blackboard.get_context()
        2. Evaluate conditions based on context
        3. Call blackboard.propose_action() / propose_transition() as needed
        
        Args:
            blackboard: The dialogue blackboard to contribute to
        """
        pass
    
    def _log_contribution(
        self,
        action: Optional[str] = None,
        transition: Optional[str] = None,
        reason: str = ""
    ) -> None:
        """Helper to log contributions."""
        if action:
            logger.debug(f"[{self._name}] Proposing action: {action} ({reason})")
        if transition:
            logger.debug(f"[{self._name}] Proposing transition: {transition} ({reason})")
        if not action and not transition:
            logger.debug(f"[{self._name}] No proposals ({reason})")
7.1 SourceRegistry (Plugin System)

# src/blackboard/source_registry.py

from typing import Dict, Type, List, Optional, Any, Callable
from dataclasses import dataclass, field
import logging

from .knowledge_source import KnowledgeSource

logger = logging.getLogger(__name__)


@dataclass
class SourceRegistration:
    """
    Registration entry for a Knowledge Source.

    Attributes:
        source_class: The KnowledgeSource class (not instance)
        name: Unique name for this source
        priority_order: Order in which sources are called (lower = earlier)
        enabled_by_default: Whether source is enabled by default
        config_key: Key in constants.yaml for source-specific config
        description: Human-readable description
    """
    source_class: Type[KnowledgeSource]
    name: str
    priority_order: int = 100
    enabled_by_default: bool = True
    config_key: Optional[str] = None
    description: str = ""

    def __post_init__(self):
        if not self.name:
            self.name = self.source_class.__name__


class SourceRegistry:
    """
    Registry for Knowledge Sources following Plugin Architecture pattern.

    This registry allows:
        - Dynamic registration of Knowledge Sources
        - Configuration-driven enabling/disabling of sources
        - Ordered instantiation of sources
        - Runtime addition of custom sources

    Usage:
        # Register built-in sources (typically in sources/__init__.py)
        SourceRegistry.register(
            PriceQuestionSource,
            name="PriceQuestionSource",
            priority_order=10,
            config_key="price_question"
        )

        # Get all enabled source instances
        sources = SourceRegistry.create_sources(config)

        # Register custom source at runtime
        SourceRegistry.register(MyCustomSource, priority_order=50)

    Design Principles:
        - Open/Closed: New sources can be added without modifying existing code
        - Configuration-driven: Sources can be enabled/disabled via YAML
        - Deterministic: Sources are always instantiated in priority_order
    """

    _registry: Dict[str, SourceRegistration] = {}
    _frozen: bool = False

    @classmethod
    def register(
        cls,
        source_class: Type[KnowledgeSource],
        name: Optional[str] = None,
        priority_order: int = 100,
        enabled_by_default: bool = True,
        config_key: Optional[str] = None,
        description: str = "",
    ) -> None:
        """
        Register a Knowledge Source class.

        Args:
            source_class: The KnowledgeSource class to register
            name: Unique name (defaults to class name)
            priority_order: Execution order (lower = earlier)
            enabled_by_default: Whether enabled when not in config
            config_key: Key in constants.yaml for source config
            description: Human-readable description

        Raises:
            ValueError: If name is already registered
            TypeError: If source_class is not a KnowledgeSource subclass
        """
        if not issubclass(source_class, KnowledgeSource):
            raise TypeError(
                f"{source_class} must be a subclass of KnowledgeSource"
            )

        registration_name = name or source_class.__name__

        if registration_name in cls._registry and cls._frozen:
            raise ValueError(
                f"Source '{registration_name}' is already registered and registry is frozen"
            )

        cls._registry[registration_name] = SourceRegistration(
            source_class=source_class,
            name=registration_name,
            priority_order=priority_order,
            enabled_by_default=enabled_by_default,
            config_key=config_key,
            description=description,
        )

        logger.debug(f"Registered Knowledge Source: {registration_name} (order={priority_order})")

    @classmethod
    def unregister(cls, name: str) -> bool:
        """
        Unregister a Knowledge Source.

        Args:
            name: Name of the source to unregister

        Returns:
            True if source was unregistered, False if not found
        """
        if cls._frozen:
            raise RuntimeError("Cannot unregister from frozen registry")

        if name in cls._registry:
            del cls._registry[name]
            logger.debug(f"Unregistered Knowledge Source: {name}")
            return True
        return False

    @classmethod
    def get_registration(cls, name: str) -> Optional[SourceRegistration]:
        """Get registration info for a source."""
        return cls._registry.get(name)

    @classmethod
    def list_registered(cls) -> List[str]:
        """List all registered source names in priority order."""
        sorted_regs = sorted(
            cls._registry.values(),
            key=lambda r: r.priority_order
        )
        return [r.name for r in sorted_regs]

    @classmethod
    def create_sources(
        cls,
        config: Optional[Dict[str, Any]] = None,
        source_configs: Optional[Dict[str, Dict[str, Any]]] = None,
    ) -> List[KnowledgeSource]:
        """
        Create instances of all enabled Knowledge Sources.

        Args:
            config: Global config dict (checks 'sources.{name}.enabled')
            source_configs: Per-source configuration dicts

        Returns:
            List of KnowledgeSource instances in priority order
        """
        config = config or {}
        source_configs = source_configs or {}

        # Get sources config section
        sources_config = config.get("sources", {})

        # Sort registrations by priority
        sorted_regs = sorted(
            cls._registry.values(),
            key=lambda r: r.priority_order
        )

        sources: List[KnowledgeSource] = []

        for reg in sorted_regs:
            # Check if enabled
            source_cfg = sources_config.get(reg.name, {})
            is_enabled = source_cfg.get("enabled", reg.enabled_by_default)

            if not is_enabled:
                logger.debug(f"Source {reg.name} is disabled by config")
                continue

            # Get source-specific config
            init_kwargs = source_configs.get(reg.name, {})
            init_kwargs["name"] = reg.name

            # Create instance
            try:
                source = reg.source_class(**init_kwargs)
                sources.append(source)
                logger.debug(f"Created source instance: {reg.name}")
            except Exception as e:
                logger.error(f"Failed to create source {reg.name}: {e}")
                raise

        logger.info(f"Created {len(sources)} Knowledge Sources")
        return sources

    @classmethod
    def freeze(cls) -> None:
        """Freeze registry to prevent further modifications."""
        cls._frozen = True
        logger.info("SourceRegistry frozen")

    @classmethod
    def reset(cls) -> None:
        """Reset registry (mainly for testing)."""
        cls._registry.clear()
        cls._frozen = False
        logger.debug("SourceRegistry reset")


# === Decorator for easy registration ===

def register_source(
    name: Optional[str] = None,
    priority_order: int = 100,
    enabled_by_default: bool = True,
    config_key: Optional[str] = None,
    description: str = "",
) -> Callable[[Type[KnowledgeSource]], Type[KnowledgeSource]]:
    """
    Decorator to register a Knowledge Source class.

    Usage:
        @register_source(priority_order=10, description="Handles price questions")
        class PriceQuestionSource(KnowledgeSource):
            ...
    """
    def decorator(cls: Type[KnowledgeSource]) -> Type[KnowledgeSource]:
        SourceRegistry.register(
            source_class=cls,
            name=name,
            priority_order=priority_order,
            enabled_by_default=enabled_by_default,
            config_key=config_key,
            description=description,
        )
        return cls
    return decorator


# === Built-in sources registration ===
# This is called when the module is imported

def register_builtin_sources() -> None:
    """
    Register all built-in Knowledge Sources.

    Called automatically when blackboard module is imported.
    Sources are registered in recommended execution order.
    """
    from .sources.price_question import PriceQuestionSource
    from .sources.data_collector import DataCollectorSource
    from .sources.objection_guard import ObjectionGuardSource
    from .sources.intent_processor import IntentProcessorSource
    from .sources.transition_resolver import TransitionResolverSource
    from .sources.escalation import EscalationSource

    # Register in recommended order (lower priority_order = earlier execution)
    SourceRegistry.register(
        PriceQuestionSource,
        name="PriceQuestionSource",
        priority_order=10,
        config_key="price_question",
        description="Handles price-related questions with combinable actions"
    )

    SourceRegistry.register(
        DataCollectorSource,
        name="DataCollectorSource",
        priority_order=20,
        config_key="data_collector",
        description="Tracks data completeness and proposes transitions"
    )

    SourceRegistry.register(
        ObjectionGuardSource,
        name="ObjectionGuardSource",
        priority_order=30,
        config_key="objection_guard",
        description="Monitors objection limits per persona"
    )

    SourceRegistry.register(
        IntentProcessorSource,
        name="IntentProcessorSource",
        priority_order=40,
        config_key="intent_processor",
        description="Maps intents to actions via rules"
    )

    SourceRegistry.register(
        TransitionResolverSource,
        name="TransitionResolverSource",
        priority_order=50,
        config_key="transition_resolver",
        description="Handles intent-based state transitions"
    )

    SourceRegistry.register(
        EscalationSource,
        name="EscalationSource",
        priority_order=60,
        config_key="escalation",
        description="Detects escalation triggers for human handoff"
    )

    logger.info(f"Registered {len(SourceRegistry.list_registered())} built-in sources")

Продолжаю с четвёртой частью — Реализация Knowledge Sources.

продолжай
Часть 4: Реализация Knowledge Sources
8. Knowledge Sources Implementation
8.1 PriceQuestionSource

# src/blackboard/sources/price_question.py

from typing import Set, Optional
import logging

from ..knowledge_source import KnowledgeSource
from ..blackboard import DialogueBlackboard
from ..enums import Priority

logger = logging.getLogger(__name__)


class PriceQuestionSource(KnowledgeSource):
    """
    Knowledge Source for handling price-related questions.
    
    Responsibility:
        - Detect price-related intents
        - Propose "answer_with_pricing" action
        - Always combinable=True (allows state transitions to proceed)
    
    Intents handled:
        - price_question
        - pricing_details
        - cost_inquiry
        - discount_request
        - payment_terms
    
    This source addresses the core problem: price questions should be answered
    WITHOUT blocking data_complete transitions.
    """
    
    # Default price-related intents (can be overridden from config)
    DEFAULT_PRICE_INTENTS: Set[str] = {
        "price_question",
        "pricing_details", 
        "cost_inquiry",
        "discount_request",
        "payment_terms",
        "pricing_comparison",
        "budget_question",
    }
    
    def __init__(
        self,
        price_intents: Optional[Set[str]] = None,
        name: str = "PriceQuestionSource"
    ):
        """
        Initialize the price question source.
        
        Args:
            price_intents: Set of intents considered price-related.
                           Defaults to DEFAULT_PRICE_INTENTS.
            name: Source name for logging
        """
        super().__init__(name)
        self._price_intents = price_intents or self.DEFAULT_PRICE_INTENTS
    
    def should_contribute(self, blackboard: DialogueBlackboard) -> bool:
        """
        Quick check: is current intent price-related?
        
        O(1) check against price intents set.
        """
        if not self._enabled:
            return False
        
        return blackboard.current_intent in self._price_intents
    
    def contribute(self, blackboard: DialogueBlackboard) -> None:
        """
        Propose answer_with_pricing action for price questions.
        
        Key design decision: combinable=True
        This allows the action to coexist with transitions (e.g., data_complete).
        The bot will answer the price question AND transition to the next phase.
        """
        ctx = blackboard.get_context()
        intent = ctx.current_intent
        
        if intent not in self._price_intents:
            self._log_contribution(reason="Intent not price-related")
            return
        
        # Determine specific action based on intent
        if intent == "discount_request":
            action = "handle_discount_request"
        elif intent == "payment_terms":
            action = "explain_payment_terms"
        else:
            action = "answer_with_pricing"
        
        # Check if we have pricing data available
        has_pricing = bool(ctx.collected_data.get("pricing_tier"))
        
        # Propose action with HIGH priority (but combinable!)
        blackboard.propose_action(
            action=action,
            priority=Priority.HIGH,
            combinable=True,  # KEY: Allows coexistence with transitions
            reason_code="price_question_priority",
            source_name=self.name,
            metadata={
                "original_intent": intent,
                "has_pricing_data": has_pricing,
            }
        )
        
        self._log_contribution(
            action=action,
            reason=f"Price intent detected: {intent}"
        )
8.2 DataCollectorSource

# src/blackboard/sources/data_collector.py

from typing import List, Optional, Dict, Any
import logging

from ..knowledge_source import KnowledgeSource
from ..blackboard import DialogueBlackboard
from ..enums import Priority

logger = logging.getLogger(__name__)


class DataCollectorSource(KnowledgeSource):
    """
    Knowledge Source for monitoring data collection progress.
    
    Responsibility:
        - Check if required data for current state is complete
        - Propose data_complete transition when all required data is collected
        - DOES NOT handle intent-based transitions (that's TransitionResolverSource)
    
    This is a critical source that ensures automatic phase progression
    when users provide required information (even in combination with other intents).
    
    Clear boundary with TransitionResolverSource:
        - DataCollectorSource: data_complete transitions ONLY
        - TransitionResolverSource: intent-based transitions ONLY
    """
    
    def __init__(self, name: str = "DataCollectorSource"):
        """
        Initialize the data collector source.
        
        Args:
            name: Source name for logging
        """
        super().__init__(name)
    
    def should_contribute(self, blackboard: DialogueBlackboard) -> bool:
        """
        Quick check: does current state have required_data?
        
        Skip if:
        - Source is disabled
        - State has no required_data defined
        - State is final
        """
        if not self._enabled:
            return False
        
        ctx = blackboard.get_context()
        
        # Skip if state is final
        if ctx.state_config.get("is_final", False):
            return False
        
        # Skip if no required_data defined
        required = ctx.state_config.get("required_data", [])
        if not required:
            return False
        
        return True
    
    def contribute(self, blackboard: DialogueBlackboard) -> None:
        """
        Check data completeness and propose transition if complete.
        
        Algorithm:
        1. Get required_data from state config
        2. Check each field in collected_data
        3. If all required fields present -> propose data_complete transition
        """
        ctx = blackboard.get_context()
        
        required_fields = ctx.required_data
        collected = ctx.collected_data
        
        # Find missing fields
        missing_fields = []
        for field in required_fields:
            value = collected.get(field)
            if value is None or value == "" or value == []:
                missing_fields.append(field)
        
        if missing_fields:
            # Not all data collected yet
            self._log_contribution(
                reason=f"Missing required data: {missing_fields}"
            )
            return
        
        # All required data is present!
        # Check if there's a data_complete transition defined
        data_complete_target = ctx.get_transition("data_complete")
        
        if not data_complete_target:
            # No data_complete transition defined for this state
            self._log_contribution(
                reason="Data complete but no transition defined"
            )
            return
        
        # Propose the transition
        blackboard.propose_transition(
            next_state=data_complete_target,
            priority=Priority.NORMAL,
            reason_code="data_complete",
            source_name=self.name,
            metadata={
                "required_fields": required_fields,
                "collected_fields": list(collected.keys()),
            }
        )
        
        self._log_contribution(
            transition=data_complete_target,
            reason=f"All required data collected: {required_fields}"
        )
8.3 ObjectionGuardSource

# src/blackboard/sources/objection_guard.py

from typing import Dict, Optional, Set
import logging

from ..knowledge_source import KnowledgeSource
from ..blackboard import DialogueBlackboard
from ..enums import Priority

logger = logging.getLogger(__name__)


class ObjectionGuardSource(KnowledgeSource):
    """
    Knowledge Source for monitoring objection limits per persona.
    
    Responsibility:
        - Track consecutive and total objections
        - Apply persona-specific limits
        - Propose soft_close transition when limits exceeded
        - Propose objection_limit_reached action for appropriate messaging
    
    Persona limits (from constants.yaml):
        aggressive:      consecutive=5, total=8
        price_sensitive: consecutive=4, total=7
        skeptical:       consecutive=4, total=6
        busy:            consecutive=2, total=4
        default:         consecutive=3, total=5
    
    Design decision: When limit is reached, we propose BLOCKING action
    (combinable=False) because we want to stop normal processing and
    redirect to soft close.
    """
    
    # Default persona limits (loaded from constants.yaml in production)
    DEFAULT_PERSONA_LIMITS: Dict[str, Dict[str, int]] = {
        "aggressive": {"consecutive": 5, "total": 8},
        "price_sensitive": {"consecutive": 4, "total": 7},
        "skeptical": {"consecutive": 4, "total": 6},
        "busy": {"consecutive": 2, "total": 4},
        "analytical": {"consecutive": 4, "total": 6},
        "friendly": {"consecutive": 4, "total": 7},
        "default": {"consecutive": 3, "total": 5},
    }
    
    # Intents considered as objections
    DEFAULT_OBJECTION_INTENTS: Set[str] = {
        "objection_price",
        "objection_competitor", 
        "objection_timing",
        "objection_authority",
        "objection_need",
        "objection_trust",
        "objection_budget",
        "objection_features",
        "objection_complexity",
        "objection_support",
        "objection_integration",
        "objection_security",
        "objection_scalability",
        "objection_contract",
        "objection_implementation",
        "objection_training",
        "objection_roi",
        "objection_change",
        "objection_generic",
    }
    
    def __init__(
        self,
        persona_limits: Optional[Dict[str, Dict[str, int]]] = None,
        objection_intents: Optional[Set[str]] = None,
        name: str = "ObjectionGuardSource"
    ):
        """
        Initialize the objection guard source.
        
        Args:
            persona_limits: Dict mapping persona -> {consecutive, total} limits.
                           Defaults to DEFAULT_PERSONA_LIMITS.
            objection_intents: Set of intents considered as objections.
                              Defaults to DEFAULT_OBJECTION_INTENTS.
            name: Source name for logging
        """
        super().__init__(name)
        self._persona_limits = persona_limits or self.DEFAULT_PERSONA_LIMITS
        self._objection_intents = objection_intents or self.DEFAULT_OBJECTION_INTENTS
    
    def should_contribute(self, blackboard: DialogueBlackboard) -> bool:
        """
        Quick check: is current intent an objection?
        
        We only need to check limits when an objection is detected.
        """
        if not self._enabled:
            return False
        
        return blackboard.current_intent in self._objection_intents
    
    def contribute(self, blackboard: DialogueBlackboard) -> None:
        """
        Check objection limits and propose soft_close if exceeded.
        
        Algorithm:
        1. Get persona from collected_data (default: "default")
        2. Get limits for persona
        3. Get consecutive and total objection counts from IntentTracker
        4. If either limit exceeded -> propose blocking action + transition
        """
        ctx = blackboard.get_context()
        
        # Get persona (default if not detected)
        persona = ctx.persona
        if persona not in self._persona_limits:
            persona = "default"
        
        limits = self._persona_limits[persona]
        max_consecutive = limits["consecutive"]
        max_total = limits["total"]
        
        # Get objection counts from IntentTracker
        consecutive = ctx.objection_consecutive
        total = ctx.objection_total
        
        # Check if limits exceeded
        consecutive_exceeded = consecutive >= max_consecutive
        total_exceeded = total >= max_total
        
        if not consecutive_exceeded and not total_exceeded:
            # Within limits - let other sources handle the objection
            self._log_contribution(
                reason=f"Within limits: consecutive={consecutive}/{max_consecutive}, "
                       f"total={total}/{max_total} (persona={persona})"
            )
            return
        
        # Limits exceeded - propose blocking action and transition
        exceeded_reason = []
        if consecutive_exceeded:
            exceeded_reason.append(f"consecutive={consecutive}>={max_consecutive}")
        if total_exceeded:
            exceeded_reason.append(f"total={total}>={max_total}")
        
        reason_str = ", ".join(exceeded_reason)
        
        # Propose BLOCKING action (combinable=False)
        # This prevents any other actions from being merged
        blackboard.propose_action(
            action="objection_limit_reached",
            priority=Priority.HIGH,
            combinable=False,  # BLOCKING: prevents other actions
            reason_code="objection_limit_exceeded",
            source_name=self.name,
            metadata={
                "persona": persona,
                "consecutive": consecutive,
                "total": total,
                "max_consecutive": max_consecutive,
                "max_total": max_total,
                "exceeded": exceeded_reason,
            }
        )
        
        # Propose transition to soft_close
        blackboard.propose_transition(
            next_state="soft_close",
            priority=Priority.HIGH,
            reason_code="objection_limit_exceeded",
            source_name=self.name,
            metadata={
                "persona": persona,
                "trigger": reason_str,
            }
        )
        
        self._log_contribution(
            action="objection_limit_reached",
            transition="soft_close",
            reason=f"Objection limit exceeded for persona={persona}: {reason_str}"
        )
        
        logger.warning(
            f"Objection limit reached: persona={persona}, {reason_str}"
        )
8.4 IntentProcessorSource

# src/blackboard/sources/intent_processor.py

from typing import Optional, Dict, Any, List, Union
import logging

from ..knowledge_source import KnowledgeSource
from ..blackboard import DialogueBlackboard
from ..enums import Priority
from src.rules.resolver import RuleResolver
from src.conditions.state_machine.registry import ConditionRegistry

logger = logging.getLogger(__name__)


class IntentProcessorSource(KnowledgeSource):
    """
    Knowledge Source for general intent-to-action mapping.
    
    Responsibility:
        - Map intents to actions based on state rules
        - Use RuleResolver for conditional rule evaluation
        - Handle rules defined in state configuration
    
    DOES NOT handle:
        - Price questions (handled by PriceQuestionSource)
        - Objection limits (handled by ObjectionGuardSource)
        - State transitions (handled by TransitionResolverSource)
        - Data completeness (handled by DataCollectorSource)
    
    Rule formats supported:
        1. Simple string: "unclear": "probe_situation"
        2. Conditional dict: {"when": "condition", "then": "action"}
        3. Conditional chain: [{"when": "cond1", "then": "act1"}, "default"]
    """
    
    # Intents handled by dedicated sources (skip here)
    DEDICATED_SOURCE_INTENTS = {
        # Price questions handled by PriceQuestionSource
        "price_question",
        "pricing_details",
        "cost_inquiry",
        "discount_request",
        "payment_terms",
        "pricing_comparison",
        "budget_question",
    }
    
    def __init__(
        self,
        rule_resolver: Optional[RuleResolver] = None,
        condition_registry: Optional[ConditionRegistry] = None,
        name: str = "IntentProcessorSource"
    ):
        """
        Initialize the intent processor source.
        
        Args:
            rule_resolver: RuleResolver instance for conditional rules.
                          Created if not provided.
            condition_registry: ConditionRegistry for condition evaluation.
                               Created if not provided.
            name: Source name for logging
        """
        super().__init__(name)
        self._rule_resolver = rule_resolver or RuleResolver()
        self._condition_registry = condition_registry or ConditionRegistry()
    
    def should_contribute(self, blackboard: DialogueBlackboard) -> bool:
        """
        Quick check: should we process this intent?
        
        Skip if:
        - Source is disabled
        - Intent is handled by a dedicated source
        - No rules defined for current state
        """
        if not self._enabled:
            return False
        
        intent = blackboard.current_intent
        
        # Skip intents handled by dedicated sources
        if intent in self.DEDICATED_SOURCE_INTENTS:
            return False
        
        return True
    
    def contribute(self, blackboard: DialogueBlackboard) -> None:
        """
        Map intent to action using state rules.
        
        Algorithm:
        1. Get rules from current state config
        2. Check if intent has a rule defined
        3. If conditional rule, evaluate using RuleResolver
        4. Propose resolved action
        """
        ctx = blackboard.get_context()
        intent = ctx.current_intent
        
        # Skip dedicated source intents
        if intent in self.DEDICATED_SOURCE_INTENTS:
            self._log_contribution(
                reason=f"Intent {intent} handled by dedicated source"
            )
            return
        
        # Get rules from state config
        rules = ctx.state_config.get("rules", {})
        
        # Check if intent has a rule
        if intent not in rules:
            self._log_contribution(
                reason=f"No rule defined for intent: {intent}"
            )
            return
        
        rule = rules[intent]
        
        # Resolve the rule (handles simple string, conditional dict, chain)
        action = self._resolve_rule(rule, ctx)
        
        if not action:
            self._log_contribution(
                reason=f"Rule for {intent} evaluated to None"
            )
            return
        
        # Determine if action should be combinable
        # Most actions are combinable, but some block transitions
        blocking_actions = {
            "handle_rejection",
            "emergency_escalate",
            "end_conversation",
        }
        combinable = action not in blocking_actions
        
        # Propose the action
        blackboard.propose_action(
            action=action,
            priority=Priority.NORMAL,
            combinable=combinable,
            reason_code=f"rule_{intent}",
            source_name=self.name,
            metadata={
                "intent": intent,
                "rule_type": type(rule).__name__,
            }
        )
        
        self._log_contribution(
            action=action,
            reason=f"Rule matched for intent: {intent}"
        )
    
    def _resolve_rule(
        self,
        rule: Union[str, Dict, List],
        ctx
    ) -> Optional[str]:
        """
        Resolve a rule to an action.
        
        Args:
            rule: Rule definition (string, dict, or list)
            ctx: Context snapshot
            
        Returns:
            Resolved action name or None
        """
        # Simple string rule
        if isinstance(rule, str):
            return rule
        
        # Conditional dict rule: {"when": "condition", "then": "action"}
        if isinstance(rule, dict):
            condition = rule.get("when")
            action = rule.get("then")
            
            if condition and action:
                # Build evaluation context for condition registry
                eval_ctx = self._build_eval_context(ctx)
                
                if self._condition_registry.evaluate(condition, eval_ctx):
                    return action
            
            return None
        
        # Conditional chain: [{"when": "c1", "then": "a1"}, ..., "default"]
        if isinstance(rule, list):
            for item in rule:
                if isinstance(item, str):
                    # Default fallback
                    return item
                
                if isinstance(item, dict):
                    condition = item.get("when")
                    action = item.get("then")
                    
                    if condition and action:
                        eval_ctx = self._build_eval_context(ctx)
                        
                        if self._condition_registry.evaluate(condition, eval_ctx):
                            return action
            
            return None
        
        logger.warning(f"Unknown rule type: {type(rule)}")
        return None
    
    def _build_eval_context(self, ctx) -> Dict[str, Any]:
        """Build evaluation context for condition registry."""
        return {
            "current_intent": ctx.current_intent,
            "state": ctx.state,
            "collected_data": ctx.collected_data,
            "intent_tracker": ctx.intent_tracker,
            "context_envelope": ctx.context_envelope,
        }
8.5 TransitionResolverSource

# src/blackboard/sources/transition_resolver.py

from typing import Optional, Dict, Any, List, Union, Set
import logging

from ..knowledge_source import KnowledgeSource
from ..blackboard import DialogueBlackboard
from ..enums import Priority
from src.conditions.state_machine.registry import ConditionRegistry

logger = logging.getLogger(__name__)


class TransitionResolverSource(KnowledgeSource):
    """
    Knowledge Source for intent-based state transitions.
    
    Responsibility:
        - Detect explicit intent-to-transition mappings
        - Handle conditional transitions
        - Propose state transitions based on intent
    
    DOES NOT handle:
        - data_complete transitions (handled by DataCollectorSource)
        - Objection limit transitions (handled by ObjectionGuardSource)
        - "any" fallback transitions (handled separately in Orchestrator)
    
    Clear boundary with DataCollectorSource:
        - TransitionResolverSource: intent-based transitions (e.g., "rejection" -> "soft_close")
        - DataCollectorSource: data-based transitions (data_complete only)
    """
    
    # Transition triggers handled by other sources
    EXCLUDED_TRIGGERS: Set[str] = {
        "data_complete",  # Handled by DataCollectorSource
        "any",            # Handled separately as fallback
    }
    
    def __init__(
        self,
        condition_registry: Optional[ConditionRegistry] = None,
        name: str = "TransitionResolverSource"
    ):
        """
        Initialize the transition resolver source.
        
        Args:
            condition_registry: ConditionRegistry for conditional transitions.
                               Created if not provided.
            name: Source name for logging
        """
        super().__init__(name)
        self._condition_registry = condition_registry or ConditionRegistry()
    
    def should_contribute(self, blackboard: DialogueBlackboard) -> bool:
        """
        Quick check: does current state have transitions defined?
        """
        if not self._enabled:
            return False
        
        ctx = blackboard.get_context()
        transitions = ctx.state_config.get("transitions", {})
        
        return len(transitions) > 0
    
    def contribute(self, blackboard: DialogueBlackboard) -> None:
        """
        Check for intent-based transitions and propose if matched.
        
        Algorithm:
        1. Get transitions from state config
        2. Check if current intent matches a transition trigger
        3. Handle conditional transitions
        4. Propose transition with appropriate priority
        """
        ctx = blackboard.get_context()
        intent = ctx.current_intent
        transitions = ctx.state_config.get("transitions", {})
        
        # Skip excluded triggers
        if intent in self.EXCLUDED_TRIGGERS:
            self._log_contribution(
                reason=f"Trigger {intent} handled by dedicated source"
            )
            return
        
        # Check if intent has a transition defined
        if intent not in transitions:
            self._log_contribution(
                reason=f"No transition defined for intent: {intent}"
            )
            return
        
        transition_def = transitions[intent]
        
        # Resolve the transition
        next_state = self._resolve_transition(transition_def, ctx)
        
        if not next_state:
            self._log_contribution(
                reason=f"Transition for {intent} evaluated to None"
            )
            return
        
        # Determine priority based on intent type
        high_priority_intents = {
            "rejection",
            "hard_no",
            "end_conversation",
            "explicit_close_request",
        }
        
        priority = Priority.HIGH if intent in high_priority_intents else Priority.NORMAL
        
        # Propose the transition
        blackboard.propose_transition(
            next_state=next_state,
            priority=priority,
            reason_code=f"intent_transition_{intent}",
            source_name=self.name,
            metadata={
                "trigger_intent": intent,
                "transition_type": type(transition_def).__name__,
            }
        )
        
        self._log_contribution(
            transition=next_state,
            reason=f"Intent-based transition: {intent} -> {next_state}"
        )
    
    def _resolve_transition(
        self,
        transition_def: Union[str, Dict, List],
        ctx
    ) -> Optional[str]:
        """
        Resolve a transition definition to a target state.
        
        Args:
            transition_def: Transition definition (string, dict, or list)
            ctx: Context snapshot
            
        Returns:
            Target state name or None
        """
        # Simple string transition
        if isinstance(transition_def, str):
            return transition_def
        
        # Conditional dict: {"when": "condition", "then": "state"}
        if isinstance(transition_def, dict):
            condition = transition_def.get("when")
            target = transition_def.get("then")
            
            if condition and target:
                eval_ctx = self._build_eval_context(ctx)
                
                if self._condition_registry.evaluate(condition, eval_ctx):
                    return target
            
            return None
        
        # Conditional chain: [{"when": "c1", "then": "s1"}, ..., "default"]
        if isinstance(transition_def, list):
            for item in transition_def:
                if isinstance(item, str):
                    # Default fallback
                    return item
                
                if isinstance(item, dict):
                    condition = item.get("when")
                    target = item.get("then")
                    
                    if condition and target:
                        eval_ctx = self._build_eval_context(ctx)
                        
                        if self._condition_registry.evaluate(condition, eval_ctx):
                            return target
            
            return None
        
        logger.warning(f"Unknown transition type: {type(transition_def)}")
        return None
    
    def _build_eval_context(self, ctx) -> Dict[str, Any]:
        """Build evaluation context for condition registry."""
        return {
            "current_intent": ctx.current_intent,
            "state": ctx.state,
            "collected_data": ctx.collected_data,
            "intent_tracker": ctx.intent_tracker,
            "context_envelope": ctx.context_envelope,
        }
8.6 EscalationSource

# src/blackboard/sources/escalation.py

from typing import Optional, Dict, Set
import logging

from ..knowledge_source import KnowledgeSource
from ..blackboard import DialogueBlackboard
from ..enums import Priority

logger = logging.getLogger(__name__)


class EscalationSource(KnowledgeSource):
    """
    Knowledge Source for human escalation triggers.
    
    Responsibility:
        - Detect situations requiring human intervention
        - Propose escalation action when triggers are met
        - Block all other processing (combinable=False)
    
    Escalation triggers:
        1. Explicit request: user asks for human/manager
        2. Frustration threshold: repeated failures or angry sentiment
        3. Repeated misunderstandings: multiple "unclear" intents
        4. Sensitive topics: legal, compliance, complaints
        5. High-value lead: detected enterprise/large deal
    
    Based on enterprise chatbot best practices:
    - Human escalation is critical for user satisfaction
    - Should be triggered proactively, not just reactively
    """
    
    # Intents that explicitly request human
    EXPLICIT_ESCALATION_INTENTS: Set[str] = {
        "request_human",
        "speak_to_manager",
        "talk_to_person",
        "need_help",
        "not_a_bot",
        "real_person",
        "human_please",
        "escalate",
    }
    
    # Intents indicating frustration
    FRUSTRATION_INTENTS: Set[str] = {
        "frustrated",
        "angry",
        "complaint",
        "this_is_useless",
        "not_helpful",
        "waste_of_time",
    }
    
    # Sensitive topics requiring human
    SENSITIVE_INTENTS: Set[str] = {
        "legal_question",
        "compliance_question",
        "formal_complaint",
        "refund_request",
        "contract_dispute",
        "data_deletion",
        "gdpr_request",
    }
    
    def __init__(
        self,
        frustration_threshold: int = 3,
        misunderstanding_threshold: int = 4,
        high_value_threshold: int = 100,  # company_size threshold
        name: str = "EscalationSource"
    ):
        """
        Initialize the escalation source.
        
        Args:
            frustration_threshold: Number of frustration signals to trigger escalation
            misunderstanding_threshold: Number of "unclear" intents to trigger escalation
            high_value_threshold: Company size to consider high-value lead
            name: Source name for logging
        """
        super().__init__(name)
        self._frustration_threshold = frustration_threshold
        self._misunderstanding_threshold = misunderstanding_threshold
        self._high_value_threshold = high_value_threshold
    
    def should_contribute(self, blackboard: DialogueBlackboard) -> bool:
        """
        Quick check: any escalation signals present?
        """
        if not self._enabled:
            return False
        
        intent = blackboard.current_intent
        
        # Always check for explicit escalation requests
        if intent in self.EXPLICIT_ESCALATION_INTENTS:
            return True
        
        # Always check for sensitive topics
        if intent in self.SENSITIVE_INTENTS:
            return True
        
        # Always check for frustration signals
        if intent in self.FRUSTRATION_INTENTS:
            return True
        
        # Check for repeated misunderstandings
        ctx = blackboard.get_context()
        unclear_count = ctx.intent_tracker.total_count("unclear")
        if unclear_count >= self._misunderstanding_threshold - 1:  # About to exceed
            return True
        
        return False
    
    def contribute(self, blackboard: DialogueBlackboard) -> None:
        """
        Check escalation triggers and propose if needed.
        
        Priority order:
        1. Explicit request -> immediate escalation
        2. Sensitive topic -> immediate escalation
        3. Frustration threshold -> escalation
        4. Misunderstanding threshold -> escalation
        5. High-value lead + complex question -> optional escalation
        """
        ctx = blackboard.get_context()
        intent = ctx.current_intent
        
        escalation_reason = None
        escalation_priority = Priority.HIGH
        
        # Check explicit escalation request
        if intent in self.EXPLICIT_ESCALATION_INTENTS:
            escalation_reason = "explicit_request"
            escalation_priority = Priority.CRITICAL  # Highest priority
        
        # Check sensitive topics
        elif intent in self.SENSITIVE_INTENTS:
            escalation_reason = "sensitive_topic"
            escalation_priority = Priority.CRITICAL
        
        # Check frustration signals
        elif intent in self.FRUSTRATION_INTENTS:
            frustration_count = ctx.intent_tracker.category_total("frustration")
            if frustration_count >= self._frustration_threshold:
                escalation_reason = "frustration_threshold"
        
        # Check repeated misunderstandings
        if not escalation_reason:
            unclear_count = ctx.intent_tracker.total_count("unclear")
            if unclear_count >= self._misunderstanding_threshold:
                escalation_reason = "misunderstanding_threshold"
        
        # Check high-value lead with complex question
        if not escalation_reason:
            company_size = ctx.collected_data.get("company_size")
            if company_size and isinstance(company_size, int):
                if company_size >= self._high_value_threshold:
                    # High-value lead - check if complex question
                    complex_intents = {"custom_integration", "enterprise_features", "sla_question"}
                    if intent in complex_intents:
                        escalation_reason = "high_value_complex"
        
        if not escalation_reason:
            self._log_contribution(reason="No escalation triggers met")
            return
        
        # Propose BLOCKING escalation action
        blackboard.propose_action(
            action="escalate_to_human",
            priority=escalation_priority,
            combinable=False,  # BLOCKING: stops all other processing
            reason_code=f"escalation_{escalation_reason}",
            source_name=self.name,
            metadata={
                "trigger": escalation_reason,
                "intent": intent,
                "turn_number": ctx.turn_number,
            }
        )
        
        # Propose transition to escalation state
        blackboard.propose_transition(
            next_state="human_handoff",
            priority=escalation_priority,
            reason_code=f"escalation_{escalation_reason}",
            source_name=self.name,
            metadata={
                "trigger": escalation_reason,
            }
        )
        
        self._log_contribution(
            action="escalate_to_human",
            transition="human_handoff",
            reason=f"Escalation triggered: {escalation_reason}"
        )
        
        logger.info(
            f"Human escalation triggered: reason={escalation_reason}, "
            f"intent={intent}, turn={ctx.turn_number}"
        )
Продолжаю с пятой частью — ConflictResolver, ProposalValidator, EventBus и Orchestrator.

продолжай
Часть 5: ConflictResolver, ProposalValidator, EventBus и Orchestrator
9. ProposalValidator

# src/blackboard/proposal_validator.py

from typing import List, Dict, Any, Set, Optional
from dataclasses import dataclass
import logging

from .models import Proposal
from .enums import Priority, ProposalType

logger = logging.getLogger(__name__)


@dataclass
class ValidationError:
    """
    Represents a validation error for a proposal.
    
    Attributes:
        proposal: The proposal that failed validation
        error_code: Machine-readable error code
        message: Human-readable error message
        severity: "error" (blocks resolution) or "warning" (logged only)
    """
    proposal: Proposal
    error_code: str
    message: str
    severity: str = "error"  # "error" or "warning"
    
    def __repr__(self):
        return f"ValidationError({self.error_code}: {self.message})"


class ProposalValidator:
    """
    Validates proposals before conflict resolution.
    
    Responsibilities:
        - Validate proposal structure (required fields, types)
        - Validate action names against allowed actions
        - Validate state names against defined states
        - Validate reason codes against documented codes
        - Log warnings for non-critical issues
    
    Validation is critical for:
        - Catching configuration errors early
        - Ensuring auditability (valid reason codes)
        - Preventing runtime errors in ConflictResolver
    """
    
    def __init__(
        self,
        valid_actions: Optional[Set[str]] = None,
        valid_states: Optional[Set[str]] = None,
        valid_reason_codes: Optional[Set[str]] = None,
        strict_mode: bool = False
    ):
        """
        Initialize the validator.
        
        Args:
            valid_actions: Set of valid action names. If None, action validation is skipped.
            valid_states: Set of valid state names. If None, state validation is skipped.
            valid_reason_codes: Set of documented reason codes. If None, logs warning only.
            strict_mode: If True, treat warnings as errors.
        """
        self._valid_actions = valid_actions
        self._valid_states = valid_states
        self._valid_reason_codes = valid_reason_codes
        self._strict_mode = strict_mode
    
    def validate(self, proposals: List[Proposal]) -> List[ValidationError]:
        """
        Validate a list of proposals.
        
        Args:
            proposals: List of proposals to validate
            
        Returns:
            List of ValidationError objects (empty if all valid)
        """
        errors: List[ValidationError] = []
        
        for proposal in proposals:
            errors.extend(self._validate_proposal(proposal))
        
        # Log validation results
        error_count = sum(1 for e in errors if e.severity == "error")
        warning_count = sum(1 for e in errors if e.severity == "warning")
        
        if error_count > 0:
            logger.error(f"Proposal validation failed: {error_count} errors, {warning_count} warnings")
        elif warning_count > 0:
            logger.warning(f"Proposal validation: {warning_count} warnings")
        else:
            logger.debug(f"Proposal validation passed: {len(proposals)} proposals valid")
        
        return errors
    
    def _validate_proposal(self, proposal: Proposal) -> List[ValidationError]:
        """Validate a single proposal."""
        errors: List[ValidationError] = []
        
        # 1. Basic structure validation (from Proposal.validate())
        structure_errors = proposal.validate()
        for error_msg in structure_errors:
            errors.append(ValidationError(
                proposal=proposal,
                error_code="INVALID_STRUCTURE",
                message=error_msg,
                severity="error"
            ))
        
        # 2. Validate action names
        if proposal.type == ProposalType.ACTION and self._valid_actions is not None:
            if proposal.value not in self._valid_actions:
                errors.append(ValidationError(
                    proposal=proposal,
                    error_code="INVALID_ACTION",
                    message=f"Unknown action: '{proposal.value}'. Valid actions: {sorted(self._valid_actions)[:10]}...",
                    severity="warning" if not self._strict_mode else "error"
                ))
        
        # 3. Validate state names
        if proposal.type == ProposalType.TRANSITION and self._valid_states is not None:
            if proposal.value not in self._valid_states:
                errors.append(ValidationError(
                    proposal=proposal,
                    error_code="INVALID_STATE",
                    message=f"Unknown state: '{proposal.value}'. Valid states: {sorted(self._valid_states)[:10]}...",
                    severity="error"  # Invalid state is always an error
                ))
        
        # 4. Validate reason codes
        if self._valid_reason_codes is not None:
            if proposal.reason_code not in self._valid_reason_codes:
                errors.append(ValidationError(
                    proposal=proposal,
                    error_code="UNDOCUMENTED_REASON_CODE",
                    message=f"Undocumented reason code: '{proposal.reason_code}'",
                    severity="warning"  # Undocumented is a warning, not error
                ))
        
        # 5. Validate combinable flag consistency
        if proposal.type == ProposalType.TRANSITION and not proposal.combinable:
            errors.append(ValidationError(
                proposal=proposal,
                error_code="INVALID_COMBINABLE",
                message="TRANSITION proposals cannot have combinable=False",
                severity="error"
            ))
        
        # 6. Validate priority for blocking actions
        if proposal.type == ProposalType.ACTION and not proposal.combinable:
            if proposal.priority == Priority.LOW:
                errors.append(ValidationError(
                    proposal=proposal,
                    error_code="BLOCKING_LOW_PRIORITY",
                    message="Blocking actions (combinable=False) should not have LOW priority",
                    severity="warning"
                ))
        
        return errors
    
    def get_errors_only(self, validation_results: List[ValidationError]) -> List[ValidationError]:
        """Filter to get only errors (not warnings)."""
        return [e for e in validation_results if e.severity == "error"]
    
    def get_warnings_only(self, validation_results: List[ValidationError]) -> List[ValidationError]:
        """Filter to get only warnings (not errors)."""
        return [e for e in validation_results if e.severity == "warning"]
    
    def has_blocking_errors(self, validation_results: List[ValidationError]) -> bool:
        """Check if there are any blocking errors."""
        return any(e.severity == "error" for e in validation_results)
10. ConflictResolver

# src/blackboard/conflict_resolver.py

from typing import List, Dict, Any, Optional, Tuple
from dataclasses import dataclass, field
import logging

from .models import Proposal, ResolvedDecision
from .enums import Priority, ProposalType

logger = logging.getLogger(__name__)


@dataclass
class ResolutionTrace:
    """
    Detailed trace of the resolution process for debugging.
    
    Attributes:
        action_proposals: All action proposals received
        transition_proposals: All transition proposals received
        action_ranking: Actions sorted by priority
        transition_ranking: Transitions sorted by priority
        winning_action: Selected action proposal
        winning_transition: Selected transition proposal (may be None)
        merge_decision: Whether action and transition were merged
        blocking_reason: If action blocked transition, why
    """
    action_proposals: List[Proposal] = field(default_factory=list)
    transition_proposals: List[Proposal] = field(default_factory=list)
    action_ranking: List[Tuple[str, Priority, str]] = field(default_factory=list)
    transition_ranking: List[Tuple[str, Priority, str]] = field(default_factory=list)
    winning_action: Optional[Proposal] = None
    winning_transition: Optional[Proposal] = None
    merge_decision: str = ""
    blocking_reason: Optional[str] = None
    
    def to_dict(self) -> Dict[str, Any]:
        """Convert to dictionary for logging/serialization."""
        return {
            "action_proposals_count": len(self.action_proposals),
            "transition_proposals_count": len(self.transition_proposals),
            "action_ranking": self.action_ranking,
            "transition_ranking": self.transition_ranking,
            "winning_action": str(self.winning_action) if self.winning_action else None,
            "winning_transition": str(self.winning_transition) if self.winning_transition else None,
            "merge_decision": self.merge_decision,
            "blocking_reason": self.blocking_reason,
        }


class ConflictResolver:
    """
    Resolves conflicts between proposals from multiple Knowledge Sources.
    
    Core Algorithm:
        1. Separate proposals by type (ACTION vs TRANSITION)
        2. Sort each list by priority (CRITICAL > HIGH > NORMAL > LOW)
        3. Select winning action (highest priority)
        4. Check combinable flag:
           - If combinable=False: action BLOCKS all transitions
           - If combinable=True: action can MERGE with transition
        5. Select winning transition (if not blocked)
        6. Return ResolvedDecision with both action and next_state
    
    Key Innovation:
        The combinable flag allows actions like "answer_with_pricing" to coexist
        with transitions like "data_complete -> spin_problem". This solves the
        core problem where price questions blocked phase progression.
    
    Priority Semantics:
        CRITICAL (0): Blocking actions (rejection, escalation) - always wins
        HIGH (1): Important actions (price questions, objection handling)
        NORMAL (2): Standard processing (intent rules, data collection)
        LOW (3): Fallback actions (continue, default behavior)
    """
    
    def __init__(self, default_action: str = "continue"):
        """
        Initialize the conflict resolver.
        
        Args:
            default_action: Action to use when no action proposals exist
        """
        self._default_action = default_action
    
    def resolve(
        self,
        proposals: List[Proposal],
        current_state: str,
        data_updates: Optional[Dict[str, Any]] = None,
        flags_to_set: Optional[Dict[str, Any]] = None
    ) -> ResolvedDecision:
        """
        Resolve conflicts between proposals and produce final decision.
        
        Args:
            proposals: List of all proposals from Knowledge Sources
            current_state: Current dialogue state (used if no transition)
            data_updates: Data updates to include in decision
            flags_to_set: Flags to include in decision
            
        Returns:
            ResolvedDecision with final action, next_state, and metadata
        """
        trace = ResolutionTrace()
        
        # Step 1: Separate proposals by type
        action_proposals = [p for p in proposals if p.type == ProposalType.ACTION]
        transition_proposals = [p for p in proposals if p.type == ProposalType.TRANSITION]
        
        trace.action_proposals = action_proposals
        trace.transition_proposals = transition_proposals
        
        logger.debug(
            f"Resolving conflicts: {len(action_proposals)} actions, "
            f"{len(transition_proposals)} transitions"
        )
        
        # Step 2: Sort by priority (lower value = higher priority)
        action_proposals.sort(key=lambda p: p.priority.value)
        transition_proposals.sort(key=lambda p: p.priority.value)
        
        # Record rankings for trace
        trace.action_ranking = [
            (p.value, p.priority, p.source_name) for p in action_proposals
        ]
        trace.transition_ranking = [
            (p.value, p.priority, p.source_name) for p in transition_proposals
        ]
        
        # Step 3: Select winning action
        winning_action: Optional[Proposal] = None
        if action_proposals:
            winning_action = action_proposals[0]
            trace.winning_action = winning_action
            
            logger.debug(
                f"Winning action: {winning_action.value} "
                f"(priority={winning_action.priority.name}, "
                f"combinable={winning_action.combinable}, "
                f"source={winning_action.source_name})"
            )
        
        # Step 4: Check combinable flag and decide on transition
        winning_transition: Optional[Proposal] = None
        rejected_proposals: List[Proposal] = []
        
        if winning_action and not winning_action.combinable:
            # BLOCKING action - reject all transitions
            trace.blocking_reason = (
                f"Action '{winning_action.value}' has combinable=False, "
                f"blocking {len(transition_proposals)} transition(s)"
            )
            trace.merge_decision = "BLOCKED"
            
            rejected_proposals.extend(transition_proposals)
            rejected_proposals.extend(action_proposals[1:])  # Non-winning actions
            
            logger.debug(
                f"Blocking action detected: {winning_action.value}. "
                f"Transitions blocked: {[p.value for p in transition_proposals]}"
            )
        else:
            # COMBINABLE action (or no action) - can merge with transition
            if transition_proposals:
                winning_transition = transition_proposals[0]
                trace.winning_transition = winning_transition
                trace.merge_decision = "MERGED" if winning_action else "TRANSITION_ONLY"
                
                rejected_proposals.extend(transition_proposals[1:])  # Non-winning transitions
                
                logger.debug(
                    f"Winning transition: {winning_transition.value} "
                    f"(priority={winning_transition.priority.name}, "
                    f"source={winning_transition.source_name})"
                )
            else:
                trace.merge_decision = "ACTION_ONLY" if winning_action else "NO_PROPOSALS"
            
            if winning_action:
                rejected_proposals.extend(action_proposals[1:])  # Non-winning actions
        
        # Step 5: Build reason codes
        reason_codes: List[str] = []
        if winning_action:
            reason_codes.append(winning_action.reason_code)
        if winning_transition:
            reason_codes.append(winning_transition.reason_code)
        
        # Step 6: Construct final decision
        final_action = winning_action.value if winning_action else self._default_action
        next_state = winning_transition.value if winning_transition else current_state
        
        decision = ResolvedDecision(
            action=final_action,
            next_state=next_state,
            reason_codes=reason_codes,
            rejected_proposals=rejected_proposals,
            resolution_trace=trace.to_dict(),
            data_updates=data_updates or {},
            flags_to_set=flags_to_set or {},
        )
        
        logger.info(
            f"Conflict resolved: action='{final_action}', next_state='{next_state}', "
            f"merge={trace.merge_decision}, rejected={len(rejected_proposals)}"
        )
        
        return decision
    
    def resolve_with_fallback(
        self,
        proposals: List[Proposal],
        current_state: str,
        fallback_transition: Optional[str] = None,
        data_updates: Optional[Dict[str, Any]] = None,
        flags_to_set: Optional[Dict[str, Any]] = None
    ) -> ResolvedDecision:
        """
        Resolve conflicts with a fallback transition (e.g., "any" transition).
        
        This method first tries normal resolution. If no transition is selected
        and a fallback is provided, it applies the fallback transition.
        
        Args:
            proposals: List of all proposals from Knowledge Sources
            current_state: Current dialogue state
            fallback_transition: Fallback transition target (e.g., from "any" trigger)
            data_updates: Data updates to include in decision
            flags_to_set: Flags to include in decision
            
        Returns:
            ResolvedDecision with final action, next_state, and metadata
        """
        decision = self.resolve(
            proposals=proposals,
            current_state=current_state,
            data_updates=data_updates,
            flags_to_set=flags_to_set,
        )
        
        # Apply fallback if no transition was selected and fallback is available
        if decision.next_state == current_state and fallback_transition:
            # Check if action allows fallback (must be combinable or no action)
            action_blocked = any(
                p.type == ProposalType.ACTION and not p.combinable
                for p in proposals
                if p.value == decision.action
            )
            
            if not action_blocked:
                logger.debug(
                    f"Applying fallback transition: {fallback_transition}"
                )
                decision.next_state = fallback_transition
                decision.reason_codes.append("fallback_any_transition")
                decision.resolution_trace["fallback_applied"] = True
        
        return decision
11. DialogueEventBus

# src/blackboard/event_bus.py

from typing import Dict, Any, List, Callable, Optional
from dataclasses import dataclass, field
from datetime import datetime
from enum import Enum, auto
import logging
import threading
from queue import Queue

logger = logging.getLogger(__name__)


class EventType(Enum):
    """Types of events emitted by the Blackboard system."""
    TURN_STARTED = auto()
    SOURCE_CONTRIBUTED = auto()
    PROPOSAL_VALIDATED = auto()
    CONFLICT_RESOLVED = auto()
    DECISION_COMMITTED = auto()
    STATE_TRANSITIONED = auto()
    ERROR_OCCURRED = auto()


@dataclass
class DialogueEvent:
    """
    Base class for all dialogue events.
    
    Attributes:
        event_type: Type of the event
        timestamp: When the event occurred
        turn_number: Dialogue turn number
        data: Event-specific data
    """
    event_type: EventType
    timestamp: datetime = field(default_factory=datetime.now)
    turn_number: int = 0
    data: Dict[str, Any] = field(default_factory=dict)
    
    def to_dict(self) -> Dict[str, Any]:
        """Convert to dictionary for serialization."""
        return {
            "event_type": self.event_type.name,
            "timestamp": self.timestamp.isoformat(),
            "turn_number": self.turn_number,
            "data": self.data,
        }


@dataclass
class TurnStartedEvent(DialogueEvent):
    """Event emitted when a new turn begins."""
    
    def __init__(self, turn_number: int, intent: str, state: str, **kwargs):
        super().__init__(
            event_type=EventType.TURN_STARTED,
            turn_number=turn_number,
            data={
                "intent": intent,
                "state": state,
                **kwargs
            }
        )


@dataclass
class SourceContributedEvent(DialogueEvent):
    """Event emitted when a Knowledge Source contributes proposals."""
    
    def __init__(
        self,
        turn_number: int,
        source_name: str,
        proposals_count: int,
        proposals_summary: List[str],
        execution_time_ms: float,
        **kwargs
    ):
        super().__init__(
            event_type=EventType.SOURCE_CONTRIBUTED,
            turn_number=turn_number,
            data={
                "source_name": source_name,
                "proposals_count": proposals_count,
                "proposals_summary": proposals_summary,
                "execution_time_ms": execution_time_ms,
                **kwargs
            }
        )


@dataclass
class ProposalValidatedEvent(DialogueEvent):
    """Event emitted after proposal validation."""
    
    def __init__(
        self,
        turn_number: int,
        valid_count: int,
        error_count: int,
        warning_count: int,
        errors: List[str],
        **kwargs
    ):
        super().__init__(
            event_type=EventType.PROPOSAL_VALIDATED,
            turn_number=turn_number,
            data={
                "valid_count": valid_count,
                "error_count": error_count,
                "warning_count": warning_count,
                "errors": errors,
                **kwargs
            }
        )


@dataclass
class ConflictResolvedEvent(DialogueEvent):
    """Event emitted after conflict resolution."""
    
    def __init__(
        self,
        turn_number: int,
        winning_action: str,
        winning_transition: Optional[str],
        rejected_count: int,
        merge_decision: str,
        resolution_time_ms: float,
        **kwargs
    ):
        super().__init__(
            event_type=EventType.CONFLICT_RESOLVED,
            turn_number=turn_number,
            data={
                "winning_action": winning_action,
                "winning_transition": winning_transition,
                "rejected_count": rejected_count,
                "merge_decision": merge_decision,
                "resolution_time_ms": resolution_time_ms,
                **kwargs
            }
        )


@dataclass
class DecisionCommittedEvent(DialogueEvent):
    """Event emitted when decision is committed to blackboard."""
    
    def __init__(
        self,
        turn_number: int,
        action: str,
        next_state: str,
        reason_codes: List[str],
        **kwargs
    ):
        super().__init__(
            event_type=EventType.DECISION_COMMITTED,
            turn_number=turn_number,
            data={
                "action": action,
                "next_state": next_state,
                "reason_codes": reason_codes,
                **kwargs
            }
        )


@dataclass
class StateTransitionedEvent(DialogueEvent):
    """Event emitted when state actually changes."""
    
    def __init__(
        self,
        turn_number: int,
        from_state: str,
        to_state: str,
        trigger_reason: str,
        **kwargs
    ):
        super().__init__(
            event_type=EventType.STATE_TRANSITIONED,
            turn_number=turn_number,
            data={
                "from_state": from_state,
                "to_state": to_state,
                "trigger_reason": trigger_reason,
                **kwargs
            }
        )


@dataclass
class ErrorOccurredEvent(DialogueEvent):
    """Event emitted when an error occurs."""
    
    def __init__(
        self,
        turn_number: int,
        error_type: str,
        error_message: str,
        component: str,
        **kwargs
    ):
        super().__init__(
            event_type=EventType.ERROR_OCCURRED,
            turn_number=turn_number,
            data={
                "error_type": error_type,
                "error_message": error_message,
                "component": component,
                **kwargs
            }
        )


# Type alias for event handlers
EventHandler = Callable[[DialogueEvent], None]


class DialogueEventBus:
    """
    Event bus for observability and analytics in the Blackboard system.
    
    Responsibilities:
        - Publish events from Blackboard components
        - Allow subscribers to listen for specific event types
        - Support async processing to avoid blocking main flow
        - Provide event history for debugging
    
    Subscribers can include:
        - MetricsCollector: records metrics for monitoring
        - DebugLogger: detailed logging for debugging
        - AnalyticsTracker: business analytics
        - AlertManager: alerts on anomalies
    """
    
    def __init__(
        self,
        async_mode: bool = False,
        history_size: int = 100
    ):
        """
        Initialize the event bus.
        
        Args:
            async_mode: If True, process events asynchronously
            history_size: Number of recent events to keep in history
        """
        self._handlers: Dict[EventType, List[EventHandler]] = {
            event_type: [] for event_type in EventType
        }
        self._global_handlers: List[EventHandler] = []
        self._history: List[DialogueEvent] = []
        self._history_size = history_size
        self._async_mode = async_mode
        self._event_queue: Optional[Queue] = Queue() if async_mode else None
        self._worker_thread: Optional[threading.Thread] = None
        self._running = False
        
        if async_mode:
            self._start_worker()
    
    def subscribe(
        self,
        event_type: EventType,
        handler: EventHandler
    ) -> None:
        """
        Subscribe to a specific event type.
        
        Args:
            event_type: Type of event to subscribe to
            handler: Callback function to handle the event
        """
        self._handlers[event_type].append(handler)
        logger.debug(f"Handler subscribed to {event_type.name}")
    
    def subscribe_all(self, handler: EventHandler) -> None:
        """
        Subscribe to all event types.
        
        Args:
            handler: Callback function to handle all events
        """
        self._global_handlers.append(handler)
        logger.debug("Global handler subscribed to all events")
    
    def unsubscribe(
        self,
        event_type: EventType,
        handler: EventHandler
    ) -> None:
        """
        Unsubscribe from a specific event type.
        
        Args:
            event_type: Type of event to unsubscribe from
            handler: Handler to remove
        """
        if handler in self._handlers[event_type]:
            self._handlers[event_type].remove(handler)
            logger.debug(f"Handler unsubscribed from {event_type.name}")
    
    def emit(self, event: DialogueEvent) -> None:
        """
        Emit an event to all subscribers.
        
        Args:
            event: Event to emit
        """
        # Add to history
        self._history.append(event)
        if len(self._history) > self._history_size:
            self._history.pop(0)
        
        if self._async_mode and self._event_queue:
            # Queue for async processing
            self._event_queue.put(event)
        else:
            # Process synchronously
            self._process_event(event)
    
    def _process_event(self, event: DialogueEvent) -> None:
        """Process an event by calling all handlers."""
        # Call type-specific handlers
        for handler in self._handlers[event.event_type]:
            try:
                handler(event)
            except Exception as e:
                logger.error(
                    f"Error in event handler for {event.event_type.name}: {e}"
                )
        
        # Call global handlers
        for handler in self._global_handlers:
            try:
                handler(event)
            except Exception as e:
                logger.error(f"Error in global event handler: {e}")
    
    def _start_worker(self) -> None:
        """Start the async worker thread."""
        self._running = True
        self._worker_thread = threading.Thread(
            target=self._worker_loop,
            daemon=True
        )
        self._worker_thread.start()
        logger.debug("Event bus async worker started")
    
    def _worker_loop(self) -> None:
        """Worker loop for async event processing."""
        while self._running:
            try:
                event = self._event_queue.get(timeout=1.0)
                self._process_event(event)
            except Exception:
                pass  # Timeout, continue loop
    
    def stop(self) -> None:
        """Stop the async worker."""
        self._running = False
        if self._worker_thread:
            self._worker_thread.join(timeout=2.0)
            logger.debug("Event bus async worker stopped")
    
    def get_history(
        self,
        event_type: Optional[EventType] = None,
        limit: int = 10
    ) -> List[DialogueEvent]:
        """
        Get recent events from history.
        
        Args:
            event_type: Filter by event type (None for all)
            limit: Maximum number of events to return
            
        Returns:
            List of recent events (most recent last)
        """
        events = self._history
        
        if event_type:
            events = [e for e in events if e.event_type == event_type]
        
        return events[-limit:]
    
    def clear_history(self) -> None:
        """Clear event history."""
        self._history.clear()


# === Pre-built Subscribers ===

class MetricsCollector:
    """
    Subscriber that collects metrics from events.
    
    Metrics collected:
        - Turn count
        - Action distribution
        - Transition distribution
        - Source contribution counts
        - Resolution times
        - Error rates
    """
    
    def __init__(self):
        self.metrics: Dict[str, Any] = {
            "turn_count": 0,
            "action_counts": {},
            "transition_counts": {},
            "source_contribution_counts": {},
            "total_resolution_time_ms": 0,
            "error_count": 0,
            "state_loop_count": 0,
        }
    
    def handle_event(self, event: DialogueEvent) -> None:
        """Handle an event and update metrics."""
        if event.event_type == EventType.TURN_STARTED:
            self.metrics["turn_count"] += 1
        
        elif event.event_type == EventType.SOURCE_CONTRIBUTED:
            source = event.data.get("source_name", "unknown")
            if source not in self.metrics["source_contribution_counts"]:
                self.metrics["source_contribution_counts"][source] = 0
            self.metrics["source_contribution_counts"][source] += 1
        
        elif event.event_type == EventType.CONFLICT_RESOLVED:
            action = event.data.get("winning_action", "unknown")
            if action not in self.metrics["action_counts"]:
                self.metrics["action_counts"][action] = 0
            self.metrics["action_counts"][action] += 1
            
            self.metrics["total_resolution_time_ms"] += event.data.get(
                "resolution_time_ms", 0
            )
        
        elif event.event_type == EventType.STATE_TRANSITIONED:
            from_state = event.data.get("from_state")
            to_state = event.data.get("to_state")
            
            transition_key = f"{from_state}->{to_state}"
            if transition_key not in self.metrics["transition_counts"]:
                self.metrics["transition_counts"][transition_key] = 0
            self.metrics["transition_counts"][transition_key] += 1
            
            # Detect state loops
            if from_state == to_state:
                self.metrics["state_loop_count"] += 1
        
        elif event.event_type == EventType.ERROR_OCCURRED:
            self.metrics["error_count"] += 1
    
    def get_metrics(self) -> Dict[str, Any]:
        """Get current metrics."""
        return dict(self.metrics)
    
    def reset(self) -> None:
        """Reset all metrics."""
        self.metrics = {
            "turn_count": 0,
            "action_counts": {},
            "transition_counts": {},
            "source_contribution_counts": {},
            "total_resolution_time_ms": 0,
            "error_count": 0,
            "state_loop_count": 0,
        }


class DebugLogger:
    """
    Subscriber that logs detailed debug information.
    """
    
    def __init__(self, log_level: int = logging.DEBUG):
        self._logger = logging.getLogger("blackboard.debug")
        self._log_level = log_level
    
    def handle_event(self, event: DialogueEvent) -> None:
        """Log event details."""
        self._logger.log(
            self._log_level,
            f"[Turn {event.turn_number}] {event.event_type.name}: {event.data}"
        )
12. DialogueOrchestrator

# src/blackboard/orchestrator.py

from typing import List, Dict, Any, Optional, Tuple, Type
from datetime import datetime
import logging
import time

from .blackboard import DialogueBlackboard
from .knowledge_source import KnowledgeSource
from .conflict_resolver import ConflictResolver
from .proposal_validator import ProposalValidator, ValidationError
from .event_bus import (
    DialogueEventBus,
    TurnStartedEvent,
    SourceContributedEvent,
    ProposalValidatedEvent,
    ConflictResolvedEvent,
    DecisionCommittedEvent,
    StateTransitionedEvent,
    ErrorOccurredEvent,
)
from .models import ResolvedDecision
from .enums import Priority

# Hexagonal Architecture: Import protocols (ports)
from .protocols import (
    IStateMachine,
    IFlowConfig,
    TenantConfig,
    DEFAULT_TENANT,
)

# Import SourceRegistry (Plugin System)
from .source_registry import SourceRegistry, register_builtin_sources

logger = logging.getLogger(__name__)

# Register built-in sources on module import
register_builtin_sources()


class DialogueOrchestrator:
    """
    Main coordinator for the Dialogue Blackboard System.

    Hexagonal Architecture:
        Orchestrator is the APPLICATION LAYER that coordinates domain logic.
        It depends on PROTOCOLS (ports) rather than concrete implementations:
        - IStateMachine: input port for state management
        - IFlowConfig: input port for configuration
        - IContextEnvelope: input port for context data

    Responsibilities:
        - Initialize and manage Knowledge Sources
        - Coordinate the turn processing pipeline
        - Handle validation and error recovery
        - Emit events for observability

    Multi-Tenancy:
        Supports tenant-specific configuration via TenantConfig.
        Each tenant can have custom feature flags, persona limits, etc.

    Pipeline:
        1. begin_turn() - Initialize blackboard for new turn
        2. Knowledge Sources contribute proposals
        3. Validate proposals
        4. Resolve conflicts
        5. Commit decision
        6. Return result to caller (SalesBot)

    Usage:
        orchestrator = DialogueOrchestrator(state_machine, flow_config)
        decision = orchestrator.process_turn(intent, extracted_data, context_envelope)
        # decision.action, decision.next_state, decision.reason_codes
    """

    def __init__(
        self,
        state_machine: 'IStateMachine',  # Protocol type (Hexagonal Architecture port)
        flow_config: 'IFlowConfig',       # Protocol type (Hexagonal Architecture port)
        event_bus: Optional[DialogueEventBus] = None,
        enable_validation: bool = True,
        strict_validation: bool = False,
        persona_limits: Optional[Dict[str, Dict[str, int]]] = None,
        tenant_config: Optional['TenantConfig'] = None,  # Multi-tenancy support
    ):
        """
        Initialize the orchestrator.

        Args:
            state_machine: State machine implementing IStateMachine protocol
            flow_config: Flow configuration implementing IFlowConfig protocol
            event_bus: Event bus for observability (created if not provided)
            enable_validation: Whether to validate proposals
            strict_validation: Whether to treat warnings as errors
            persona_limits: Custom persona limits for ObjectionGuardSource
            tenant_config: Tenant-specific configuration (uses DEFAULT_TENANT if not provided)
        """
        self._state_machine = state_machine
        self._flow_config = flow_config
        self._tenant_config = tenant_config or DEFAULT_TENANT

        # Initialize blackboard with tenant config
        self._blackboard = DialogueBlackboard(
            state_machine=state_machine,
            flow_config=flow_config,
            tenant_config=self._tenant_config,
        )
        
        # Initialize event bus
        self._event_bus = event_bus or DialogueEventBus()
        
        # Initialize validator
        self._enable_validation = enable_validation
        self._validator = ProposalValidator(
            valid_states=set(flow_config.states.keys()) if hasattr(flow_config, 'states') else None,
            strict_mode=strict_validation,
        )
        
        # Initialize conflict resolver
        self._resolver = ConflictResolver(default_action="continue")
        
        # Initialize Knowledge Sources via Registry (Plugin System)
        # Sources are created in priority_order from SourceRegistry
        # Configuration can enable/disable individual sources
        source_configs = {
            "ObjectionGuardSource": {"persona_limits": persona_limits},
        }

        self._sources: List[KnowledgeSource] = SourceRegistry.create_sources(
            config=self._get_sources_config(),
            source_configs=source_configs,
        )

        logger.info(
            f"DialogueOrchestrator initialized with {len(self._sources)} sources: "
            f"{[s.name for s in self._sources]}"
        )

    def _get_sources_config(self) -> Dict[str, Any]:
        """
        Get sources configuration from flow_config or constants.

        Returns:
            Dict with 'sources' key containing per-source enabled flags
        """
        # Try to get from flow_config
        if hasattr(self._flow_config, 'constants'):
            return self._flow_config.constants.get('blackboard', {})
        return {}
    
    @property
    def blackboard(self) -> DialogueBlackboard:
        """Get the blackboard instance."""
        return self._blackboard
    
    @property
    def event_bus(self) -> DialogueEventBus:
        """Get the event bus instance."""
        return self._event_bus
    
    @property
    def sources(self) -> List[KnowledgeSource]:
        """Get list of Knowledge Sources."""
        return list(self._sources)
    
    def add_source(self, source: KnowledgeSource) -> None:
        """
        Add a new Knowledge Source.
        
        Args:
            source: Knowledge Source to add
        """
        self._sources.append(source)
        logger.info(f"Added Knowledge Source: {source.name}")
    
    def remove_source(self, source_name: str) -> bool:
        """
        Remove a Knowledge Source by name.
        
        Args:
            source_name: Name of source to remove
            
        Returns:
            True if source was removed, False if not found
        """
        for source in self._sources:
            if source.name == source_name:
                self._sources.remove(source)
                logger.info(f"Removed Knowledge Source: {source_name}")
                return True
        return False
    
    def process_turn(
        self,
        intent: str,
        extracted_data: Dict[str, Any],
        context_envelope: Optional[Any] = None,
    ) -> ResolvedDecision:
        """
        Process a dialogue turn through the Blackboard system.
        
        This is the main entry point, replacing StateMachine.apply_rules().
        
        Args:
            intent: Classified intent for this turn
            extracted_data: Data extracted from user message
            context_envelope: Full context envelope (Phase 5)
            
        Returns:
            ResolvedDecision with action, next_state, and metadata
        """
        turn_start_time = time.time()
        turn_number = self._blackboard._intent_tracker.turn_number + 1
        current_state = self._state_machine.state
        
        try:
            # === STEP 1: Begin Turn ===
            self._blackboard.begin_turn(
                intent=intent,
                extracted_data=extracted_data,
                context_envelope=context_envelope,
            )
            
            self._event_bus.emit(TurnStartedEvent(
                turn_number=turn_number,
                intent=intent,
                state=current_state,
            ))
            
            logger.debug(
                f"Turn {turn_number} started: intent={intent}, state={current_state}"
            )
            
            # === STEP 2: Knowledge Sources Contribute ===
            for source in self._sources:
                source_start_time = time.time()
                
                # Check if source should contribute
                if not source.should_contribute(self._blackboard):
                    logger.debug(f"Source {source.name} skipped (should_contribute=False)")
                    continue
                
                # Let source contribute
                try:
                    source.contribute(self._blackboard)
                except Exception as e:
                    logger.error(f"Error in source {source.name}: {e}")
                    self._event_bus.emit(ErrorOccurredEvent(
                        turn_number=turn_number,
                        error_type=type(e).__name__,
                        error_message=str(e),
                        component=source.name,
                    ))
                    continue
                
                source_time_ms = (time.time() - source_start_time) * 1000
                
                # Get proposals from this source
                proposals_summary = [
                    str(p) for p in self._blackboard.get_proposals()
                    if p.source_name == source.name
                ]
                
                self._event_bus.emit(SourceContributedEvent(
                    turn_number=turn_number,
                    source_name=source.name,
                    proposals_count=len(proposals_summary),
                    proposals_summary=proposals_summary,
                    execution_time_ms=source_time_ms,
                ))
            
            # === STEP 3: Validate Proposals ===
            proposals = self._blackboard.get_proposals()
            validation_errors: List[ValidationError] = []
            
            if self._enable_validation:
                validation_errors = self._validator.validate(proposals)
                
                error_count = len(self._validator.get_errors_only(validation_errors))
                warning_count = len(self._validator.get_warnings_only(validation_errors))
                
                self._event_bus.emit(ProposalValidatedEvent(
                    turn_number=turn_number,
                    valid_count=len(proposals) - error_count,
                    error_count=error_count,
                    warning_count=warning_count,
                    errors=[str(e) for e in validation_errors],
                ))
                
                # Handle blocking validation errors
                if self._validator.has_blocking_errors(validation_errors):
                    logger.error(
                        f"Blocking validation errors: {validation_errors}"
                    )
                    # Return safe fallback decision
                    return self._create_fallback_decision(
                        current_state=current_state,
                        reason="validation_error",
                        turn_number=turn_number,
                    )
            
            # === STEP 4: Resolve Conflicts ===
            resolve_start_time = time.time()
            
            # Get fallback transition (from "any" trigger)
            fallback_transition = self._get_fallback_transition()
            
            decision = self._resolver.resolve_with_fallback(
                proposals=proposals,
                current_state=current_state,
                fallback_transition=fallback_transition,
                data_updates=self._blackboard.get_data_updates(),
                flags_to_set=self._blackboard.get_flags_to_set(),
            )
            
            resolve_time_ms = (time.time() - resolve_start_time) * 1000
            
            self._event_bus.emit(ConflictResolvedEvent(
                turn_number=turn_number,
                winning_action=decision.action,
                winning_transition=decision.next_state if decision.next_state != current_state else None,
                rejected_count=len(decision.rejected_proposals),
                merge_decision=decision.resolution_trace.get("merge_decision", "unknown"),
                resolution_time_ms=resolve_time_ms,
            ))
            
            # === STEP 5: Commit Decision ===
            self._blackboard.commit_decision(decision)
            
            self._event_bus.emit(DecisionCommittedEvent(
                turn_number=turn_number,
                action=decision.action,
                next_state=decision.next_state,
                reason_codes=decision.reason_codes,
            ))
            
            # Emit state transition event if state changed
            if decision.next_state != current_state:
                self._event_bus.emit(StateTransitionedEvent(
                    turn_number=turn_number,
                    from_state=current_state,
                    to_state=decision.next_state,
                    trigger_reason=", ".join(decision.reason_codes),
                ))
            
            turn_time_ms = (time.time() - turn_start_time) * 1000
            
            logger.info(
                f"Turn {turn_number} completed in {turn_time_ms:.1f}ms: "
                f"action={decision.action}, next_state={decision.next_state}"
            )
            
            return decision
            
        except Exception as e:
            logger.exception(f"Error processing turn {turn_number}: {e}")
            
            self._event_bus.emit(ErrorOccurredEvent(
                turn_number=turn_number,
                error_type=type(e).__name__,
                error_message=str(e),
                component="DialogueOrchestrator",
            ))
            
            # Return safe fallback
            return self._create_fallback_decision(
                current_state=current_state,
                reason="processing_error",
                turn_number=turn_number,
            )
    
    def _get_fallback_transition(self) -> Optional[str]:
        """
        Get fallback transition from "any" trigger in current state.
        
        Returns:
            Target state for "any" transition, or None
        """
        ctx = self._blackboard.get_context()
        return ctx.get_transition("any")
    
    def _create_fallback_decision(
        self,
        current_state: str,
        reason: str,
        turn_number: int,
    ) -> ResolvedDecision:
        """
        Create a safe fallback decision when processing fails.
        
        Args:
            current_state: Current dialogue state
            reason: Reason for fallback
            turn_number: Current turn number
            
        Returns:
            Safe ResolvedDecision that continues conversation
        """
        logger.warning(
            f"Creating fallback decision: reason={reason}, state={current_state}"
        )
        
        return ResolvedDecision(
            action="continue_current_goal",
            next_state=current_state,  # Stay in current state
            reason_codes=[f"fallback_{reason}"],
            rejected_proposals=[],
            resolution_trace={"fallback": True, "reason": reason},
        )
    
    def get_turn_summary(self) -> Dict[str, Any]:
        """Get summary of the last processed turn."""
        return self._blackboard.get_turn_summary()


# === Factory function for easy setup ===

def create_orchestrator(
    state_machine: 'IStateMachine',
    flow_config: 'IFlowConfig',
    persona_limits: Optional[Dict[str, Dict[str, int]]] = None,
    enable_metrics: bool = True,
    enable_debug_logging: bool = False,
    custom_sources: Optional[List[Type[KnowledgeSource]]] = None,
    tenant_config: Optional['TenantConfig'] = None,  # Multi-tenancy support
) -> DialogueOrchestrator:
    """
    Factory function to create a fully configured DialogueOrchestrator.

    This is the COMPOSITION ROOT for the Blackboard system (DESIGN_PRINCIPLES.md).
    All dependencies are wired here, not scattered throughout the codebase.

    Hexagonal Architecture:
        - state_machine must implement IStateMachine protocol
        - flow_config must implement IFlowConfig protocol
        - This allows easy testing with mock implementations

    Multi-Tenancy:
        Pass tenant_config to customize behavior per tenant.

    Args:
        state_machine: State machine implementing IStateMachine protocol
        flow_config: Flow config implementing IFlowConfig protocol
        persona_limits: Custom persona limits (uses defaults if None)
        enable_metrics: Whether to enable metrics collection
        enable_debug_logging: Whether to enable debug event logging
        custom_sources: Optional list of custom KnowledgeSource classes to register
        tenant_config: Tenant-specific configuration (optional)

    Returns:
        Configured DialogueOrchestrator instance

    Example:
        # Basic usage (uses all built-in sources)
        orchestrator = create_orchestrator(state_machine, flow_config)

        # With custom source
        class MyCustomSource(KnowledgeSource):
            ...

        orchestrator = create_orchestrator(
            state_machine,
            flow_config,
            custom_sources=[MyCustomSource]
        )

        # With tenant configuration
        tenant = TenantConfig(
            tenant_id="acme_corp",
            bot_name="ACME Sales Assistant",
            tone="friendly",
            features={"escalation": True},
        )
        orchestrator = create_orchestrator(
            state_machine,
            flow_config,
            tenant_config=tenant
        )
    """
    from .event_bus import MetricsCollector, DebugLogger
    from .protocols import DEFAULT_TENANT

    # Use default tenant if not provided
    tenant_config = tenant_config or DEFAULT_TENANT

    # Register custom sources if provided
    if custom_sources:
        for source_class in custom_sources:
            if not SourceRegistry.get_registration(source_class.__name__):
                SourceRegistry.register(
                    source_class,
                    priority_order=200,  # Custom sources run after built-in
                    description=f"Custom source: {source_class.__name__}"
                )
                logger.info(f"Registered custom source: {source_class.__name__}")

    # Create event bus
    event_bus = DialogueEventBus()

    # Add metrics collector
    if enable_metrics:
        metrics_collector = MetricsCollector()
        event_bus.subscribe_all(metrics_collector.handle_event)

    # Add debug logger
    if enable_debug_logging:
        debug_logger = DebugLogger()
        event_bus.subscribe_all(debug_logger.handle_event)

    # Create orchestrator (sources loaded via SourceRegistry)
    orchestrator = DialogueOrchestrator(
        state_machine=state_machine,
        flow_config=flow_config,
        event_bus=event_bus,
        enable_validation=True,
        persona_limits=persona_limits,
        tenant_config=tenant_config,
    )

    return orchestrator
Продолжаю с шестой частью — Configuration, Migration Plan и Testing.

продолжай
Часть 6: Configuration, Migration Plan и Testing
13. Configuration (YAML)
13.1 Обновление constants.yaml

# yaml_config/constants.yaml

# ==============================================================================
# BLACKBOARD SYSTEM CONFIGURATION
# ==============================================================================
#
# NOTE: Blackboard — ЕДИНСТВЕННАЯ система управления диалогом.
#       НЕТ feature flags для включения/выключения.
#       НЕТ shadow mode.
#       НЕТ gradual rollout.

blackboard:
  # Validation settings
  validation:
    enabled: true
    strict_mode: false  # Treat warnings as errors

  # Event bus settings
  event_bus:
    async_mode: false  # Set true for high-throughput scenarios
    history_size: 100

  # Default action when no proposals
  default_action: "continue_current_goal"

  # Debug logging (can be toggled without redeployment)
  debug_logging: false

# УДАЛЕНО (для справки):
# - enabled: flag — Blackboard ВСЕГДА включён
# - shadow_mode: — удалён полностью
# - shadow_mode_log_divergences: — удалён полностью

# ==============================================================================
# KNOWLEDGE SOURCES CONFIGURATION (Plugin System)
# ==============================================================================
# Each source can be enabled/disabled independently via configuration.
# Sources are loaded via SourceRegistry in priority_order.

sources:
  PriceQuestionSource:
    enabled: true
    priority_order: 10
    description: "Handles price-related questions with combinable actions"

  DataCollectorSource:
    enabled: true
    priority_order: 20
    description: "Tracks data completeness and proposes transitions"

  ObjectionGuardSource:
    enabled: true
    priority_order: 30
    description: "Monitors objection limits per persona"

  IntentProcessorSource:
    enabled: true
    priority_order: 40
    description: "Maps intents to actions via rules"

  TransitionResolverSource:
    enabled: true
    priority_order: 50
    description: "Handles intent-based state transitions"

  EscalationSource:
    enabled: true
    priority_order: 60
    description: "Detects escalation triggers for human handoff"

  # Example: To disable a source, set enabled: false
  # MyCustomSource:
  #   enabled: true
  #   priority_order: 200
  #   description: "Custom source for specific business logic"

# ==============================================================================
# PERSONA LIMITS (for ObjectionGuardSource)
# ==============================================================================

persona_limits:
  aggressive:
    consecutive_objections: 5
    total_objections: 8
    description: "Aggressive negotiators - allow more pushback"
    
  price_sensitive:
    consecutive_objections: 4
    total_objections: 7
    description: "Price-focused buyers - moderate tolerance"
    
  skeptical:
    consecutive_objections: 4
    total_objections: 6
    description: "Skeptical prospects - lower tolerance"
    
  busy:
    consecutive_objections: 2
    total_objections: 4
    description: "Time-constrained buyers - minimal tolerance"
    
  analytical:
    consecutive_objections: 4
    total_objections: 6
    description: "Detail-oriented buyers - moderate tolerance"
    
  friendly:
    consecutive_objections: 4
    total_objections: 7
    description: "Positive prospects - moderate tolerance"
    
  default:
    consecutive_objections: 3
    total_objections: 5
    description: "Default limits when persona not detected"

# ==============================================================================
# ESCALATION THRESHOLDS (for EscalationSource)
# ==============================================================================

escalation:
  frustration_threshold: 3      # Number of frustration signals
  misunderstanding_threshold: 4  # Number of "unclear" intents
  high_value_threshold: 100      # Company size for high-value treatment
  
  # Intents that trigger immediate escalation
  explicit_intents:
    - request_human
    - speak_to_manager
    - talk_to_person
    - need_help
    - real_person
    - human_please
    - escalate
    
  # Sensitive topics requiring human
  sensitive_intents:
    - legal_question
    - compliance_question
    - formal_complaint
    - refund_request
    - contract_dispute
    - data_deletion
    - gdpr_request

# ==============================================================================
# PRICE-RELATED INTENTS (for PriceQuestionSource)
# ==============================================================================

price_related_intents:
  - price_question
  - pricing_details
  - cost_inquiry
  - discount_request
  - payment_terms
  - pricing_comparison
  - budget_question
  - roi_question
  - total_cost_ownership

# ==============================================================================
# REASON CODES DOCUMENTATION
# ==============================================================================

reason_codes:
  # PriceQuestionSource
  price_question_priority:
    description: "Price-related question detected, answering with pricing info"
    source: "PriceQuestionSource"
    combinable: true
    
  # DataCollectorSource  
  data_complete:
    description: "All required data for current state collected"
    source: "DataCollectorSource"
    combinable: true
    
  # ObjectionGuardSource
  objection_limit_exceeded:
    description: "Persona-specific objection limit reached"
    source: "ObjectionGuardSource"
    combinable: false
    
  # IntentProcessorSource
  rule_matched:
    description: "Intent matched a rule in state configuration"
    source: "IntentProcessorSource"
    combinable: true
    
  # TransitionResolverSource
  intent_transition:
    description: "Explicit intent-to-transition mapping matched"
    source: "TransitionResolverSource"
    combinable: true
    
  # EscalationSource
  escalation_explicit_request:
    description: "User explicitly requested human assistance"
    source: "EscalationSource"
    combinable: false
    
  escalation_sensitive_topic:
    description: "Sensitive topic requiring human handling"
    source: "EscalationSource"
    combinable: false
    
  escalation_frustration_threshold:
    description: "User frustration threshold exceeded"
    source: "EscalationSource"
    combinable: false
    
  escalation_misunderstanding_threshold:
    description: "Too many misunderstandings in conversation"
    source: "EscalationSource"
    combinable: false
    
  # ConflictResolver
  fallback_any_transition:
    description: "No explicit transition, using 'any' fallback"
    source: "ConflictResolver"
    combinable: true

# ==============================================================================
# BLOCKING ACTIONS (combinable=False)
# ==============================================================================

blocking_actions:
  - handle_rejection
  - objection_limit_reached
  - escalate_to_human
  - emergency_escalate
  - end_conversation
  - hard_close

# ==============================================================================
# EXISTING CONFIGURATION (unchanged)
# ==============================================================================

limits:
  max_consecutive_objections: 3  # Legacy - use persona_limits instead
  max_total_objections: 5        # Legacy - use persona_limits instead
  max_gobacks: 2

circular_flow:
  allowed_gobacks:
    spin_implication: spin_situation
    spin_problem: greeting
    spin_need_payoff: spin_problem

# Intent categories (existing - unchanged)
intents:
  objection:
    - objection_price
    - objection_competitor
    - objection_timing
    - objection_authority
    - objection_need
    - objection_trust
    - objection_budget
    - objection_features
    - objection_complexity
    - objection_support
    - objection_integration
    - objection_security
    - objection_scalability
    - objection_contract
    - objection_implementation
    - objection_training
    - objection_roi
    - objection_change
    - objection_generic
    
  positive:
    - agreement
    - positive_feedback
    - interest_expressed
    - ready_to_proceed
    - schedule_meeting
    - request_demo
    - request_proposal
    - request_quote
    - confirm_understanding
    - appreciation
    # ... (rest of existing intents)
    
  question:
    - price_question
    - question_features
    - question_integration
    - question_support
    - question_security
    - question_timeline
    - question_process
    - question_comparison
    - question_customization
    - question_training
    # ... (rest of existing intents)
13.2 Feature Flags (settings.yaml update) — УПРОЩЁННАЯ ВЕРСИЯ

# settings.yaml (ПОСЛЕ МИГРАЦИИ)
#
# УДАЛЕНО всё что связано с legacy/blackboard switching:
# - blackboard_enabled (больше не нужен — всегда Blackboard)
# - blackboard_shadow_mode (удалён shadow mode)
# - blackboard_traffic_percentage (удалён gradual rollout)

feature_flags:
  # === EXISTING FLAGS (unchanged) ===
  tone_analysis: true           # Phase 2
  conversation_guard: true       # Phase 1
  objection_handler: true        # Phase 3
  lead_scoring: true             # Phase 3
  metrics_tracking: true         # Phase 0
  confidence_router: true        # Phase 4
  context_full_envelope: true    # Phase 5
  dialogue_policy: true          # Phase 5

  # === BLACKBOARD OPERATIONAL FLAGS ===
  # (НЕ для switching между системами — только для tuning)

  # Enable detailed Blackboard logging (for debugging)
  blackboard_debug_logging: false

  # Enable Blackboard metrics collection
  blackboard_metrics: true

  # Enable proposal validation
  blackboard_validation: true

# УДАЛЁННЫЕ FLAGS (для справки):
#
# blackboard_enabled: УДАЛЁН — Blackboard теперь единственная система
# blackboard_shadow_mode: УДАЛЁН — нет shadow mode
# blackboard_traffic_percentage: УДАЛЁН — нет gradual rollout
# blackboard_source_*: УДАЛЕНЫ — управление через constants.yaml
13.3 Добавление human_handoff state

# yaml_config/flows/_base/states.yaml (additions)

human_handoff:
  goal: "Передать разговор человеку"
  description: "Состояние эскалации к живому оператору"
  is_final: false
  is_escalation: true
  
  on_enter:
    action: "initiate_handoff"
    set_flags:
      escalated: true
      escalation_time: "{{timestamp}}"
      
  transitions:
    human_available: handoff_complete
    human_unavailable: handoff_delayed
    user_cancel: "{{previous_state}}"
    
  rules:
    any: "wait_for_handoff"
    
  metadata:
    sla_minutes: 5
    notification_channels:
      - slack
      - email

handoff_complete:
  goal: "Передача завершена"
  is_final: true
  
  on_enter:
    action: "confirm_handoff"
    
handoff_delayed:
  goal: "Оператор недоступен, ожидание"
  
  on_enter:
    action: "notify_delay"
    set_flags:
      handoff_delayed: true
      
  transitions:
    human_available: handoff_complete
    user_leave_contact: collect_callback
    timeout: soft_close
14. Integration with SalesBot (ПОЛНАЯ ЗАМЕНА)
14.1 Updated bot.py — БЕЗ LEGACY КОДА

# src/bot.py (ПОЛНАЯ ЗАМЕНА dialogue management)

from typing import Dict, Any, Optional
import logging

from src.state_machine import StateMachine
from src.config_loader import ConfigLoader

# Blackboard — ЕДИНСТВЕННАЯ система управления диалогом
from src.blackboard.orchestrator import DialogueOrchestrator, create_orchestrator
from src.blackboard.models import ResolvedDecision

logger = logging.getLogger(__name__)


class SalesBot:
    """
    Main Sales Bot class.

    Dialogue management полностью через Blackboard architecture.
    НЕТ legacy кода, НЕТ feature flags для переключения систем.
    """

    def __init__(
        self,
        config_loader: Optional[ConfigLoader] = None,
    ):
        """Initialize the bot."""
        self._config_loader = config_loader or ConfigLoader()

        # StateMachine используется ТОЛЬКО для хранения state и collected_data
        # apply_rules() УДАЛЁН
        self._state_machine = StateMachine(
            config_loader=self._config_loader,
        )

        # Blackboard orchestrator — единственная система dialogue management
        self._orchestrator = self._create_orchestrator()

        logger.info("SalesBot initialized with Blackboard architecture")

    def _create_orchestrator(self) -> DialogueOrchestrator:
        """
        Create the Blackboard orchestrator.
        """
        # Load persona limits from config
        constants = self._config_loader.load_constants()
        persona_limits = constants.get("persona_limits", {})

        # Convert to expected format
        formatted_limits = {}
        for persona, config in persona_limits.items():
            formatted_limits[persona] = {
                "consecutive": config.get("consecutive_objections", 3),
                "total": config.get("total_objections", 5),
            }

        return create_orchestrator(
            state_machine=self._state_machine,
            flow_config=self._config_loader.get_flow_config(),
            persona_limits=formatted_limits,
            enable_metrics=True,
            enable_debug_logging=False,  # Set True for debugging
        )

    @property
    def orchestrator(self) -> DialogueOrchestrator:
        """Get the orchestrator (for testing/debugging)."""
        return self._orchestrator

    def process(self, user_message: str) -> Dict[str, Any]:
        """
        Process a user message and generate a response.

        This is the main entry point for the bot.

        Args:
            user_message: The user's message

        Returns:
            Dict with response, intent, action, state, etc.
        """
        # ... (existing preprocessing code: tone analysis, guard, etc.)

        # Classify intent
        classification = self._classify_intent(user_message)
        intent = classification["intent"]
        extracted_data = classification.get("extracted_data", {})

        # Build context envelope
        context_envelope = self._build_context_envelope()

        # === DIALOGUE MANAGEMENT через Blackboard ===
        previous_state = self._state_machine.state

        decision = self._orchestrator.process_turn(
            intent=intent,
            extracted_data=extracted_data,
            context_envelope=context_envelope,
        )

        # Update state (if transition happened)
        if decision.next_state != previous_state:
            self._state_machine.state = decision.next_state
            logger.info(f"State transition: {previous_state} -> {decision.next_state}")

        # Log decision details
        logger.debug(
            f"Blackboard decision: action={decision.action}, "
            f"next_state={decision.next_state}, "
            f"reasons={decision.reason_codes}"
        )

        # Generate response
        response = self._generate_response(decision.action, context_envelope)

        # ... (existing postprocessing code: CTA, metrics, etc.)

        return {
            "response": response,
            "intent": intent,
            "action": decision.action,
            "state": decision.next_state,
            "previous_state": previous_state,
            "reason_codes": decision.reason_codes,  # NEW: visibility into decision
            "is_final": self._state_machine.is_final(),
            "collected_data": dict(self._state_machine.collected_data),
        }

    def get_turn_summary(self) -> Dict[str, Any]:
        """
        Get detailed summary of the last processed turn.

        Useful for debugging and analytics.
        """
        return self._orchestrator.get_turn_summary()


# УДАЛЁННЫЙ КОД (для справки что было убрано):
#
# - _process_legacy() — УДАЛЁН (использовал apply_rules)
# - _process_shadow_mode() — УДАЛЁН (сравнение систем)
# - _compare_shadow_results() — УДАЛЁН
# - _should_use_blackboard() — УДАЛЁН (всегда Blackboard)
# - _should_run_shadow_mode() — УДАЛЁН
# - get_shadow_stats() — УДАЛЁН
# - reset_shadow_stats() — УДАЛЁН
# - _shadow_stats dictionary — УДАЛЁН
# - FeatureFlags dependency для switching — УДАЛЁН
15. Migration Plan (Updated: 6-8 weeks) — ПОЛНАЯ ЗАМЕНА
15.1 Timeline Overview

ПРИНЦИП: Никакого legacy кода. StateMachine.apply_rules() удаляется полностью.
         Blackboard — единственная система управления диалогом.

Week 1-2:   Phase 1 - Foundation (Core implementation + Unit tests)
Week 3-4:   Phase 2 - Integration & Regression Testing
Week 5-6:   Phase 3 - Legacy Removal & Full Deployment
Week 7-8:   Phase 4 - Stabilization & Documentation (buffer)
15.2 Phase 1: Foundation (Week 1-2)
Goals:

Implement all Blackboard components
Unit tests for each component
Prepare integration points with SalesBot
Tasks:


Week 1:
├── Day 1-2: Core data structures
│   ├── src/blackboard/__init__.py
│   ├── src/blackboard/protocols.py (Hexagonal Architecture ports)
│   ├── src/blackboard/enums.py (Priority, ProposalType)
│   └── src/blackboard/models.py (Proposal, ResolvedDecision, ContextSnapshot)
│
├── Day 3-4: DialogueBlackboard
│   ├── src/blackboard/blackboard.py
│   └── tests/test_blackboard.py
│
└── Day 5: ProposalValidator & ConflictResolver
    ├── src/blackboard/proposal_validator.py
    ├── src/blackboard/conflict_resolver.py
    ├── tests/test_proposal_validator.py
    └── tests/test_conflict_resolver.py

Week 2:
├── Day 1-2: Knowledge Sources (Part 1) + Plugin System
│   ├── src/blackboard/knowledge_source.py (base class)
│   ├── src/blackboard/source_registry.py (Plugin System)
│   ├── tests/test_source_registry.py
│   ├── src/blackboard/sources/__init__.py (with auto-registration)
│   ├── src/blackboard/sources/price_question.py
│   ├── src/blackboard/sources/data_collector.py
│   └── tests/test_sources_part1.py
│
├── Day 3-4: Knowledge Sources (Part 2)
│   ├── src/blackboard/sources/objection_guard.py
│   ├── src/blackboard/sources/intent_processor.py
│   ├── src/blackboard/sources/transition_resolver.py
│   ├── src/blackboard/sources/escalation.py
│   └── tests/test_sources_part2.py
│
└── Day 5: EventBus & Orchestrator
    ├── src/blackboard/event_bus.py
    ├── src/blackboard/orchestrator.py
    └── tests/test_orchestrator.py

Deliverables:

Complete /src/blackboard/ module
100% unit test coverage for new code

Risk Mitigation:

Comprehensive test suite before any integration
All tests must pass before Phase 2
15.3 Phase 2: Integration & Regression Testing (Week 3-4)
Goals:

Integrate Blackboard with SalesBot (replace apply_rules)
Comprehensive regression tests
Ensure behavioral parity for correct scenarios, improvements for buggy ones
Tasks:


Week 3:
├── Day 1-2: SalesBot Integration
│   ├── Modify src/bot.py to use DialogueOrchestrator
│   ├── Remove ALL calls to StateMachine.apply_rules()
│   ├── Update response generation to work with ResolvedDecision
│   └── tests/test_bot_integration.py
│
├── Day 3-4: Integration tests
│   ├── tests/test_blackboard_integration.py
│   ├── Test full pipeline: user_message → response
│   ├── Test all Knowledge Source combinations
│   └── Test all SPIN phases
│
└── Day 5: Edge case tests
    ├── tests/test_blackboard_edge_cases.py
    ├── Empty proposals
    ├── All sources disabled
    ├── Validation errors
    └── Error recovery

Week 4:
├── Day 1-2: Regression testing
│   ├── tests/test_blackboard_regression.py
│   ├── Port ALL existing state_machine tests
│   ├── Document expected behavioral differences (bugs fixed)
│   └── Ensure improvements work correctly
│
├── Day 3-4: Historical replay & Performance
│   ├── scripts/replay_conversations.py
│   ├── Replay historical conversations through new system
│   ├── Verify improvements (price_question + data_complete)
│   ├── scripts/benchmark_blackboard.py
│   └── Measure latency, memory
│
└── Day 5: Bug fixes
    └── Address any issues found during testing

Deliverables:

Working SalesBot with Blackboard (no legacy)
Full test suite (unit + integration + regression)
Performance benchmark results
Historical replay report showing improvements

Success Criteria:

All tests pass
Known bugs (price_question blocking) are fixed
Latency overhead < 10ms per turn
No regressions in correct behavior
15.4 Phase 3: Legacy Removal & Full Deployment (Week 5-6)
Goals:

ПОЛНОСТЬЮ удалить legacy код (apply_rules и связанное)
Развернуть новую систему в production
Убрать все feature flags переключения между системами
Tasks:


Week 5:
├── Day 1-2: Legacy Code Removal
│   ├── DELETE: StateMachine.apply_rules() method
│   ├── DELETE: StateMachine._check_data_complete()
│   ├── DELETE: StateMachine._process_intent_rules()
│   ├── DELETE: All priority-based rule processing in state_machine.py
│   ├── KEEP: StateMachine.state, collected_data, is_final() (used by Blackboard)
│   ├── KEEP: IntentTracker (used by Blackboard)
│   └── Update imports throughout codebase
│
├── Day 3-4: Configuration Cleanup
│   ├── REMOVE: feature flags for legacy/blackboard switching
│   ├── REMOVE: shadow_mode configuration
│   ├── REMOVE: blackboard_traffic_percentage
│   ├── UPDATE: constants.yaml (keep only Blackboard config)
│   ├── UPDATE: settings.yaml (remove legacy flags)
│   └── SIMPLIFY: bot.py (remove all legacy code paths)
│
└── Day 5: Final Integration Testing
    ├── Run full test suite
    ├── Manual smoke testing of all scenarios
    └── Verify no references to deleted code

Week 6:
├── Day 1-2: Production Deployment
│   ├── Deploy to staging environment
│   ├── Full QA testing on staging
│   ├── Deploy to production
│   └── Monitor closely for first 48 hours
│
├── Day 3-4: Production Monitoring
│   ├── Monitor error rates
│   ├── Monitor conversation metrics
│   ├── Monitor performance metrics
│   └── Address any production issues
│
└── Day 5: Phase 3 Complete
    ├── Confirm stable operation
    └── Document deployment results

Deliverables:

Clean codebase with NO legacy dialogue management code
Production deployment of Blackboard system
Monitoring dashboards

Success Criteria:

Zero references to apply_rules() in codebase
All tests pass after legacy removal
Production stable for 48+ hours
No increase in error rates

DELETED CODE (comprehensive list):

# src/state_machine.py — УДАЛИТЬ:
- apply_rules() method (~200 lines)
- _check_data_complete() method
- _process_intent_rules() method
- _evaluate_rule_conditions() method
- _get_priority_action() method
- All RuleResult related code

# src/bot.py — УДАЛИТЬ:
- _process_legacy() method
- _process_shadow_mode() method
- _compare_shadow_results() method
- _should_use_blackboard() method
- _should_run_shadow_mode() method
- get_shadow_stats() method
- reset_shadow_stats() method
- _shadow_stats dictionary
- All conditional logic choosing between systems

# yaml_config/settings.yaml — УДАЛИТЬ:
- blackboard_enabled flag
- blackboard_shadow_mode flag
- blackboard_traffic_percentage flag
- All legacy/blackboard switching flags

# yaml_config/constants.yaml — УДАЛИТЬ:
- shadow_mode section
- Any legacy-specific configuration
15.5 Phase 4: Stabilization & Documentation (Week 7-8) — BUFFER
Goals:

Стабилизация production системы
Документация новой архитектуры
Обучение команды
Оптимизация по результатам мониторинга
Tasks:


Week 7:
├── Day 1-2: Production Optimization
│   ├── Analyze production metrics
│   ├── Identify and fix any performance bottlenecks
│   ├── Tune Knowledge Source configurations
│   └── Optimize based on real usage patterns
│
├── Day 3-4: Documentation
│   ├── Architecture documentation (как работает Blackboard)
│   ├── Knowledge Source development guide
│   ├── Troubleshooting guide
│   ├── Runbook updates
│   └── API documentation for DialogueOrchestrator
│
└── Day 5: Code Quality
    ├── Code review всего нового кода
    ├── Ensure consistent code style
    └── Add any missing docstrings/comments

Week 8:
├── Day 1-2: Knowledge Transfer
│   ├── Team training session
│   ├── Q&A sessions
│   ├── Pair programming на добавление нового Knowledge Source
│   └── Review best practices
│
├── Day 3-4: Final Polish
│   ├── Address any feedback from documentation review
│   ├── Final test suite review
│   ├── Performance optimization if needed
│   └── Clean up any TODO comments
│
└── Day 5: Project Completion
    ├── Final documentation review
    ├── Project retrospective
    ├── Archive old documentation
    └── Celebrate successful migration! 🎉

Deliverables:

Stable production system (2+ weeks running)
Complete documentation
Team trained on new architecture
Clean, maintainable codebase

Success Criteria:

No production incidents for 2 weeks
All team members can explain Blackboard architecture
At least one team member can add a new Knowledge Source independently
Documentation complete and reviewed
15.6 Rollback Strategy (Emergency Only)

ВАЖНО: В этом плане нет постепенного отката. Если нужен откат — это git revert.

Rollback Procedure (EMERGENCY ONLY):

# Если обнаружена критическая проблема после deployment:

# 1. Git revert к последнему стабильному коммиту
git revert HEAD~N  # где N = количество коммитов Blackboard

# 2. Или переключиться на pre-blackboard branch
git checkout pre-blackboard-migration
git push -f origin main

# 3. Redeploy
kubectl rollout restart deployment/salesbot

Когда использовать откат:

- Критические баги, влияющие на >10% пользователей
- Полная неработоспособность бота
- Data corruption

Когда НЕ откатывать:

- Мелкие баги (исправить в hotfix)
- Производительность чуть хуже (оптимизировать)
- Один-два edge cases не работают (исправить)

Pre-deployment Checklist (чтобы избежать отката):

- [ ] Все unit tests проходят
- [ ] Все integration tests проходят
- [ ] Все regression tests проходят
- [ ] Historical replay показывает улучшения
- [ ] Performance benchmark в пределах нормы
- [ ] Manual testing всех основных сценариев
- [ ] Code review пройден
16. File Structure Summary

=== НОВЫЕ ФАЙЛЫ (создаются) ===

src/blackboard/
├── __init__.py                    # Module exports
├── protocols.py                   # Hexagonal Architecture ports (IStateMachine, IFlowConfig, ITenantConfig)
├── enums.py                       # Priority, ProposalType enums
├── models.py                      # Proposal, ResolvedDecision, ContextSnapshot
├── blackboard.py                  # DialogueBlackboard class
├── knowledge_source.py            # KnowledgeSource ABC
├── source_registry.py             # SourceRegistry (Plugin System)
├── conflict_resolver.py           # ConflictResolver class
├── proposal_validator.py          # ProposalValidator class
├── event_bus.py                   # DialogueEventBus, events, subscribers
├── orchestrator.py                # DialogueOrchestrator, factory function
└── sources/
    ├── __init__.py                # Source exports + auto-registration
    ├── price_question.py          # PriceQuestionSource
    ├── data_collector.py          # DataCollectorSource
    ├── objection_guard.py         # ObjectionGuardSource
    ├── intent_processor.py        # IntentProcessorSource
    ├── transition_resolver.py     # TransitionResolverSource
    └── escalation.py              # EscalationSource

tests/
├── test_protocols.py              # Protocol compliance tests
├── test_blackboard.py             # DialogueBlackboard tests
├── test_conflict_resolver.py      # ConflictResolver tests
├── test_proposal_validator.py     # ProposalValidator tests
├── test_event_bus.py              # EventBus tests
├── test_orchestrator.py           # Orchestrator tests
├── test_source_registry.py        # SourceRegistry tests
├── test_sources_price.py          # PriceQuestionSource tests
├── test_sources_data.py           # DataCollectorSource tests
├── test_sources_objection.py      # ObjectionGuardSource tests
├── test_sources_intent.py         # IntentProcessorSource tests
├── test_sources_transition.py     # TransitionResolverSource tests
├── test_sources_escalation.py     # EscalationSource tests
├── test_blackboard_integration.py # Integration tests
├── test_blackboard_regression.py  # Regression tests
└── test_multi_tenancy.py          # Multi-tenancy isolation tests

=== МОДИФИЦИРУЕМЫЕ ФАЙЛЫ ===

src/bot.py                         # ПЕРЕПИСАН: использует только Blackboard
src/state_machine.py               # ОЧИЩЕН: удалён apply_rules() и связанный код
yaml_config/constants.yaml         # ОБНОВЛЁН: Blackboard config
yaml_config/settings.yaml          # ОЧИЩЕН: удалены legacy flags

=== УДАЛЯЕМЫЙ КОД (из существующих файлов) ===

# src/state_machine.py — УДАЛИТЬ (~300 строк):
StateMachine.apply_rules()         # Основной метод legacy системы
StateMachine._check_data_complete()
StateMachine._process_intent_rules()
StateMachine._evaluate_rule_conditions()
StateMachine._get_priority_action()
StateMachine._apply_rule_result()
RuleResult class                   # Если определён здесь

# src/bot.py — УДАЛИТЬ (~150 строк):
SalesBot._process_legacy()
SalesBot._process_shadow_mode()
SalesBot._compare_shadow_results()
SalesBot._should_use_blackboard()
SalesBot._should_run_shadow_mode()
SalesBot.get_shadow_stats()
SalesBot.reset_shadow_stats()
SalesBot._shadow_stats

# yaml_config/settings.yaml — УДАЛИТЬ:
blackboard_enabled
blackboard_shadow_mode
blackboard_traffic_percentage

=== ЧТО ОСТАЁТСЯ В state_machine.py ===

# StateMachine используется Blackboard для:
StateMachine.state                 # property: текущее состояние
StateMachine.collected_data        # property: собранные данные
StateMachine.is_final()            # method: проверка финального состояния
StateMachine._intent_tracker       # IntentTracker instance

# IntentTracker остаётся полностью:
IntentTracker.turn_number
IntentTracker.prev_intent
IntentTracker.record()
IntentTracker.objection_consecutive()
IntentTracker.objection_total()
IntentTracker.total_count()
IntentTracker.category_total()
Продолжаю с седьмой частью — Testing Suite и Verification.

продолжай
Часть 7: Testing Suite и Verification
17. Unit Tests
17.0 Test Protocols (Hexagonal Architecture)

# tests/test_protocols.py

"""
Tests for Protocol compliance (Hexagonal Architecture).

These tests verify that concrete implementations properly implement
the required protocols, ensuring Dependency Inversion principle.
"""

import pytest
from typing import Dict, Any, Optional

from src.blackboard.protocols import (
    IStateMachine,
    IIntentTracker,
    IFlowConfig,
    ITenantConfig,
    TenantConfig,
    DEFAULT_TENANT,
)


class TestProtocolCompliance:
    """Test that concrete classes implement protocols correctly."""

    def test_state_machine_implements_protocol(self):
        """Verify StateMachine implements IStateMachine protocol."""
        from src.state_machine import StateMachine

        # Runtime check using isinstance with runtime_checkable protocol
        sm = StateMachine()
        assert isinstance(sm, IStateMachine), (
            "StateMachine must implement IStateMachine protocol"
        )

    def test_intent_tracker_implements_protocol(self):
        """Verify IntentTracker implements IIntentTracker protocol."""
        from src.intent_tracker import IntentTracker

        tracker = IntentTracker()
        assert isinstance(tracker, IIntentTracker), (
            "IntentTracker must implement IIntentTracker protocol"
        )

    def test_flow_config_implements_protocol(self):
        """Verify FlowConfig implements IFlowConfig protocol."""
        from src.config_loader import FlowConfig

        config = FlowConfig(states={}, constants={})
        assert isinstance(config, IFlowConfig), (
            "FlowConfig must implement IFlowConfig protocol"
        )


class TestTenantConfig:
    """Test TenantConfig implementation."""

    def test_default_tenant_exists(self):
        """Verify DEFAULT_TENANT is available."""
        assert DEFAULT_TENANT is not None
        assert DEFAULT_TENANT.tenant_id == "default"

    def test_tenant_config_creation(self):
        """Test creating custom tenant config."""
        tenant = TenantConfig(
            tenant_id="acme_corp",
            bot_name="ACME Assistant",
            tone="friendly",
            features={"escalation": True, "price_questions": False},
            persona_limits_override={
                "aggressive": {"consecutive": 10, "total": 15}
            },
        )

        assert tenant.tenant_id == "acme_corp"
        assert tenant.bot_name == "ACME Assistant"
        assert tenant.tone == "friendly"
        assert tenant.features["escalation"] is True
        assert tenant.features["price_questions"] is False
        assert tenant.persona_limits_override["aggressive"]["consecutive"] == 10

    def test_tenant_config_default_features(self):
        """Test that features defaults to empty dict."""
        tenant = TenantConfig(tenant_id="test")
        assert tenant.features == {}

    def test_tenant_implements_protocol(self):
        """Verify TenantConfig implements ITenantConfig protocol."""
        tenant = TenantConfig(tenant_id="test")
        assert isinstance(tenant, ITenantConfig)


class TestMockImplementations:
    """Test that mock implementations work with protocols."""

    def test_mock_state_machine_for_testing(self):
        """
        Demonstrate how to create a mock that implements IStateMachine.

        This is useful for unit testing without real StateMachine.
        """
        class MockStateMachine:
            def __init__(self):
                self._state = "greeting"
                self._collected_data = {}
                self._intent_tracker = MockIntentTracker()

            @property
            def state(self) -> str:
                return self._state

            @state.setter
            def state(self, value: str) -> None:
                self._state = value

            @property
            def collected_data(self) -> Dict[str, Any]:
                return self._collected_data

            def is_final(self) -> bool:
                return self._state == "closed"

        class MockIntentTracker:
            @property
            def turn_number(self) -> int:
                return 1

            @property
            def prev_intent(self) -> Optional[str]:
                return None

            def record(self, intent: str, state: str) -> None:
                pass

            def objection_consecutive(self) -> int:
                return 0

            def objection_total(self) -> int:
                return 0

            def total_count(self, intent: str) -> int:
                return 0

            def category_total(self, category: str) -> int:
                return 0

        mock_sm = MockStateMachine()
        assert isinstance(mock_sm, IStateMachine)

        # Use mock in DialogueBlackboard
        from src.blackboard.blackboard import DialogueBlackboard
        from src.blackboard.protocols import DEFAULT_TENANT

        class MockFlowConfig:
            @property
            def states(self) -> Dict[str, Dict[str, Any]]:
                return {"greeting": {"goal": "Test"}}

            def to_dict(self) -> Dict[str, Any]:
                return {"states": self.states}

        bb = DialogueBlackboard(
            state_machine=mock_sm,
            flow_config=MockFlowConfig(),
            tenant_config=DEFAULT_TENANT,
        )
        assert bb.tenant_id == "default"

17.1 Test DialogueBlackboard

# tests/test_blackboard.py

import pytest
from unittest.mock import Mock, MagicMock
from datetime import datetime

from src.blackboard.blackboard import DialogueBlackboard
from src.blackboard.models import Proposal, ContextSnapshot
from src.blackboard.enums import Priority, ProposalType
from src.blackboard.protocols import TenantConfig, DEFAULT_TENANT


class TestDialogueBlackboard:
    """Test suite for DialogueBlackboard class."""
    
    @pytest.fixture
    def mock_state_machine(self):
        """Create a mock state machine."""
        sm = Mock()
        sm.state = "spin_situation"
        sm.collected_data = {"company_size": "50"}
        sm._intent_tracker = Mock()
        sm._intent_tracker.turn_number = 5
        sm._intent_tracker.prev_intent = "greeting"
        sm._intent_tracker.objection_consecutive.return_value = 0
        sm._intent_tracker.objection_total.return_value = 0
        return sm
    
    @pytest.fixture
    def mock_flow_config(self):
        """Create a mock flow config."""
        config = Mock()
        config.states = {
            "spin_situation": {
                "goal": "Understand situation",
                "phase": "situation",
                "required_data": ["company_size"],
                "transitions": {
                    "data_complete": "spin_problem",
                    "rejection": "soft_close",
                },
                "rules": {
                    "unclear": "probe_situation",
                },
            },
            "spin_problem": {
                "goal": "Identify problems",
                "phase": "problem",
            },
            "soft_close": {
                "goal": "Graceful exit",
                "is_final": True,
            },
        }
        return config
    
    @pytest.fixture
    def blackboard(self, mock_state_machine, mock_flow_config):
        """Create a blackboard instance."""
        return DialogueBlackboard(
            state_machine=mock_state_machine,
            flow_config=mock_flow_config,
        )
    
    # === begin_turn tests ===
    
    def test_begin_turn_initializes_context(self, blackboard, mock_state_machine):
        """begin_turn should create a ContextSnapshot."""
        blackboard.begin_turn(
            intent="price_question",
            extracted_data={"pain_point": "no analytics"},
            context_envelope=None,
        )
        
        ctx = blackboard.get_context()
        
        assert ctx.state == "spin_situation"
        assert ctx.current_intent == "price_question"
        assert ctx.collected_data["company_size"] == "50"
        assert ctx.collected_data["pain_point"] == "no analytics"
    
    def test_begin_turn_records_intent(self, blackboard, mock_state_machine):
        """begin_turn should record intent in tracker."""
        blackboard.begin_turn(
            intent="price_question",
            extracted_data={},
            context_envelope=None,
        )
        
        mock_state_machine._intent_tracker.record.assert_called_once_with(
            "price_question", "spin_situation"
        )
    
    def test_begin_turn_clears_previous_proposals(self, blackboard):
        """begin_turn should clear previous proposals."""
        # Add some proposals
        blackboard.begin_turn("intent1", {}, None)
        blackboard.propose_action("action1", Priority.HIGH)
        blackboard.propose_transition("state1", Priority.NORMAL)
        
        assert len(blackboard.get_proposals()) == 2
        
        # Begin new turn
        blackboard.begin_turn("intent2", {}, None)
        
        assert len(blackboard.get_proposals()) == 0
    
    def test_begin_turn_merges_extracted_data(self, blackboard, mock_state_machine):
        """begin_turn should merge new data with existing."""
        mock_state_machine.collected_data = {"field1": "value1"}
        
        blackboard.begin_turn(
            intent="test",
            extracted_data={"field2": "value2"},
            context_envelope=None,
        )
        
        ctx = blackboard.get_context()
        assert ctx.collected_data["field1"] == "value1"
        assert ctx.collected_data["field2"] == "value2"
    
    def test_begin_turn_does_not_overwrite_with_empty(self, blackboard, mock_state_machine):
        """begin_turn should not overwrite with empty values."""
        mock_state_machine.collected_data = {"field1": "original"}
        
        blackboard.begin_turn(
            intent="test",
            extracted_data={"field1": "", "field2": None},
            context_envelope=None,
        )
        
        ctx = blackboard.get_context()
        assert ctx.collected_data["field1"] == "original"
        assert "field2" not in ctx.collected_data or ctx.collected_data["field2"] is None
    
    # === get_context tests ===
    
    def test_get_context_before_begin_turn_raises(self, blackboard):
        """get_context should raise if called before begin_turn."""
        with pytest.raises(RuntimeError, match="before begin_turn"):
            blackboard.get_context()
    
    def test_get_context_returns_immutable_snapshot(self, blackboard):
        """get_context should return frozen dataclass."""
        blackboard.begin_turn("test", {}, None)
        ctx = blackboard.get_context()
        
        # ContextSnapshot is frozen, should not allow modification
        with pytest.raises(AttributeError):
            ctx.state = "new_state"
    
    # === propose_action tests ===
    
    def test_propose_action_adds_to_proposals(self, blackboard):
        """propose_action should add action proposal."""
        blackboard.begin_turn("test", {}, None)
        
        blackboard.propose_action(
            action="answer_with_pricing",
            priority=Priority.HIGH,
            combinable=True,
            reason_code="price_question",
            source_name="TestSource",
        )
        
        proposals = blackboard.get_action_proposals()
        assert len(proposals) == 1
        assert proposals[0].type == ProposalType.ACTION
        assert proposals[0].value == "answer_with_pricing"
        assert proposals[0].priority == Priority.HIGH
        assert proposals[0].combinable == True
        assert proposals[0].reason_code == "price_question"
        assert proposals[0].source_name == "TestSource"
    
    def test_propose_action_default_combinable_true(self, blackboard):
        """propose_action should default combinable to True."""
        blackboard.begin_turn("test", {}, None)
        
        blackboard.propose_action("action", Priority.NORMAL)
        
        proposals = blackboard.get_action_proposals()
        assert proposals[0].combinable == True
    
    def test_propose_action_blocking(self, blackboard):
        """propose_action with combinable=False creates blocking action."""
        blackboard.begin_turn("test", {}, None)
        
        blackboard.propose_action(
            action="handle_rejection",
            priority=Priority.CRITICAL,
            combinable=False,
            reason_code="rejection",
            source_name="TestSource",
        )
        
        proposals = blackboard.get_action_proposals()
        assert proposals[0].combinable == False
    
    # === propose_transition tests ===
    
    def test_propose_transition_adds_to_proposals(self, blackboard):
        """propose_transition should add transition proposal."""
        blackboard.begin_turn("test", {}, None)
        
        blackboard.propose_transition(
            next_state="spin_problem",
            priority=Priority.NORMAL,
            reason_code="data_complete",
            source_name="TestSource",
        )
        
        proposals = blackboard.get_transition_proposals()
        assert len(proposals) == 1
        assert proposals[0].type == ProposalType.TRANSITION
        assert proposals[0].value == "spin_problem"
        assert proposals[0].priority == Priority.NORMAL
    
    def test_propose_transition_always_combinable(self, blackboard):
        """Transitions should always be combinable."""
        blackboard.begin_turn("test", {}, None)
        
        blackboard.propose_transition("state", Priority.HIGH)
        
        proposals = blackboard.get_transition_proposals()
        assert proposals[0].combinable == True
    
    # === get_proposals tests ===
    
    def test_get_proposals_returns_all(self, blackboard):
        """get_proposals should return actions and transitions."""
        blackboard.begin_turn("test", {}, None)
        
        blackboard.propose_action("action1", Priority.HIGH)
        blackboard.propose_action("action2", Priority.LOW)
        blackboard.propose_transition("state1", Priority.NORMAL)
        
        all_proposals = blackboard.get_proposals()
        assert len(all_proposals) == 3
    
    def test_get_action_proposals_filters(self, blackboard):
        """get_action_proposals should return only actions."""
        blackboard.begin_turn("test", {}, None)
        
        blackboard.propose_action("action1", Priority.HIGH)
        blackboard.propose_transition("state1", Priority.NORMAL)
        
        action_proposals = blackboard.get_action_proposals()
        assert len(action_proposals) == 1
        assert action_proposals[0].type == ProposalType.ACTION
    
    def test_get_transition_proposals_filters(self, blackboard):
        """get_transition_proposals should return only transitions."""
        blackboard.begin_turn("test", {}, None)
        
        blackboard.propose_action("action1", Priority.HIGH)
        blackboard.propose_transition("state1", Priority.NORMAL)
        
        transition_proposals = blackboard.get_transition_proposals()
        assert len(transition_proposals) == 1
        assert transition_proposals[0].type == ProposalType.TRANSITION
    
    # === commit_decision tests ===
    
    def test_commit_decision_stores_decision(self, blackboard):
        """commit_decision should store the decision."""
        from src.blackboard.models import ResolvedDecision
        
        blackboard.begin_turn("test", {}, None)
        
        decision = ResolvedDecision(
            action="answer_with_pricing",
            next_state="spin_problem",
            reason_codes=["price_question", "data_complete"],
        )
        
        blackboard.commit_decision(decision)
        
        stored = blackboard.get_decision()
        assert stored.action == "answer_with_pricing"
        assert stored.next_state == "spin_problem"
        assert "price_question" in stored.reason_codes
    
    def test_commit_decision_applies_data_updates(self, blackboard, mock_state_machine):
        """commit_decision should apply data updates to state machine."""
        from src.blackboard.models import ResolvedDecision
        
        blackboard.begin_turn("test", {}, None)
        
        decision = ResolvedDecision(
            action="test",
            next_state="test",
            data_updates={"new_field": "new_value"},
        )
        
        blackboard.commit_decision(decision)
        
        assert mock_state_machine.collected_data["new_field"] == "new_value"


class TestContextSnapshot:
    """Test suite for ContextSnapshot helper methods."""
    
    @pytest.fixture
    def context_snapshot(self):
        """Create a ContextSnapshot for testing."""
        mock_tracker = Mock()
        mock_tracker.prev_intent = "previous"
        mock_tracker.objection_consecutive.return_value = 2
        mock_tracker.objection_total.return_value = 5
        
        return ContextSnapshot(
            state="spin_situation",
            collected_data={"company_size": "50", "pain_point": ""},
            current_intent="price_question",
            intent_tracker=mock_tracker,
            context_envelope=None,
            turn_number=10,
            persona="default",
            state_config={
                "required_data": ["company_size", "industry"],
                "optional_data": ["pain_point"],
                "transitions": {
                    "data_complete": "spin_problem",
                    "rejection": "soft_close",
                },
                "phase": "situation",
            },
            flow_config={},
        )
    
    def test_last_intent_property(self, context_snapshot):
        """last_intent should return prev_intent from tracker."""
        assert context_snapshot.last_intent == "previous"
    
    def test_objection_consecutive_property(self, context_snapshot):
        """objection_consecutive should delegate to tracker."""
        assert context_snapshot.objection_consecutive == 2
    
    def test_objection_total_property(self, context_snapshot):
        """objection_total should delegate to tracker."""
        assert context_snapshot.objection_total == 5
    
    def test_required_data_property(self, context_snapshot):
        """required_data should return from state_config."""
        assert context_snapshot.required_data == ["company_size", "industry"]
    
    def test_get_missing_required_data(self, context_snapshot):
        """get_missing_required_data should return uncollected fields."""
        missing = context_snapshot.get_missing_required_data()
        assert "industry" in missing
        assert "company_size" not in missing  # Already collected
    
    def test_has_all_required_data_false(self, context_snapshot):
        """has_all_required_data should return False if missing."""
        assert context_snapshot.has_all_required_data() == False
    
    def test_get_transition(self, context_snapshot):
        """get_transition should return target state."""
        assert context_snapshot.get_transition("data_complete") == "spin_problem"
        assert context_snapshot.get_transition("rejection") == "soft_close"
        assert context_snapshot.get_transition("nonexistent") is None
    
    def test_current_phase_property(self, context_snapshot):
        """current_phase should return phase from state_config."""
        assert context_snapshot.current_phase == "situation"


class TestMultiTenancy:
    """Test multi-tenancy support in DialogueBlackboard."""

    @pytest.fixture
    def mock_state_machine(self):
        """Create a mock state machine."""
        sm = Mock()
        sm.state = "greeting"
        sm.collected_data = {}
        sm._intent_tracker = Mock()
        sm._intent_tracker.turn_number = 1
        sm._intent_tracker.prev_intent = None
        sm._intent_tracker.objection_consecutive.return_value = 0
        sm._intent_tracker.objection_total.return_value = 0
        return sm

    @pytest.fixture
    def mock_flow_config(self):
        """Create a mock flow config."""
        config = Mock()
        config.states = {"greeting": {"goal": "Greet user"}}
        config.to_dict.return_value = {
            "states": config.states,
            "persona_limits": {
                "aggressive": {"consecutive": 5, "total": 8},
                "default": {"consecutive": 3, "total": 5},
            }
        }
        return config

    def test_default_tenant_when_not_provided(self, mock_state_machine, mock_flow_config):
        """Blackboard should use DEFAULT_TENANT when none provided."""
        bb = DialogueBlackboard(
            state_machine=mock_state_machine,
            flow_config=mock_flow_config,
        )
        assert bb.tenant_id == "default"

    def test_custom_tenant_config(self, mock_state_machine, mock_flow_config):
        """Blackboard should use provided tenant config."""
        tenant = TenantConfig(
            tenant_id="acme_corp",
            bot_name="ACME Bot",
            tone="friendly",
        )
        bb = DialogueBlackboard(
            state_machine=mock_state_machine,
            flow_config=mock_flow_config,
            tenant_config=tenant,
        )
        assert bb.tenant_id == "acme_corp"
        assert bb.tenant_config.bot_name == "ACME Bot"

    def test_tenant_in_context_snapshot(self, mock_state_machine, mock_flow_config):
        """ContextSnapshot should include tenant information."""
        tenant = TenantConfig(tenant_id="test_tenant")
        bb = DialogueBlackboard(
            state_machine=mock_state_machine,
            flow_config=mock_flow_config,
            tenant_config=tenant,
        )
        bb.begin_turn("greeting", {})
        ctx = bb.get_context()

        assert ctx.tenant_id == "test_tenant"
        assert ctx.tenant_config is not None

    def test_tenant_persona_limit_override(self, mock_state_machine, mock_flow_config):
        """Tenant can override persona limits."""
        # Tenant with custom limits for aggressive persona
        tenant = TenantConfig(
            tenant_id="enterprise",
            persona_limits_override={
                "aggressive": {"consecutive": 10, "total": 20},
            }
        )
        bb = DialogueBlackboard(
            state_machine=mock_state_machine,
            flow_config=mock_flow_config,
            tenant_config=tenant,
        )
        bb.begin_turn("greeting", {})
        ctx = bb.get_context()

        # Tenant override should take precedence
        assert ctx.get_persona_limit("aggressive", "consecutive") == 10
        assert ctx.get_persona_limit("aggressive", "total") == 20

        # Non-overridden persona falls back to global
        assert ctx.get_persona_limit("default", "consecutive") == 3

    def test_tenant_feature_flags(self, mock_state_machine, mock_flow_config):
        """Tenant can have custom feature flags."""
        tenant = TenantConfig(
            tenant_id="basic_tier",
            features={
                "escalation": False,  # Disabled for this tenant
                "price_questions": True,
            }
        )
        bb = DialogueBlackboard(
            state_machine=mock_state_machine,
            flow_config=mock_flow_config,
            tenant_config=tenant,
        )
        bb.begin_turn("greeting", {})
        ctx = bb.get_context()

        assert ctx.is_tenant_feature_enabled("escalation") is False
        assert ctx.is_tenant_feature_enabled("price_questions") is True
        # Unknown features default to True
        assert ctx.is_tenant_feature_enabled("unknown_feature") is True

17.2 Test ConflictResolver

# tests/test_conflict_resolver.py

import pytest
from src.blackboard.conflict_resolver import ConflictResolver
from src.blackboard.models import Proposal
from src.blackboard.enums import Priority, ProposalType


class TestConflictResolver:
    """Test suite for ConflictResolver class."""
    
    @pytest.fixture
    def resolver(self):
        """Create a ConflictResolver instance."""
        return ConflictResolver(default_action="continue")
    
    # === Basic resolution tests ===
    
    def test_no_proposals_returns_defaults(self, resolver):
        """No proposals should return default action and current state."""
        decision = resolver.resolve([], "spin_situation")
        
        assert decision.action == "continue"
        assert decision.next_state == "spin_situation"
    
    def test_single_action_proposal(self, resolver):
        """Single action proposal should win."""
        proposals = [
            Proposal(
                type=ProposalType.ACTION,
                value="answer_with_pricing",
                priority=Priority.HIGH,
                source_name="TestSource",
                reason_code="test",
            )
        ]
        
        decision = resolver.resolve(proposals, "spin_situation")
        
        assert decision.action == "answer_with_pricing"
        assert decision.next_state == "spin_situation"
    
    def test_single_transition_proposal(self, resolver):
        """Single transition proposal should win."""
        proposals = [
            Proposal(
                type=ProposalType.TRANSITION,
                value="spin_problem",
                priority=Priority.NORMAL,
                source_name="TestSource",
                reason_code="test",
            )
        ]
        
        decision = resolver.resolve(proposals, "spin_situation")
        
        assert decision.action == "continue"
        assert decision.next_state == "spin_problem"
    
    # === Priority tests ===
    
    def test_higher_priority_action_wins(self, resolver):
        """Higher priority action should win over lower."""
        proposals = [
            Proposal(
                type=ProposalType.ACTION,
                value="low_priority_action",
                priority=Priority.LOW,
                source_name="Source1",
                reason_code="low",
            ),
            Proposal(
                type=ProposalType.ACTION,
                value="high_priority_action",
                priority=Priority.HIGH,
                source_name="Source2",
                reason_code="high",
            ),
        ]
        
        decision = resolver.resolve(proposals, "state")
        
        assert decision.action == "high_priority_action"
        assert len(decision.rejected_proposals) == 1
        assert decision.rejected_proposals[0].value == "low_priority_action"
    
    def test_critical_beats_high(self, resolver):
        """CRITICAL priority should beat HIGH."""
        proposals = [
            Proposal(
                type=ProposalType.ACTION,
                value="high_action",
                priority=Priority.HIGH,
                source_name="Source1",
                reason_code="high",
            ),
            Proposal(
                type=ProposalType.ACTION,
                value="critical_action",
                priority=Priority.CRITICAL,
                source_name="Source2",
                reason_code="critical",
            ),
        ]
        
        decision = resolver.resolve(proposals, "state")
        
        assert decision.action == "critical_action"
    
    def test_higher_priority_transition_wins(self, resolver):
        """Higher priority transition should win over lower."""
        proposals = [
            Proposal(
                type=ProposalType.TRANSITION,
                value="low_state",
                priority=Priority.LOW,
                source_name="Source1",
                reason_code="low",
            ),
            Proposal(
                type=ProposalType.TRANSITION,
                value="high_state",
                priority=Priority.HIGH,
                source_name="Source2",
                reason_code="high",
            ),
        ]
        
        decision = resolver.resolve(proposals, "current")
        
        assert decision.next_state == "high_state"
    
    # === Combinable flag tests (CRITICAL) ===
    
    def test_combinable_true_merges_action_and_transition(self, resolver):
        """combinable=True should allow action + transition merge."""
        proposals = [
            Proposal(
                type=ProposalType.ACTION,
                value="answer_with_pricing",
                priority=Priority.HIGH,
                source_name="PriceSource",
                reason_code="price",
                combinable=True,  # KEY!
            ),
            Proposal(
                type=ProposalType.TRANSITION,
                value="spin_problem",
                priority=Priority.NORMAL,
                source_name="DataSource",
                reason_code="data_complete",
            ),
        ]
        
        decision = resolver.resolve(proposals, "spin_situation")
        
        # BOTH should be applied
        assert decision.action == "answer_with_pricing"
        assert decision.next_state == "spin_problem"
        assert "price" in decision.reason_codes
        assert "data_complete" in decision.reason_codes
    
    def test_combinable_false_blocks_transitions(self, resolver):
        """combinable=False should block all transitions."""
        proposals = [
            Proposal(
                type=ProposalType.ACTION,
                value="handle_rejection",
                priority=Priority.HIGH,
                source_name="RejectionSource",
                reason_code="rejection",
                combinable=False,  # BLOCKING!
            ),
            Proposal(
                type=ProposalType.TRANSITION,
                value="spin_problem",
                priority=Priority.NORMAL,
                source_name="DataSource",
                reason_code="data_complete",
            ),
        ]
        
        decision = resolver.resolve(proposals, "spin_situation")
        
        # Action wins, transition is BLOCKED
        assert decision.action == "handle_rejection"
        assert decision.next_state == "spin_situation"  # NO TRANSITION!
        assert len(decision.rejected_proposals) == 1
        assert decision.rejected_proposals[0].value == "spin_problem"
    
    def test_combinable_false_blocks_multiple_transitions(self, resolver):
        """combinable=False should block ALL transitions."""
        proposals = [
            Proposal(
                type=ProposalType.ACTION,
                value="escalate_to_human",
                priority=Priority.CRITICAL,
                source_name="EscalationSource",
                reason_code="escalation",
                combinable=False,
            ),
            Proposal(
                type=ProposalType.TRANSITION,
                value="spin_problem",
                priority=Priority.NORMAL,
                source_name="DataSource",
                reason_code="data_complete",
            ),
            Proposal(
                type=ProposalType.TRANSITION,
                value="soft_close",
                priority=Priority.HIGH,
                source_name="OtherSource",
                reason_code="other",
            ),
        ]
        
        decision = resolver.resolve(proposals, "spin_situation")
        
        assert decision.action == "escalate_to_human"
        assert decision.next_state == "spin_situation"
        assert len(decision.rejected_proposals) == 2  # Both transitions rejected
    
    # === The Core Problem Test ===
    
    def test_price_question_with_data_complete_both_applied(self, resolver):
        """
        THIS IS THE CORE TEST.
        
        Scenario: User asks price question while providing final required data.
        Expected: Answer price question AND transition to next phase.
        
        This was the bug in legacy system where price_question early-returned
        and blocked the data_complete transition.
        """
        proposals = [
            # PriceQuestionSource proposes action with combinable=True
            Proposal(
                type=ProposalType.ACTION,
                value="answer_with_pricing",
                priority=Priority.HIGH,
                source_name="PriceQuestionSource",
                reason_code="price_question_priority",
                combinable=True,
            ),
            # DataCollectorSource proposes transition (data is complete)
            Proposal(
                type=ProposalType.TRANSITION,
                value="spin_problem",
                priority=Priority.NORMAL,
                source_name="DataCollectorSource",
                reason_code="data_complete",
            ),
        ]
        
        decision = resolver.resolve(proposals, "spin_situation")
        
        # CRITICAL ASSERTIONS:
        assert decision.action == "answer_with_pricing", \
            "Bot should answer the price question"
        assert decision.next_state == "spin_problem", \
            "Bot should ALSO transition to next phase (NOT stay in spin_situation)"
        assert "price_question_priority" in decision.reason_codes
        assert "data_complete" in decision.reason_codes
        assert len(decision.rejected_proposals) == 0, \
            "Nothing should be rejected when combinable=True"
    
    # === Reason codes tests ===
    
    def test_reason_codes_include_winners(self, resolver):
        """reason_codes should include winning action and transition codes."""
        proposals = [
            Proposal(
                type=ProposalType.ACTION,
                value="action",
                priority=Priority.HIGH,
                source_name="S1",
                reason_code="reason_action",
                combinable=True,
            ),
            Proposal(
                type=ProposalType.TRANSITION,
                value="state",
                priority=Priority.NORMAL,
                source_name="S2",
                reason_code="reason_transition",
            ),
        ]
        
        decision = resolver.resolve(proposals, "current")
        
        assert "reason_action" in decision.reason_codes
        assert "reason_transition" in decision.reason_codes
    
    # === Resolution trace tests ===
    
    def test_resolution_trace_populated(self, resolver):
        """resolution_trace should contain debug information."""
        proposals = [
            Proposal(
                type=ProposalType.ACTION,
                value="action",
                priority=Priority.HIGH,
                source_name="Source",
                reason_code="reason",
                combinable=True,
            ),
        ]
        
        decision = resolver.resolve(proposals, "state")
        
        assert "action_proposals_count" in decision.resolution_trace
        assert "merge_decision" in decision.resolution_trace
    
    # === Fallback transition tests ===
    
    def test_resolve_with_fallback_applies_fallback(self, resolver):
        """resolve_with_fallback should apply fallback when no transition."""
        proposals = [
            Proposal(
                type=ProposalType.ACTION,
                value="some_action",
                priority=Priority.NORMAL,
                source_name="Source",
                reason_code="reason",
                combinable=True,
            ),
            # No transition proposal
        ]
        
        decision = resolver.resolve_with_fallback(
            proposals=proposals,
            current_state="spin_situation",
            fallback_transition="spin_problem",  # "any" transition
        )
        
        assert decision.next_state == "spin_problem"
        assert "fallback_any_transition" in decision.reason_codes
    
    def test_resolve_with_fallback_no_fallback_if_transition_exists(self, resolver):
        """resolve_with_fallback should not apply fallback if transition exists."""
        proposals = [
            Proposal(
                type=ProposalType.TRANSITION,
                value="explicit_state",
                priority=Priority.NORMAL,
                source_name="Source",
                reason_code="explicit",
            ),
        ]
        
        decision = resolver.resolve_with_fallback(
            proposals=proposals,
            current_state="current",
            fallback_transition="fallback_state",
        )
        
        assert decision.next_state == "explicit_state"
        assert "fallback_any_transition" not in decision.reason_codes
    
    def test_resolve_with_fallback_blocked_by_non_combinable(self, resolver):
        """resolve_with_fallback should not apply fallback if action blocks it."""
        proposals = [
            Proposal(
                type=ProposalType.ACTION,
                value="blocking_action",
                priority=Priority.HIGH,
                source_name="Source",
                reason_code="blocking",
                combinable=False,  # Blocks fallback
            ),
        ]
        
        decision = resolver.resolve_with_fallback(
            proposals=proposals,
            current_state="current",
            fallback_transition="fallback_state",
        )
        
        assert decision.next_state == "current"  # Fallback not applied
17.3 Test Knowledge Sources

# tests/test_sources_price.py

import pytest
from unittest.mock import Mock, MagicMock

from src.blackboard.sources.price_question import PriceQuestionSource
from src.blackboard.blackboard import DialogueBlackboard
from src.blackboard.enums import Priority, ProposalType


class TestPriceQuestionSource:
    """Test suite for PriceQuestionSource."""
    
    @pytest.fixture
    def source(self):
        """Create a PriceQuestionSource instance."""
        return PriceQuestionSource()
    
    @pytest.fixture
    def mock_blackboard(self):
        """Create a mock blackboard."""
        bb = Mock(spec=DialogueBlackboard)
        bb.current_intent = "price_question"
        
        ctx = Mock()
        ctx.current_intent = "price_question"
        ctx.collected_data = {}
        bb.get_context.return_value = ctx
        
        return bb
    
    def test_should_contribute_true_for_price_question(self, source, mock_blackboard):
        """should_contribute returns True for price_question intent."""
        mock_blackboard.current_intent = "price_question"
        
        assert source.should_contribute(mock_blackboard) == True
    
    def test_should_contribute_true_for_pricing_details(self, source, mock_blackboard):
        """should_contribute returns True for pricing_details intent."""
        mock_blackboard.current_intent = "pricing_details"
        
        assert source.should_contribute(mock_blackboard) == True
    
    def test_should_contribute_false_for_other_intents(self, source, mock_blackboard):
        """should_contribute returns False for non-price intents."""
        mock_blackboard.current_intent = "greeting"
        
        assert source.should_contribute(mock_blackboard) == False
    
    def test_should_contribute_false_when_disabled(self, source, mock_blackboard):
        """should_contribute returns False when source is disabled."""
        source.disable()
        mock_blackboard.current_intent = "price_question"
        
        assert source.should_contribute(mock_blackboard) == False
    
    def test_contribute_proposes_answer_with_pricing(self, source, mock_blackboard):
        """contribute should propose answer_with_pricing action."""
        source.contribute(mock_blackboard)
        
        mock_blackboard.propose_action.assert_called_once()
        call_kwargs = mock_blackboard.propose_action.call_args[1]
        
        assert call_kwargs["action"] == "answer_with_pricing"
        assert call_kwargs["priority"] == Priority.HIGH
        assert call_kwargs["combinable"] == True  # CRITICAL!
        assert call_kwargs["reason_code"] == "price_question_priority"
    
    def test_contribute_proposes_discount_handler_for_discount_request(self, source, mock_blackboard):
        """contribute should propose handle_discount_request for discount intent."""
        mock_blackboard.current_intent = "discount_request"
        ctx = mock_blackboard.get_context.return_value
        ctx.current_intent = "discount_request"
        
        source.contribute(mock_blackboard)
        
        call_kwargs = mock_blackboard.propose_action.call_args[1]
        assert call_kwargs["action"] == "handle_discount_request"
    
    def test_combinable_flag_is_true(self, source, mock_blackboard):
        """
        CRITICAL TEST: combinable must be True.
        
        This ensures price questions don't block data_complete transitions.
        """
        source.contribute(mock_blackboard)
        
        call_kwargs = mock_blackboard.propose_action.call_args[1]
        assert call_kwargs["combinable"] == True, \
            "PriceQuestionSource MUST set combinable=True to allow transitions"


# tests/test_sources_data.py

class TestDataCollectorSource:
    """Test suite for DataCollectorSource."""
    
    @pytest.fixture
    def source(self):
        """Create a DataCollectorSource instance."""
        from src.blackboard.sources.data_collector import DataCollectorSource
        return DataCollectorSource()
    
    @pytest.fixture
    def mock_blackboard(self):
        """Create a mock blackboard with context."""
        bb = Mock(spec=DialogueBlackboard)
        
        ctx = Mock()
        ctx.state_config = {
            "required_data": ["company_size", "industry"],
            "is_final": False,
            "transitions": {
                "data_complete": "spin_problem",
            },
        }
        ctx.required_data = ["company_size", "industry"]
        ctx.collected_data = {"company_size": "50"}  # Missing industry
        ctx.get_transition = lambda trigger: ctx.state_config["transitions"].get(trigger)
        
        bb.get_context.return_value = ctx
        
        return bb
    
    def test_should_contribute_true_when_required_data_exists(self, source, mock_blackboard):
        """should_contribute returns True when state has required_data."""
        assert source.should_contribute(mock_blackboard) == True
    
    def test_should_contribute_false_when_no_required_data(self, source, mock_blackboard):
        """should_contribute returns False when no required_data defined."""
        ctx = mock_blackboard.get_context.return_value
        ctx.state_config = {"required_data": [], "is_final": False}
        ctx.required_data = []
        
        assert source.should_contribute(mock_blackboard) == False
    
    def test_should_contribute_false_when_final_state(self, source, mock_blackboard):
        """should_contribute returns False for final states."""
        ctx = mock_blackboard.get_context.return_value
        ctx.state_config["is_final"] = True
        
        assert source.should_contribute(mock_blackboard) == False
    
    def test_contribute_no_proposal_when_data_missing(self, source, mock_blackboard):
        """contribute should not propose if data is missing."""
        # Missing industry
        source.contribute(mock_blackboard)
        
        mock_blackboard.propose_transition.assert_not_called()
    
    def test_contribute_proposes_transition_when_data_complete(self, source, mock_blackboard):
        """contribute should propose transition when all data collected."""
        ctx = mock_blackboard.get_context.return_value
        ctx.collected_data = {"company_size": "50", "industry": "tech"}  # All data!
        
        source.contribute(mock_blackboard)
        
        mock_blackboard.propose_transition.assert_called_once()
        call_kwargs = mock_blackboard.propose_transition.call_args[1]
        
        assert call_kwargs["next_state"] == "spin_problem"
        assert call_kwargs["reason_code"] == "data_complete"
        assert call_kwargs["priority"] == Priority.NORMAL


# tests/test_sources_objection.py

class TestObjectionGuardSource:
    """Test suite for ObjectionGuardSource."""
    
    @pytest.fixture
    def source(self):
        """Create an ObjectionGuardSource with test limits."""
        from src.blackboard.sources.objection_guard import ObjectionGuardSource
        return ObjectionGuardSource(
            persona_limits={
                "aggressive": {"consecutive": 5, "total": 8},
                "busy": {"consecutive": 2, "total": 4},
                "default": {"consecutive": 3, "total": 5},
            }
        )
    
    @pytest.fixture
    def mock_blackboard(self):
        """Create a mock blackboard."""
        bb = Mock(spec=DialogueBlackboard)
        bb.current_intent = "objection_price"
        
        ctx = Mock()
        ctx.current_intent = "objection_price"
        ctx.persona = "default"
        ctx.objection_consecutive = 1
        ctx.objection_total = 2
        
        bb.get_context.return_value = ctx
        
        return bb
    
    def test_should_contribute_true_for_objection(self, source, mock_blackboard):
        """should_contribute returns True for objection intents."""
        assert source.should_contribute(mock_blackboard) == True
    
    def test_should_contribute_false_for_non_objection(self, source, mock_blackboard):
        """should_contribute returns False for non-objection intents."""
        mock_blackboard.current_intent = "greeting"
        
        assert source.should_contribute(mock_blackboard) == False
    
    def test_contribute_no_proposal_when_within_limits(self, source, mock_blackboard):
        """contribute should not propose if within limits."""
        ctx = mock_blackboard.get_context.return_value
        ctx.objection_consecutive = 1
        ctx.objection_total = 2
        # Default limits: consecutive=3, total=5
        
        source.contribute(mock_blackboard)
        
        mock_blackboard.propose_action.assert_not_called()
        mock_blackboard.propose_transition.assert_not_called()
    
    def test_contribute_proposes_when_consecutive_exceeded(self, source, mock_blackboard):
        """contribute should propose soft_close when consecutive limit exceeded."""
        ctx = mock_blackboard.get_context.return_value
        ctx.objection_consecutive = 3  # Equals default limit
        ctx.objection_total = 3
        
        source.contribute(mock_blackboard)
        
        # Should propose BLOCKING action
        mock_blackboard.propose_action.assert_called_once()
        action_kwargs = mock_blackboard.propose_action.call_args[1]
        assert action_kwargs["action"] == "objection_limit_reached"
        assert action_kwargs["combinable"] == False  # BLOCKING!
        
        # Should propose transition
        mock_blackboard.propose_transition.assert_called_once()
        trans_kwargs = mock_blackboard.propose_transition.call_args[1]
        assert trans_kwargs["next_state"] == "soft_close"
    
    def test_contribute_proposes_when_total_exceeded(self, source, mock_blackboard):
        """contribute should propose soft_close when total limit exceeded."""
        ctx = mock_blackboard.get_context.return_value
        ctx.objection_consecutive = 1
        ctx.objection_total = 5  # Equals default limit
        
        source.contribute(mock_blackboard)
        
        mock_blackboard.propose_action.assert_called_once()
        mock_blackboard.propose_transition.assert_called_once()
    
    def test_contribute_uses_persona_limits(self, source, mock_blackboard):
        """contribute should use persona-specific limits."""
        ctx = mock_blackboard.get_context.return_value
        ctx.persona = "busy"  # Stricter limits: consecutive=2, total=4
        ctx.objection_consecutive = 2  # Equals busy limit
        ctx.objection_total = 2
        
        source.contribute(mock_blackboard)
        
        # Should trigger because busy limit is 2
        mock_blackboard.propose_action.assert_called_once()
    
    def test_contribute_uses_default_for_unknown_persona(self, source, mock_blackboard):
        """contribute should use default limits for unknown persona."""
        ctx = mock_blackboard.get_context.return_value
        ctx.persona = "unknown_persona"
        ctx.objection_consecutive = 3  # Default limit
        ctx.objection_total = 3
        
        source.contribute(mock_blackboard)
        
        mock_blackboard.propose_action.assert_called_once()

17.3.1 Test SourceRegistry (Plugin System)

# tests/test_source_registry.py

import pytest
from unittest.mock import Mock

from src.blackboard.source_registry import (
    SourceRegistry,
    SourceRegistration,
    register_source,
)
from src.blackboard.knowledge_source import KnowledgeSource


class TestSourceRegistry:
    """Test suite for SourceRegistry (Plugin System)."""

    @pytest.fixture(autouse=True)
    def reset_registry(self):
        """Reset registry before each test."""
        SourceRegistry.reset()
        yield
        SourceRegistry.reset()

    def test_register_source_class(self):
        """register should add source to registry."""
        class TestSource(KnowledgeSource):
            def contribute(self, bb):
                pass

        SourceRegistry.register(TestSource, name="TestSource")

        assert "TestSource" in SourceRegistry.list_registered()

    def test_register_with_priority_order(self):
        """Sources should be listed in priority_order."""
        class Source1(KnowledgeSource):
            def contribute(self, bb):
                pass

        class Source2(KnowledgeSource):
            def contribute(self, bb):
                pass

        SourceRegistry.register(Source1, name="Source1", priority_order=20)
        SourceRegistry.register(Source2, name="Source2", priority_order=10)

        registered = SourceRegistry.list_registered()
        assert registered[0] == "Source2"  # Lower priority = earlier
        assert registered[1] == "Source1"

    def test_register_rejects_non_knowledge_source(self):
        """register should reject non-KnowledgeSource classes."""
        class NotASource:
            pass

        with pytest.raises(TypeError):
            SourceRegistry.register(NotASource)

    def test_register_rejects_duplicate_name_when_frozen(self):
        """register should reject duplicate names when frozen."""
        class TestSource(KnowledgeSource):
            def contribute(self, bb):
                pass

        SourceRegistry.register(TestSource, name="TestSource")
        SourceRegistry.freeze()

        with pytest.raises(ValueError):
            SourceRegistry.register(TestSource, name="TestSource")

    def test_unregister_source(self):
        """unregister should remove source from registry."""
        class TestSource(KnowledgeSource):
            def contribute(self, bb):
                pass

        SourceRegistry.register(TestSource, name="TestSource")
        assert "TestSource" in SourceRegistry.list_registered()

        result = SourceRegistry.unregister("TestSource")

        assert result == True
        assert "TestSource" not in SourceRegistry.list_registered()

    def test_create_sources_returns_instances(self):
        """create_sources should return KnowledgeSource instances."""
        class TestSource(KnowledgeSource):
            def contribute(self, bb):
                pass

        SourceRegistry.register(TestSource, name="TestSource")

        sources = SourceRegistry.create_sources()

        assert len(sources) == 1
        assert isinstance(sources[0], TestSource)
        assert sources[0].name == "TestSource"

    def test_create_sources_respects_enabled_config(self):
        """create_sources should respect enabled flag in config."""
        class Source1(KnowledgeSource):
            def contribute(self, bb):
                pass

        class Source2(KnowledgeSource):
            def contribute(self, bb):
                pass

        SourceRegistry.register(Source1, name="Source1")
        SourceRegistry.register(Source2, name="Source2")

        config = {
            "sources": {
                "Source1": {"enabled": True},
                "Source2": {"enabled": False},  # Disabled!
            }
        }

        sources = SourceRegistry.create_sources(config=config)

        assert len(sources) == 1
        assert sources[0].name == "Source1"

    def test_create_sources_uses_default_enabled(self):
        """create_sources should use enabled_by_default if not in config."""
        class EnabledSource(KnowledgeSource):
            def contribute(self, bb):
                pass

        class DisabledSource(KnowledgeSource):
            def contribute(self, bb):
                pass

        SourceRegistry.register(
            EnabledSource, name="EnabledSource", enabled_by_default=True
        )
        SourceRegistry.register(
            DisabledSource, name="DisabledSource", enabled_by_default=False
        )

        sources = SourceRegistry.create_sources()

        assert len(sources) == 1
        assert sources[0].name == "EnabledSource"

    def test_create_sources_passes_config_to_source(self):
        """create_sources should pass source_configs to source __init__."""
        class ConfigurableSource(KnowledgeSource):
            def __init__(self, name: str, custom_param: str = "default"):
                super().__init__(name)
                self.custom_param = custom_param

            def contribute(self, bb):
                pass

        SourceRegistry.register(ConfigurableSource, name="ConfigurableSource")

        source_configs = {
            "ConfigurableSource": {"custom_param": "custom_value"}
        }

        sources = SourceRegistry.create_sources(source_configs=source_configs)

        assert sources[0].custom_param == "custom_value"

    def test_create_sources_maintains_priority_order(self):
        """create_sources should return sources in priority_order."""
        class Source1(KnowledgeSource):
            def contribute(self, bb):
                pass

        class Source2(KnowledgeSource):
            def contribute(self, bb):
                pass

        class Source3(KnowledgeSource):
            def contribute(self, bb):
                pass

        SourceRegistry.register(Source1, name="Source1", priority_order=30)
        SourceRegistry.register(Source2, name="Source2", priority_order=10)
        SourceRegistry.register(Source3, name="Source3", priority_order=20)

        sources = SourceRegistry.create_sources()

        assert sources[0].name == "Source2"  # priority 10
        assert sources[1].name == "Source3"  # priority 20
        assert sources[2].name == "Source1"  # priority 30


class TestRegisterSourceDecorator:
    """Test suite for @register_source decorator."""

    @pytest.fixture(autouse=True)
    def reset_registry(self):
        """Reset registry before each test."""
        SourceRegistry.reset()
        yield
        SourceRegistry.reset()

    def test_decorator_registers_class(self):
        """@register_source should register the decorated class."""
        @register_source(priority_order=15)
        class DecoratedSource(KnowledgeSource):
            def contribute(self, bb):
                pass

        assert "DecoratedSource" in SourceRegistry.list_registered()
        reg = SourceRegistry.get_registration("DecoratedSource")
        assert reg.priority_order == 15

    def test_decorator_with_custom_name(self):
        """@register_source should support custom name."""
        @register_source(name="CustomName", priority_order=25)
        class DecoratedSource(KnowledgeSource):
            def contribute(self, bb):
                pass

        assert "CustomName" in SourceRegistry.list_registered()

    def test_decorator_preserves_class(self):
        """@register_source should return the original class."""
        @register_source()
        class DecoratedSource(KnowledgeSource):
            def contribute(self, bb):
                pass

        # Should still be usable as a class
        instance = DecoratedSource(name="test")
        assert isinstance(instance, KnowledgeSource)

17.4 Test Orchestrator Integration

# tests/test_orchestrator.py

import pytest
from unittest.mock import Mock, MagicMock, patch

from src.blackboard.orchestrator import DialogueOrchestrator, create_orchestrator
from src.blackboard.models import ResolvedDecision
from src.blackboard.enums import Priority


class TestDialogueOrchestrator:
    """Test suite for DialogueOrchestrator."""
    
    @pytest.fixture
    def mock_state_machine(self):
        """Create a mock state machine."""
        sm = Mock()
        sm.state = "spin_situation"
        sm.collected_data = {}
        sm._intent_tracker = Mock()
        sm._intent_tracker.turn_number = 0
        sm._intent_tracker.record = Mock()
        sm._intent_tracker.prev_intent = None
        sm._intent_tracker.objection_consecutive.return_value = 0
        sm._intent_tracker.objection_total.return_value = 0
        sm._intent_tracker.total_count.return_value = 0
        sm._intent_tracker.category_total.return_value = 0
        return sm
    
    @pytest.fixture
    def mock_flow_config(self):
        """Create a mock flow config."""
        config = Mock()
        config.states = {
            "spin_situation": {
                "goal": "Understand situation",
                "phase": "situation",
                "required_data": ["company_size"],
                "is_final": False,
                "transitions": {
                    "data_complete": "spin_problem",
                    "rejection": "soft_close",
                    "any": "spin_problem",
                },
                "rules": {},
            },
            "spin_problem": {
                "goal": "Identify problems",
                "phase": "problem",
                "required_data": [],
                "is_final": False,
                "transitions": {},
                "rules": {},
            },
            "soft_close": {
                "goal": "Graceful exit",
                "is_final": True,
                "transitions": {},
                "rules": {},
            },
        }
        return config
    
    @pytest.fixture
    def orchestrator(self, mock_state_machine, mock_flow_config):
        """Create an orchestrator instance."""
        return DialogueOrchestrator(
            state_machine=mock_state_machine,
            flow_config=mock_flow_config,
            enable_validation=True,
        )
    
    # === Basic processing tests ===
    
    def test_process_turn_returns_decision(self, orchestrator):
        """process_turn should return a ResolvedDecision."""
        decision = orchestrator.process_turn(
            intent="greeting",
            extracted_data={},
            context_envelope=None,
        )
        
        assert isinstance(decision, ResolvedDecision)
        assert decision.action is not None
        assert decision.next_state is not None
    
    def test_process_turn_records_intent(self, orchestrator, mock_state_machine):
        """process_turn should record intent in tracker."""
        orchestrator.process_turn(
            intent="test_intent",
            extracted_data={},
            context_envelope=None,
        )
        
        mock_state_machine._intent_tracker.record.assert_called()
    
    # === The Core Problem Test ===
    
    def test_price_question_with_data_complete_scenario(self, orchestrator, mock_state_machine):
        """
        CORE INTEGRATION TEST.
        
        Scenario:
        - Current state: spin_situation (requires company_size)
        - User message: "У нас 15 человек. Сколько стоит?"
        - Intent: price_question
        - Extracted data: {company_size: "15"}
        
        Expected:
        - Action: answer_with_pricing (answer the price question)
        - Next state: spin_problem (data is now complete, transition!)
        """
        mock_state_machine.state = "spin_situation"
        mock_state_machine.collected_data = {}  # No data yet
        
        decision = orchestrator.process_turn(
            intent="price_question",
            extracted_data={"company_size": "15"},
            context_envelope=None,
        )
        
        # CRITICAL ASSERTIONS
        assert decision.action == "answer_with_pricing", \
            "Should answer the price question"
        assert decision.next_state == "spin_problem", \
            "Should ALSO transition to next phase (data is complete)"
        assert "price_question_priority" in decision.reason_codes
        assert "data_complete" in decision.reason_codes
    
    def test_price_question_without_complete_data(self, orchestrator, mock_state_machine):
        """Price question without completing data should not transition."""
        mock_state_machine.state = "spin_situation"
        mock_state_machine.collected_data = {}  # No data
        
        decision = orchestrator.process_turn(
            intent="price_question",
            extracted_data={},  # No new data either
            context_envelope=None,
        )
        
        assert decision.action == "answer_with_pricing"
        # No transition because data not complete
        # (will use fallback "any" transition or stay in state)
    
    # === Objection limit tests ===
    
    def test_objection_limit_triggers_soft_close(self, orchestrator, mock_state_machine):
        """Exceeding objection limit should trigger soft_close."""
        mock_state_machine._intent_tracker.objection_consecutive.return_value = 3
        mock_state_machine._intent_tracker.objection_total.return_value = 5
        
        decision = orchestrator.process_turn(
            intent="objection_price",
            extracted_data={},
            context_envelope=None,
        )
        
        assert decision.action == "objection_limit_reached"
        assert decision.next_state == "soft_close"
    
    # === Source management tests ===
    
    def test_add_source(self, orchestrator):
        """add_source should add a new Knowledge Source."""
        from src.blackboard.knowledge_source import KnowledgeSource
        
        class CustomSource(KnowledgeSource):
            def contribute(self, bb):
                pass
        
        custom = CustomSource("CustomSource")
        initial_count = len(orchestrator.sources)
        
        orchestrator.add_source(custom)
        
        assert len(orchestrator.sources) == initial_count + 1
    
    def test_remove_source(self, orchestrator):
        """remove_source should remove a Knowledge Source."""
        initial_count = len(orchestrator.sources)
        
        result = orchestrator.remove_source("PriceQuestionSource")
        
        assert result == True
        assert len(orchestrator.sources) == initial_count - 1
    
    # === Error handling tests ===
    
    def test_process_turn_handles_source_error(self, orchestrator):
        """process_turn should handle errors in Knowledge Sources."""
        # Add a failing source
        from src.blackboard.knowledge_source import KnowledgeSource
        
        class FailingSource(KnowledgeSource):
            def should_contribute(self, bb):
                return True
            def contribute(self, bb):
                raise ValueError("Test error")
        
        orchestrator.add_source(FailingSource("FailingSource"))
        
        # Should not raise, should return fallback
        decision = orchestrator.process_turn(
            intent="test",
            extracted_data={},
            context_envelope=None,
        )
        
        assert decision is not None
    
    # === Factory function tests ===
    
    def test_create_orchestrator_factory(self, mock_state_machine, mock_flow_config):
        """create_orchestrator should create configured orchestrator."""
        orchestrator = create_orchestrator(
            state_machine=mock_state_machine,
            flow_config=mock_flow_config,
            enable_metrics=True,
            enable_debug_logging=True,
        )

        assert orchestrator is not None
        # Sources are loaded via SourceRegistry (6 built-in sources)
        assert len(orchestrator.sources) == 6

    def test_create_orchestrator_with_custom_source(self, mock_state_machine, mock_flow_config):
        """create_orchestrator should support custom sources via Plugin System."""
        from src.blackboard.knowledge_source import KnowledgeSource
        from src.blackboard.source_registry import SourceRegistry

        # Reset registry to ensure clean state
        SourceRegistry.reset()

        class MyCustomSource(KnowledgeSource):
            """Custom source for testing."""
            def contribute(self, blackboard):
                pass

        orchestrator = create_orchestrator(
            state_machine=mock_state_machine,
            flow_config=mock_flow_config,
            custom_sources=[MyCustomSource],
        )

        # Should have built-in sources + custom source
        source_names = [s.name for s in orchestrator.sources]
        assert "MyCustomSource" in source_names

    def test_orchestrator_loads_sources_from_registry(self, mock_state_machine, mock_flow_config):
        """DialogueOrchestrator should load sources from SourceRegistry."""
        orchestrator = create_orchestrator(
            state_machine=mock_state_machine,
            flow_config=mock_flow_config,
        )

        # Verify sources are in priority_order
        source_names = [s.name for s in orchestrator.sources]
        assert source_names[0] == "PriceQuestionSource"  # priority 10
        assert "DataCollectorSource" in source_names
        assert "EscalationSource" in source_names
18. Integration Tests

# tests/test_blackboard_integration.py

import pytest
from unittest.mock import Mock

from src.blackboard.orchestrator import DialogueOrchestrator
from src.blackboard.blackboard import DialogueBlackboard
from src.blackboard.conflict_resolver import ConflictResolver
from src.blackboard.sources.price_question import PriceQuestionSource
from src.blackboard.sources.data_collector import DataCollectorSource
from src.blackboard.sources.objection_guard import ObjectionGuardSource


class TestBlackboardIntegration:
    """
    Integration tests for the complete Blackboard system.
    
    These tests verify end-to-end behavior with real components
    (not mocks) to ensure the system works as designed.
    """
    
    @pytest.fixture
    def real_state_machine(self):
        """Create a real (or near-real) state machine."""
        from src.state_machine import StateMachine
        from src.config_loader import ConfigLoader
        
        # Use real config loader
        config_loader = ConfigLoader()
        sm = StateMachine(config_loader=config_loader)
        sm.state = "spin_situation"
        
        return sm
    
    @pytest.fixture
    def real_flow_config(self):
        """Load real flow config."""
        from src.config_loader import ConfigLoader
        
        config_loader = ConfigLoader()
        return config_loader.get_flow_config()
    
    # === Scenario Tests ===
    
    def test_scenario_price_question_with_data(self, real_state_machine, real_flow_config):
        """
        Scenario: User provides company size while asking about price.
        
        Input: "У нас 15 человек. Сколько стоит?"
        Expected: Answer price AND advance to next phase.
        """
        orchestrator = DialogueOrchestrator(
            state_machine=real_state_machine,
            flow_config=real_flow_config,
        )
        
        real_state_machine.state = "spin_situation"
        real_state_machine.collected_data = {}
        
        decision = orchestrator.process_turn(
            intent="price_question",
            extracted_data={"company_size": "15"},
            context_envelope=None,
        )
        
        assert decision.action == "answer_with_pricing"
        # Next state depends on actual config, but should NOT be spin_situation
        # if data_complete transition is defined
    
    def test_scenario_multiple_objections(self, real_state_machine, real_flow_config):
        """
        Scenario: User raises multiple objections.
        
        After reaching limit, should soft close.
        """
        orchestrator = DialogueOrchestrator(
            state_machine=real_state_machine,
            flow_config=real_flow_config,
        )
        
        real_state_machine.state = "spin_problem"
        
        # Simulate previous objections
        for _ in range(3):
            real_state_machine._intent_tracker.record("objection_price", "spin_problem")
        
        decision = orchestrator.process_turn(
            intent="objection_price",
            extracted_data={},
            context_envelope=None,
        )
        
        # Should trigger limit
        assert "objection_limit" in decision.action or decision.next_state == "soft_close"
    
    def test_scenario_normal_flow(self, real_state_machine, real_flow_config):
        """
        Scenario: Normal conversation flow.
        
        User provides situation info -> advance to problem phase.
        """
        orchestrator = DialogueOrchestrator(
            state_machine=real_state_machine,
            flow_config=real_flow_config,
        )
        
        real_state_machine.state = "spin_situation"
        real_state_machine.collected_data = {}
        
        # Provide required data
        decision = orchestrator.process_turn(
            intent="situation_provided",
            extracted_data={"company_size": "50", "industry": "tech"},
            context_envelope=None,
        )
        
        # Should have some action and potentially transition
        assert decision.action is not None
    
    def test_scenario_rejection(self, real_state_machine, real_flow_config):
        """
        Scenario: User rejects completely.
        
        Should transition to soft_close with BLOCKING action.
        """
        orchestrator = DialogueOrchestrator(
            state_machine=real_state_machine,
            flow_config=real_flow_config,
        )
        
        real_state_machine.state = "spin_situation"
        
        decision = orchestrator.process_turn(
            intent="rejection",
            extracted_data={},
            context_envelope=None,
        )
        
        # Rejection should block other transitions
        assert decision.next_state in ["soft_close", "spin_situation"]


class TestBugFixes:
    """
    Tests that verify Blackboard fixes known bugs from the old system.

    NOTE: Legacy система полностью удалена, эти тесты документируют
    исправленное поведение (не сравнивают с legacy).
    """

    def test_price_question_no_longer_blocks_transition(self):
        """
        Verify the core bug is fixed.

        OLD BEHAVIOR (BUG):
        - price_question -> return("answer_with_pricing", SAME_STATE)
        - data_complete check NEVER reached
        - Bot stuck in spin_situation asking same questions

        NEW BEHAVIOR (FIXED):
        - price_question -> propose_action("answer_with_pricing", combinable=True)
        - data_complete -> propose_transition("spin_problem")
        - BOTH applied — bot answers price AND advances to next phase
        """
        # Implementation in test_orchestrator.py::test_price_question_with_data_complete_scenario
        pass

    def test_persona_limits_respected(self):
        """
        Verify persona-specific objection limits work correctly.

        - aggressive persona: 5 consecutive, 8 total
        - busy persona: 2 consecutive, 4 total
        - default: 3 consecutive, 5 total
        """
        # Implementation in test_sources_objection.py
        pass

    def test_blocking_actions_work(self):
        """
        Verify combinable=False blocks transitions correctly.

        - rejection -> blocks data_complete transition
        - escalation -> blocks all other transitions
        - objection_limit_reached -> blocks continuation
        """
        # Implementation in test_conflict_resolver.py
        pass


class TestPerformance:
    """Performance benchmarks for Blackboard system."""
    
    def test_process_turn_latency(self, benchmark):
        """Benchmark process_turn latency."""
        # This would use pytest-benchmark
        pass
    
    def test_source_contribution_latency(self, benchmark):
        """Benchmark individual source contribution time."""
        pass
19. Regression Tests

# tests/test_blackboard_regression.py

import pytest
import json
from pathlib import Path


class TestBlackboardRegression:
    """
    Regression tests ensuring Blackboard produces EXPECTED behavior.

    NOTE: Эти тесты НЕ сравнивают с legacy системой (она удалена).
    Они проверяют что Blackboard работает как ЗАДУМАНО.
    """
    
    @pytest.fixture
    def regression_scenarios(self):
        """Load regression test scenarios."""
        scenarios_file = Path(__file__).parent / "fixtures" / "regression_scenarios.json"
        
        if scenarios_file.exists():
            with open(scenarios_file) as f:
                return json.load(f)
        
        # Default scenarios if file doesn't exist
        return [
            {
                "name": "price_question_with_data_complete",
                "initial_state": "spin_situation",
                "collected_data": {},
                "intent": "price_question",
                "extracted_data": {"company_size": "15"},
                "expected_action": "answer_with_pricing",
                "expected_state": "spin_problem",
                "expected_reason_codes": ["price_question_priority", "data_complete"],
            },
            {
                "name": "objection_within_limits",
                "initial_state": "spin_problem",
                "collected_data": {"company_size": "50"},
                "intent": "objection_price",
                "extracted_data": {},
                "objection_consecutive": 1,
                "objection_total": 2,
                "expected_action_not": "objection_limit_reached",
                "expected_state_not": "soft_close",
            },
            {
                "name": "objection_exceeds_limits",
                "initial_state": "spin_problem",
                "collected_data": {"company_size": "50"},
                "intent": "objection_price",
                "extracted_data": {},
                "objection_consecutive": 3,
                "objection_total": 5,
                "expected_action": "objection_limit_reached",
                "expected_state": "soft_close",
            },
            {
                "name": "rejection_blocks_transition",
                "initial_state": "spin_situation",
                "collected_data": {"company_size": "50"},  # Data complete
                "intent": "rejection",
                "extracted_data": {},
                "expected_state": "soft_close",
                # Even though data is complete, rejection should win
            },
        ]
    
    def test_regression_scenarios(self, regression_scenarios):
        """Run all regression scenarios."""
        from src.blackboard.orchestrator import DialogueOrchestrator
        from unittest.mock import Mock
        
        for scenario in regression_scenarios:
            # Setup
            sm = Mock()
            sm.state = scenario["initial_state"]
            sm.collected_data = scenario["collected_data"]
            sm._intent_tracker = Mock()
            sm._intent_tracker.turn_number = 0
            sm._intent_tracker.record = Mock()
            sm._intent_tracker.prev_intent = None
            sm._intent_tracker.objection_consecutive.return_value = scenario.get("objection_consecutive", 0)
            sm._intent_tracker.objection_total.return_value = scenario.get("objection_total", 0)
            sm._intent_tracker.total_count.return_value = 0
            sm._intent_tracker.category_total.return_value = 0
            
            flow_config = Mock()
            flow_config.states = {
                "spin_situation": {
                    "required_data": ["company_size"],
                    "is_final": False,
                    "transitions": {"data_complete": "spin_problem", "rejection": "soft_close"},
                    "rules": {},
                },
                "spin_problem": {
                    "required_data": [],
                    "is_final": False,
                    "transitions": {},
                    "rules": {},
                },
                "soft_close": {
                    "is_final": True,
                    "transitions": {},
                    "rules": {},
                },
            }
            
            orchestrator = DialogueOrchestrator(
                state_machine=sm,
                flow_config=flow_config,
            )
            
            # Execute
            decision = orchestrator.process_turn(
                intent=scenario["intent"],
                extracted_data=scenario["extracted_data"],
                context_envelope=None,
            )
            
            # Verify
            if "expected_action" in scenario:
                assert decision.action == scenario["expected_action"], \
                    f"Scenario '{scenario['name']}': expected action {scenario['expected_action']}, got {decision.action}"
            
            if "expected_state" in scenario:
                assert decision.next_state == scenario["expected_state"], \
                    f"Scenario '{scenario['name']}': expected state {scenario['expected_state']}, got {decision.next_state}"
            
            if "expected_action_not" in scenario:
                assert decision.action != scenario["expected_action_not"], \
                    f"Scenario '{scenario['name']}': action should NOT be {scenario['expected_action_not']}"
            
            if "expected_state_not" in scenario:
                assert decision.next_state != scenario["expected_state_not"], \
                    f"Scenario '{scenario['name']}': state should NOT be {scenario['expected_state_not']}"
            
            if "expected_reason_codes" in scenario:
                for code in scenario["expected_reason_codes"]:
                    assert code in decision.reason_codes, \
                        f"Scenario '{scenario['name']}': expected reason code {code} not found"
20. Verification Checklist

20.1 Pre-Development Checklist (Phase 1)

## Before Writing Any Code

### Understanding
- [ ] Полностью понял архитектуру Blackboard
- [ ] Понял как работает combinable флаг
- [ ] Понял разницу между 6 Knowledge Sources
- [ ] Знаю что именно удаляется из legacy кода


20.2 Pre-Integration Checklist (Phase 2)

## Before Integrating with SalesBot

### Unit Tests (MUST PASS)
- [ ] All unit tests pass: `pytest tests/test_blackboard*.py -v`
- [ ] Test coverage > 90%: `pytest --cov=src/blackboard tests/`
- [ ] No flaky tests (run 3x): `pytest tests/ --count=3`

### Core Functionality
- [ ] PriceQuestionSource proposes combinable=True actions
- [ ] DataCollectorSource proposes transitions correctly
- [ ] ObjectionGuardSource respects persona limits
- [ ] ConflictResolver merges combinable actions with transitions
- [ ] ConflictResolver blocks transitions for combinable=False actions

### Code Quality
- [ ] No linting errors: `ruff check src/blackboard/`
- [ ] Type hints complete: `mypy src/blackboard/`
- [ ] Docstrings for all public methods


20.3 Pre-Deployment Checklist (Phase 3)

## Before Deploying to Production

### All Tests MUST Pass
- [ ] Unit tests: `pytest tests/test_blackboard*.py -v`
- [ ] Integration tests: `pytest tests/test_blackboard_integration.py -v`
- [ ] Regression tests: `pytest tests/test_blackboard_regression.py -v`
- [ ] Full suite: `pytest tests/ -v`

### Legacy Code Removal Verification
- [ ] `grep -r "apply_rules" src/` returns NOTHING
- [ ] `grep -r "_process_legacy" src/` returns NOTHING
- [ ] `grep -r "shadow_mode" src/` returns NOTHING
- [ ] `grep -r "blackboard_enabled" src/` returns NOTHING
- [ ] `grep -r "traffic_percentage" src/` returns NOTHING

### Performance
- [ ] process_turn latency < 10ms (p99)
- [ ] Memory overhead < 10MB per conversation
- [ ] No memory leaks (run 1000 turns)

### Configuration
- [ ] constants.yaml has persona_limits
- [ ] settings.yaml has NO legacy flags
- [ ] All reason_codes documented

### Manual Testing
- [ ] Scenario: price_question + data_complete → BOTH applied
- [ ] Scenario: objection limit exceeded → soft_close
- [ ] Scenario: rejection → blocks transitions
- [ ] Scenario: normal SPIN flow → works correctly
- [ ] Scenario: escalation request → human_handoff


20.4 Post-Deployment Checklist (After Production Deploy)

## First 48 Hours After Deployment

### Error Monitoring
- [ ] Error rate < 0.1%
- [ ] No new error types
- [ ] No increase in exceptions

### Business Metrics
- [ ] Conversation completion rate stable or improved
- [ ] Lead conversion rate stable or improved
- [ ] Average conversation length stable

### Technical Metrics
- [ ] Response latency stable
- [ ] Memory usage stable
- [ ] CPU usage stable

### Improvements (Expected!)
- [ ] State loop count DECREASED (price_question bug fixed)
- [ ] More successful phase transitions
- [ ] Better handling of price questions with data

### Emergency Rollback Triggers
- [ ] Error rate > 1% for 15+ minutes → git revert
- [ ] Bot completely non-functional → git revert
- [ ] Data corruption detected → git revert
21. Summary: Code Changes

=== НОВЫЙ КОД ===

File                                    Lines    Purpose
─────────────────────────────────────────────────────────────────
src/blackboard/__init__.py              30       Module exports
src/blackboard/protocols.py             100      Hexagonal Architecture ports
src/blackboard/enums.py                 40       Priority, ProposalType
src/blackboard/models.py                200      Proposal, ResolvedDecision, ContextSnapshot
src/blackboard/blackboard.py            350      DialogueBlackboard
src/blackboard/knowledge_source.py      80       KnowledgeSource ABC
src/blackboard/source_registry.py       250      SourceRegistry (Plugin System)
src/blackboard/proposal_validator.py    150      ProposalValidator
src/blackboard/conflict_resolver.py     250      ConflictResolver
src/blackboard/event_bus.py             350      EventBus, Events, Subscribers
src/blackboard/orchestrator.py          420      DialogueOrchestrator
src/blackboard/sources/price_question.py    100  PriceQuestionSource
src/blackboard/sources/data_collector.py    100  DataCollectorSource
src/blackboard/sources/objection_guard.py   150  ObjectionGuardSource
src/blackboard/sources/intent_processor.py  150  IntentProcessorSource
src/blackboard/sources/transition_resolver.py 120 TransitionResolverSource
src/blackboard/sources/escalation.py        150  EscalationSource
─────────────────────────────────────────────────────────────────
Total New Code                          ~2,990

tests/test_blackboard*.py               ~1,700   Test suite
─────────────────────────────────────────────────────────────────
Total with Tests                        ~4,690


=== УДАЛЯЕМЫЙ КОД ===

File                     Lines Removed    What's Removed
─────────────────────────────────────────────────────────────────
src/state_machine.py     ~300            apply_rules() and related methods
src/bot.py               ~150            Shadow mode, legacy processing
yaml_config/settings.yaml ~20           Legacy feature flags
─────────────────────────────────────────────────────────────────
Total Removed            ~470


=== NET CHANGE ===

New Code:      +2,990 lines (production)
New Tests:     +1,700 lines (tests)
Removed Code:  -470 lines
─────────────────────────────────────────────────────────────────
Net Addition:  +4,220 lines

Но важнее количества — КАЧЕСТВО:
- Удалён запутанный legacy код с early returns
- Добавлена чистая, расширяемая архитектура
- Полное тестовое покрытие
22. Заключение
Данный план представляет собой полную спецификацию Dialogue Blackboard System с ПОЛНОЙ ЗАМЕНОЙ legacy системы.

=== ПРИНЦИП МИГРАЦИИ ===

❌ НЕТ shadow mode
❌ НЕТ gradual rollout
❌ НЕТ legacy кода после миграции
❌ НЕТ feature flags для переключения между системами

✅ ПОЛНАЯ замена apply_rules() на Blackboard
✅ УДАЛЕНИЕ всего legacy кода
✅ ЧИСТЫЙ codebase без "мёртвого" кода
✅ Rollback только через git revert (emergency only)


=== КЛЮЧЕВЫЕ ОСОБЕННОСТИ ПЛАНА ===

Архитектура:
✅ SourceRegistry (Plugin System) — динамическая регистрация Knowledge Sources
✅ Configuration-driven sources — включение/отключение sources через YAML
✅ @register_source декоратор для простой регистрации custom sources
✅ combinable флаг полностью реализован в ConflictResolver
✅ rejected_proposals добавлен в Decision Layer для debugging
✅ 6 Knowledge Sources с чётким разделением ответственности
✅ DialogueEventBus для observability
✅ ProposalValidator для валидации
✅ Hexagonal Architecture с Protocols для тестируемости

Миграция:
✅ 6-8 недель (вместо 10-12)
✅ Phase 1-2: Implementation & Testing
✅ Phase 3: Legacy Removal & Deployment
✅ Phase 4: Stabilization (buffer)
✅ Детальный список удаляемого кода

Решение корневой проблемы:
✅ price_question + data_complete применяются ОДНОВРЕМЕННО
✅ Blocking actions (rejection, escalation) корректно блокируют transitions
✅ Persona-specific objection limits


=== ПОСЛЕ МИГРАЦИИ ===

StateMachine остаётся, но ТОЛЬКО для:
- Хранения текущего state
- Хранения collected_data
- IntentTracker

StateMachine НЕ содержит:
- apply_rules() — УДАЛЁН
- _check_data_complete() — УДАЛЁН
- Любую логику выбора action/transition — УДАЛЕНА

Dialogue management = Blackboard. Точка.
